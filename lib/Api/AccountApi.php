<?php
/**
 * AccountApi
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0-beta2
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * AccountApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class AccountApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation restAccountLoginPost
     *
     * Login
     *
     * @param  \OpenAPI\Client\Model\InlineObject $_rest_account_login _rest_account_login (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TokenData
     */
    public function restAccountLoginPost($_rest_account_login = null)
    {
        list($response) = $this->restAccountLoginPostWithHttpInfo($_rest_account_login);
        return $response;
    }

    /**
     * Operation restAccountLoginPostWithHttpInfo
     *
     * Login
     *
     * @param  \OpenAPI\Client\Model\InlineObject $_rest_account_login (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TokenData, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountLoginPostWithHttpInfo($_rest_account_login = null)
    {
        $request = $this->restAccountLoginPostRequest($_rest_account_login);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TokenData' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TokenData', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TokenData';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TokenData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountLoginPostAsync
     *
     * Login
     *
     * @param  \OpenAPI\Client\Model\InlineObject $_rest_account_login (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountLoginPostAsync($_rest_account_login = null)
    {
        return $this->restAccountLoginPostAsyncWithHttpInfo($_rest_account_login)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountLoginPostAsyncWithHttpInfo
     *
     * Login
     *
     * @param  \OpenAPI\Client\Model\InlineObject $_rest_account_login (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountLoginPostAsyncWithHttpInfo($_rest_account_login = null)
    {
        $returnType = '\OpenAPI\Client\Model\TokenData';
        $request = $this->restAccountLoginPostRequest($_rest_account_login);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountLoginPost'
     *
     * @param  \OpenAPI\Client\Model\InlineObject $_rest_account_login (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountLoginPostRequest($_rest_account_login = null)
    {

        $resourcePath = '/rest/account/login';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_account_login)) {
            $_tempBody = $_rest_account_login;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountLoginRefreshPost
     *
     * Refresh
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountLoginRefreshPost()
    {
        $this->restAccountLoginRefreshPostWithHttpInfo();
    }

    /**
     * Operation restAccountLoginRefreshPostWithHttpInfo
     *
     * Refresh
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountLoginRefreshPostWithHttpInfo()
    {
        $request = $this->restAccountLoginRefreshPostRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountLoginRefreshPostAsync
     *
     * Refresh
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountLoginRefreshPostAsync()
    {
        return $this->restAccountLoginRefreshPostAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountLoginRefreshPostAsyncWithHttpInfo
     *
     * Refresh
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountLoginRefreshPostAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->restAccountLoginRefreshPostRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountLoginRefreshPost'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountLoginRefreshPostRequest()
    {

        $resourcePath = '/rest/account/login/refresh';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountLogoutPost
     *
     * Logout
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountLogoutPost()
    {
        $this->restAccountLogoutPostWithHttpInfo();
    }

    /**
     * Operation restAccountLogoutPostWithHttpInfo
     *
     * Logout
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountLogoutPostWithHttpInfo()
    {
        $request = $this->restAccountLogoutPostRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountLogoutPostAsync
     *
     * Logout
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountLogoutPostAsync()
    {
        return $this->restAccountLogoutPostAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountLogoutPostAsyncWithHttpInfo
     *
     * Logout
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountLogoutPostAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->restAccountLogoutPostRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountLogoutPost'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountLogoutPostRequest()
    {

        $resourcePath = '/rest/account/logout';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAccountIdContactsGet
     *
     * List contacts
     *
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Contact[]
     */
    public function restAccountsAccountIdContactsGet($account_id)
    {
        list($response) = $this->restAccountsAccountIdContactsGetWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation restAccountsAccountIdContactsGetWithHttpInfo
     *
     * List contacts
     *
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Contact[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAccountIdContactsGetWithHttpInfo($account_id)
    {
        $request = $this->restAccountsAccountIdContactsGetRequest($account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Contact[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Contact[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Contact[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Contact[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAccountIdContactsGetAsync
     *
     * List contacts
     *
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAccountIdContactsGetAsync($account_id)
    {
        return $this->restAccountsAccountIdContactsGetAsyncWithHttpInfo($account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAccountIdContactsGetAsyncWithHttpInfo
     *
     * List contacts
     *
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAccountIdContactsGetAsyncWithHttpInfo($account_id)
    {
        $returnType = '\OpenAPI\Client\Model\Contact[]';
        $request = $this->restAccountsAccountIdContactsGetRequest($account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAccountIdContactsGet'
     *
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAccountIdContactsGetRequest($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling restAccountsAccountIdContactsGet'
            );
        }

        $resourcePath = '/rest/accounts/{accountId}/contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAccountIdDelete
     *
     * Delete account
     *
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsAccountIdDelete($account_id)
    {
        $this->restAccountsAccountIdDeleteWithHttpInfo($account_id);
    }

    /**
     * Operation restAccountsAccountIdDeleteWithHttpInfo
     *
     * Delete account
     *
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAccountIdDeleteWithHttpInfo($account_id)
    {
        $request = $this->restAccountsAccountIdDeleteRequest($account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAccountIdDeleteAsync
     *
     * Delete account
     *
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAccountIdDeleteAsync($account_id)
    {
        return $this->restAccountsAccountIdDeleteAsyncWithHttpInfo($account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAccountIdDeleteAsyncWithHttpInfo
     *
     * Delete account
     *
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAccountIdDeleteAsyncWithHttpInfo($account_id)
    {
        $returnType = '';
        $request = $this->restAccountsAccountIdDeleteRequest($account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAccountIdDelete'
     *
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAccountIdDeleteRequest($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling restAccountsAccountIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAccountIdGet
     *
     * Get account
     *
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Account
     */
    public function restAccountsAccountIdGet($account_id)
    {
        list($response) = $this->restAccountsAccountIdGetWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation restAccountsAccountIdGetWithHttpInfo
     *
     * Get account
     *
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Account, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAccountIdGetWithHttpInfo($account_id)
    {
        $request = $this->restAccountsAccountIdGetRequest($account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Account' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Account', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Account';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Account',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAccountIdGetAsync
     *
     * Get account
     *
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAccountIdGetAsync($account_id)
    {
        return $this->restAccountsAccountIdGetAsyncWithHttpInfo($account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAccountIdGetAsyncWithHttpInfo
     *
     * Get account
     *
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAccountIdGetAsyncWithHttpInfo($account_id)
    {
        $returnType = '\OpenAPI\Client\Model\Account';
        $request = $this->restAccountsAccountIdGetRequest($account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAccountIdGet'
     *
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAccountIdGetRequest($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling restAccountsAccountIdGet'
            );
        }

        $resourcePath = '/rest/accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAccountIdPut
     *
     * Update account
     *
     * @param  int $account_id The ID of the account (required)
     * @param  \OpenAPI\Client\Model\InlineObject29 $_rest_accounts_account_id _rest_accounts_account_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Account
     */
    public function restAccountsAccountIdPut($account_id, $_rest_accounts_account_id = null)
    {
        list($response) = $this->restAccountsAccountIdPutWithHttpInfo($account_id, $_rest_accounts_account_id);
        return $response;
    }

    /**
     * Operation restAccountsAccountIdPutWithHttpInfo
     *
     * Update account
     *
     * @param  int $account_id The ID of the account (required)
     * @param  \OpenAPI\Client\Model\InlineObject29 $_rest_accounts_account_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Account, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAccountIdPutWithHttpInfo($account_id, $_rest_accounts_account_id = null)
    {
        $request = $this->restAccountsAccountIdPutRequest($account_id, $_rest_accounts_account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Account' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Account', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Account';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Account',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAccountIdPutAsync
     *
     * Update account
     *
     * @param  int $account_id The ID of the account (required)
     * @param  \OpenAPI\Client\Model\InlineObject29 $_rest_accounts_account_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAccountIdPutAsync($account_id, $_rest_accounts_account_id = null)
    {
        return $this->restAccountsAccountIdPutAsyncWithHttpInfo($account_id, $_rest_accounts_account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAccountIdPutAsyncWithHttpInfo
     *
     * Update account
     *
     * @param  int $account_id The ID of the account (required)
     * @param  \OpenAPI\Client\Model\InlineObject29 $_rest_accounts_account_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAccountIdPutAsyncWithHttpInfo($account_id, $_rest_accounts_account_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\Account';
        $request = $this->restAccountsAccountIdPutRequest($account_id, $_rest_accounts_account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAccountIdPut'
     *
     * @param  int $account_id The ID of the account (required)
     * @param  \OpenAPI\Client\Model\InlineObject29 $_rest_accounts_account_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAccountIdPutRequest($account_id, $_rest_accounts_account_id = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling restAccountsAccountIdPut'
            );
        }

        $resourcePath = '/rest/accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_account_id)) {
            $_tempBody = $_rest_accounts_account_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesAddressIdDelete
     *
     * Delete address
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsAddressesAddressIdDelete($address_id)
    {
        $this->restAccountsAddressesAddressIdDeleteWithHttpInfo($address_id);
    }

    /**
     * Operation restAccountsAddressesAddressIdDeleteWithHttpInfo
     *
     * Delete address
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesAddressIdDeleteWithHttpInfo($address_id)
    {
        $request = $this->restAccountsAddressesAddressIdDeleteRequest($address_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesAddressIdDeleteAsync
     *
     * Delete address
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdDeleteAsync($address_id)
    {
        return $this->restAccountsAddressesAddressIdDeleteAsyncWithHttpInfo($address_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesAddressIdDeleteAsyncWithHttpInfo
     *
     * Delete address
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdDeleteAsyncWithHttpInfo($address_id)
    {
        $returnType = '';
        $request = $this->restAccountsAddressesAddressIdDeleteRequest($address_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesAddressIdDelete'
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesAddressIdDeleteRequest($address_id)
    {
        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsAddressesAddressIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/addresses/{addressId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesAddressIdGet
     *
     * Get address
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Address
     */
    public function restAccountsAddressesAddressIdGet($address_id)
    {
        list($response) = $this->restAccountsAddressesAddressIdGetWithHttpInfo($address_id);
        return $response;
    }

    /**
     * Operation restAccountsAddressesAddressIdGetWithHttpInfo
     *
     * Get address
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Address, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesAddressIdGetWithHttpInfo($address_id)
    {
        $request = $this->restAccountsAddressesAddressIdGetRequest($address_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Address' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Address', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Address';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Address',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesAddressIdGetAsync
     *
     * Get address
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdGetAsync($address_id)
    {
        return $this->restAccountsAddressesAddressIdGetAsyncWithHttpInfo($address_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesAddressIdGetAsyncWithHttpInfo
     *
     * Get address
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdGetAsyncWithHttpInfo($address_id)
    {
        $returnType = '\OpenAPI\Client\Model\Address';
        $request = $this->restAccountsAddressesAddressIdGetRequest($address_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesAddressIdGet'
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesAddressIdGetRequest($address_id)
    {
        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsAddressesAddressIdGet'
            );
        }

        $resourcePath = '/rest/accounts/addresses/{addressId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsDelete
     *
     * Delete address option by addressId
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsAddressesAddressIdOptionsDelete($address_id)
    {
        $this->restAccountsAddressesAddressIdOptionsDeleteWithHttpInfo($address_id);
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsDeleteWithHttpInfo
     *
     * Delete address option by addressId
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesAddressIdOptionsDeleteWithHttpInfo($address_id)
    {
        $request = $this->restAccountsAddressesAddressIdOptionsDeleteRequest($address_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsDeleteAsync
     *
     * Delete address option by addressId
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdOptionsDeleteAsync($address_id)
    {
        return $this->restAccountsAddressesAddressIdOptionsDeleteAsyncWithHttpInfo($address_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsDeleteAsyncWithHttpInfo
     *
     * Delete address option by addressId
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdOptionsDeleteAsyncWithHttpInfo($address_id)
    {
        $returnType = '';
        $request = $this->restAccountsAddressesAddressIdOptionsDeleteRequest($address_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesAddressIdOptionsDelete'
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesAddressIdOptionsDeleteRequest($address_id)
    {
        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsAddressesAddressIdOptionsDelete'
            );
        }

        $resourcePath = '/rest/accounts/addresses/{addressId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsGet
     *
     * List address options
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AddressOption[]
     */
    public function restAccountsAddressesAddressIdOptionsGet($address_id)
    {
        list($response) = $this->restAccountsAddressesAddressIdOptionsGetWithHttpInfo($address_id);
        return $response;
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsGetWithHttpInfo
     *
     * List address options
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AddressOption[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesAddressIdOptionsGetWithHttpInfo($address_id)
    {
        $request = $this->restAccountsAddressesAddressIdOptionsGetRequest($address_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AddressOption[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AddressOption[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AddressOption[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AddressOption[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsGetAsync
     *
     * List address options
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdOptionsGetAsync($address_id)
    {
        return $this->restAccountsAddressesAddressIdOptionsGetAsyncWithHttpInfo($address_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsGetAsyncWithHttpInfo
     *
     * List address options
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdOptionsGetAsyncWithHttpInfo($address_id)
    {
        $returnType = '\OpenAPI\Client\Model\AddressOption[]';
        $request = $this->restAccountsAddressesAddressIdOptionsGetRequest($address_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesAddressIdOptionsGet'
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesAddressIdOptionsGetRequest($address_id)
    {
        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsAddressesAddressIdOptionsGet'
            );
        }

        $resourcePath = '/rest/accounts/addresses/{addressId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsPost
     *
     * Create address option
     *
     * @param  int $address_id The ID of the address (required)
     * @param  \OpenAPI\Client\Model\InlineObject10 $_rest_accounts_addresses_address_id_options _rest_accounts_addresses_address_id_options (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AddressOption[]
     */
    public function restAccountsAddressesAddressIdOptionsPost($address_id, $_rest_accounts_addresses_address_id_options = null)
    {
        list($response) = $this->restAccountsAddressesAddressIdOptionsPostWithHttpInfo($address_id, $_rest_accounts_addresses_address_id_options);
        return $response;
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsPostWithHttpInfo
     *
     * Create address option
     *
     * @param  int $address_id The ID of the address (required)
     * @param  \OpenAPI\Client\Model\InlineObject10 $_rest_accounts_addresses_address_id_options (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AddressOption[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesAddressIdOptionsPostWithHttpInfo($address_id, $_rest_accounts_addresses_address_id_options = null)
    {
        $request = $this->restAccountsAddressesAddressIdOptionsPostRequest($address_id, $_rest_accounts_addresses_address_id_options);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AddressOption[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AddressOption[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AddressOption[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AddressOption[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsPostAsync
     *
     * Create address option
     *
     * @param  int $address_id The ID of the address (required)
     * @param  \OpenAPI\Client\Model\InlineObject10 $_rest_accounts_addresses_address_id_options (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdOptionsPostAsync($address_id, $_rest_accounts_addresses_address_id_options = null)
    {
        return $this->restAccountsAddressesAddressIdOptionsPostAsyncWithHttpInfo($address_id, $_rest_accounts_addresses_address_id_options)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsPostAsyncWithHttpInfo
     *
     * Create address option
     *
     * @param  int $address_id The ID of the address (required)
     * @param  \OpenAPI\Client\Model\InlineObject10 $_rest_accounts_addresses_address_id_options (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdOptionsPostAsyncWithHttpInfo($address_id, $_rest_accounts_addresses_address_id_options = null)
    {
        $returnType = '\OpenAPI\Client\Model\AddressOption[]';
        $request = $this->restAccountsAddressesAddressIdOptionsPostRequest($address_id, $_rest_accounts_addresses_address_id_options);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesAddressIdOptionsPost'
     *
     * @param  int $address_id The ID of the address (required)
     * @param  \OpenAPI\Client\Model\InlineObject10 $_rest_accounts_addresses_address_id_options (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesAddressIdOptionsPostRequest($address_id, $_rest_accounts_addresses_address_id_options = null)
    {
        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsAddressesAddressIdOptionsPost'
            );
        }

        $resourcePath = '/rest/accounts/addresses/{addressId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_addresses_address_id_options)) {
            $_tempBody = $_rest_accounts_addresses_address_id_options;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsPut
     *
     * Update address option by addressId
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AddressOption[]
     */
    public function restAccountsAddressesAddressIdOptionsPut($address_id)
    {
        list($response) = $this->restAccountsAddressesAddressIdOptionsPutWithHttpInfo($address_id);
        return $response;
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsPutWithHttpInfo
     *
     * Update address option by addressId
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AddressOption[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesAddressIdOptionsPutWithHttpInfo($address_id)
    {
        $request = $this->restAccountsAddressesAddressIdOptionsPutRequest($address_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AddressOption[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AddressOption[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AddressOption[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AddressOption[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsPutAsync
     *
     * Update address option by addressId
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdOptionsPutAsync($address_id)
    {
        return $this->restAccountsAddressesAddressIdOptionsPutAsyncWithHttpInfo($address_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsPutAsyncWithHttpInfo
     *
     * Update address option by addressId
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdOptionsPutAsyncWithHttpInfo($address_id)
    {
        $returnType = '\OpenAPI\Client\Model\AddressOption[]';
        $request = $this->restAccountsAddressesAddressIdOptionsPutRequest($address_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesAddressIdOptionsPut'
     *
     * @param  int $address_id The ID of the address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesAddressIdOptionsPutRequest($address_id)
    {
        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsAddressesAddressIdOptionsPut'
            );
        }

        $resourcePath = '/rest/accounts/addresses/{addressId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesAddressIdPut
     *
     * Update address
     *
     * @param  int $address_id The ID of the address (required)
     * @param  \OpenAPI\Client\Model\InlineObject9 $_rest_accounts_addresses_address_id _rest_accounts_addresses_address_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Address
     */
    public function restAccountsAddressesAddressIdPut($address_id, $_rest_accounts_addresses_address_id = null)
    {
        list($response) = $this->restAccountsAddressesAddressIdPutWithHttpInfo($address_id, $_rest_accounts_addresses_address_id);
        return $response;
    }

    /**
     * Operation restAccountsAddressesAddressIdPutWithHttpInfo
     *
     * Update address
     *
     * @param  int $address_id The ID of the address (required)
     * @param  \OpenAPI\Client\Model\InlineObject9 $_rest_accounts_addresses_address_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Address, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesAddressIdPutWithHttpInfo($address_id, $_rest_accounts_addresses_address_id = null)
    {
        $request = $this->restAccountsAddressesAddressIdPutRequest($address_id, $_rest_accounts_addresses_address_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Address' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Address', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Address';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Address',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesAddressIdPutAsync
     *
     * Update address
     *
     * @param  int $address_id The ID of the address (required)
     * @param  \OpenAPI\Client\Model\InlineObject9 $_rest_accounts_addresses_address_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdPutAsync($address_id, $_rest_accounts_addresses_address_id = null)
    {
        return $this->restAccountsAddressesAddressIdPutAsyncWithHttpInfo($address_id, $_rest_accounts_addresses_address_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesAddressIdPutAsyncWithHttpInfo
     *
     * Update address
     *
     * @param  int $address_id The ID of the address (required)
     * @param  \OpenAPI\Client\Model\InlineObject9 $_rest_accounts_addresses_address_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdPutAsyncWithHttpInfo($address_id, $_rest_accounts_addresses_address_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\Address';
        $request = $this->restAccountsAddressesAddressIdPutRequest($address_id, $_rest_accounts_addresses_address_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesAddressIdPut'
     *
     * @param  int $address_id The ID of the address (required)
     * @param  \OpenAPI\Client\Model\InlineObject9 $_rest_accounts_addresses_address_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesAddressIdPutRequest($address_id, $_rest_accounts_addresses_address_id = null)
    {
        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsAddressesAddressIdPut'
            );
        }

        $resourcePath = '/rest/accounts/addresses/{addressId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_addresses_address_id)) {
            $_tempBody = $_rest_accounts_addresses_address_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesAddressIdRelatedDataGet
     *
     * Get address data by addressId
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $order_ids The ID of the orders (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Address
     */
    public function restAccountsAddressesAddressIdRelatedDataGet($address_id, $order_ids = null)
    {
        list($response) = $this->restAccountsAddressesAddressIdRelatedDataGetWithHttpInfo($address_id, $order_ids);
        return $response;
    }

    /**
     * Operation restAccountsAddressesAddressIdRelatedDataGetWithHttpInfo
     *
     * Get address data by addressId
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $order_ids The ID of the orders (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Address, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesAddressIdRelatedDataGetWithHttpInfo($address_id, $order_ids = null)
    {
        $request = $this->restAccountsAddressesAddressIdRelatedDataGetRequest($address_id, $order_ids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Address' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Address', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Address';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Address',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesAddressIdRelatedDataGetAsync
     *
     * Get address data by addressId
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $order_ids The ID of the orders (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdRelatedDataGetAsync($address_id, $order_ids = null)
    {
        return $this->restAccountsAddressesAddressIdRelatedDataGetAsyncWithHttpInfo($address_id, $order_ids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesAddressIdRelatedDataGetAsyncWithHttpInfo
     *
     * Get address data by addressId
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $order_ids The ID of the orders (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdRelatedDataGetAsyncWithHttpInfo($address_id, $order_ids = null)
    {
        $returnType = '\OpenAPI\Client\Model\Address';
        $request = $this->restAccountsAddressesAddressIdRelatedDataGetRequest($address_id, $order_ids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesAddressIdRelatedDataGet'
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $order_ids The ID of the orders (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesAddressIdRelatedDataGetRequest($address_id, $order_ids = null)
    {
        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsAddressesAddressIdRelatedDataGet'
            );
        }

        $resourcePath = '/rest/accounts/addresses/{addressId}/related_data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($order_ids)) {
            $order_ids = ObjectSerializer::serializeCollection($order_ids, '', true);
        }
        if ($order_ids !== null) {
            $queryParams['orderIds'] = $order_ids;
        }


        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesContactRelationsAddressContactRelationIdDelete
     *
     * Delete address contact relation
     *
     * @param  int $address_contact_relation_id The ID of the address contact relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdDelete($address_contact_relation_id)
    {
        $this->restAccountsAddressesContactRelationsAddressContactRelationIdDeleteWithHttpInfo($address_contact_relation_id);
    }

    /**
     * Operation restAccountsAddressesContactRelationsAddressContactRelationIdDeleteWithHttpInfo
     *
     * Delete address contact relation
     *
     * @param  int $address_contact_relation_id The ID of the address contact relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdDeleteWithHttpInfo($address_contact_relation_id)
    {
        $request = $this->restAccountsAddressesContactRelationsAddressContactRelationIdDeleteRequest($address_contact_relation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesContactRelationsAddressContactRelationIdDeleteAsync
     *
     * Delete address contact relation
     *
     * @param  int $address_contact_relation_id The ID of the address contact relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdDeleteAsync($address_contact_relation_id)
    {
        return $this->restAccountsAddressesContactRelationsAddressContactRelationIdDeleteAsyncWithHttpInfo($address_contact_relation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesContactRelationsAddressContactRelationIdDeleteAsyncWithHttpInfo
     *
     * Delete address contact relation
     *
     * @param  int $address_contact_relation_id The ID of the address contact relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdDeleteAsyncWithHttpInfo($address_contact_relation_id)
    {
        $returnType = '';
        $request = $this->restAccountsAddressesContactRelationsAddressContactRelationIdDeleteRequest($address_contact_relation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesContactRelationsAddressContactRelationIdDelete'
     *
     * @param  int $address_contact_relation_id The ID of the address contact relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesContactRelationsAddressContactRelationIdDeleteRequest($address_contact_relation_id)
    {
        // verify the required parameter 'address_contact_relation_id' is set
        if ($address_contact_relation_id === null || (is_array($address_contact_relation_id) && count($address_contact_relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_contact_relation_id when calling restAccountsAddressesContactRelationsAddressContactRelationIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/addresses/contact_relations/{addressContactRelationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($address_contact_relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressContactRelationId' . '}',
                ObjectSerializer::toPathValue($address_contact_relation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesContactRelationsAddressContactRelationIdGet
     *
     * Get address contact relation
     *
     * @param  int $address_contact_relation_id The ID of the address contact relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AddressContactRelation
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdGet($address_contact_relation_id)
    {
        list($response) = $this->restAccountsAddressesContactRelationsAddressContactRelationIdGetWithHttpInfo($address_contact_relation_id);
        return $response;
    }

    /**
     * Operation restAccountsAddressesContactRelationsAddressContactRelationIdGetWithHttpInfo
     *
     * Get address contact relation
     *
     * @param  int $address_contact_relation_id The ID of the address contact relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AddressContactRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdGetWithHttpInfo($address_contact_relation_id)
    {
        $request = $this->restAccountsAddressesContactRelationsAddressContactRelationIdGetRequest($address_contact_relation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AddressContactRelation' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AddressContactRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AddressContactRelation';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AddressContactRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesContactRelationsAddressContactRelationIdGetAsync
     *
     * Get address contact relation
     *
     * @param  int $address_contact_relation_id The ID of the address contact relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdGetAsync($address_contact_relation_id)
    {
        return $this->restAccountsAddressesContactRelationsAddressContactRelationIdGetAsyncWithHttpInfo($address_contact_relation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesContactRelationsAddressContactRelationIdGetAsyncWithHttpInfo
     *
     * Get address contact relation
     *
     * @param  int $address_contact_relation_id The ID of the address contact relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdGetAsyncWithHttpInfo($address_contact_relation_id)
    {
        $returnType = '\OpenAPI\Client\Model\AddressContactRelation';
        $request = $this->restAccountsAddressesContactRelationsAddressContactRelationIdGetRequest($address_contact_relation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesContactRelationsAddressContactRelationIdGet'
     *
     * @param  int $address_contact_relation_id The ID of the address contact relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesContactRelationsAddressContactRelationIdGetRequest($address_contact_relation_id)
    {
        // verify the required parameter 'address_contact_relation_id' is set
        if ($address_contact_relation_id === null || (is_array($address_contact_relation_id) && count($address_contact_relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_contact_relation_id when calling restAccountsAddressesContactRelationsAddressContactRelationIdGet'
            );
        }

        $resourcePath = '/rest/accounts/addresses/contact_relations/{addressContactRelationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($address_contact_relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressContactRelationId' . '}',
                ObjectSerializer::toPathValue($address_contact_relation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesContactRelationsGet
     *
     * List address contact relations
     *
     * @param  int $id Filter that restricts the search result to address contact relations with a specific ID (optional)
     * @param  int $contact_id Filter that restricts the search result to contacts with a specific ID (optional)
     * @param  int $type_id Filter that restricts the search result to address types with a specific ID (optional)
     * @param  int $address_id Filter that restricts the search result to addresses with a specific ID (optional)
     * @param  bool $is_primary Filter that restricts the search result depending on the flag used. If the flag isPrimary&#x3D;true is set, the filter restricts the search result to addresses that are primary addresses. If the flag isPrimary&#x3D;false is set, the filter restricts the search results to addresses that are not primary addresses. If no flag is set, both primary and non-primary addresses are listed. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  string $with Includes the specified address contact relation information in the results. The following parameters are available: contact and address. More than one parameter should be separated by commas. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse2001
     */
    public function restAccountsAddressesContactRelationsGet($id = null, $contact_id = null, $type_id = null, $address_id = null, $is_primary = null, $page = null, $items_per_page = null, $with = null)
    {
        list($response) = $this->restAccountsAddressesContactRelationsGetWithHttpInfo($id, $contact_id, $type_id, $address_id, $is_primary, $page, $items_per_page, $with);
        return $response;
    }

    /**
     * Operation restAccountsAddressesContactRelationsGetWithHttpInfo
     *
     * List address contact relations
     *
     * @param  int $id Filter that restricts the search result to address contact relations with a specific ID (optional)
     * @param  int $contact_id Filter that restricts the search result to contacts with a specific ID (optional)
     * @param  int $type_id Filter that restricts the search result to address types with a specific ID (optional)
     * @param  int $address_id Filter that restricts the search result to addresses with a specific ID (optional)
     * @param  bool $is_primary Filter that restricts the search result depending on the flag used. If the flag isPrimary&#x3D;true is set, the filter restricts the search result to addresses that are primary addresses. If the flag isPrimary&#x3D;false is set, the filter restricts the search results to addresses that are not primary addresses. If no flag is set, both primary and non-primary addresses are listed. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  string $with Includes the specified address contact relation information in the results. The following parameters are available: contact and address. More than one parameter should be separated by commas. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse2001, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesContactRelationsGetWithHttpInfo($id = null, $contact_id = null, $type_id = null, $address_id = null, $is_primary = null, $page = null, $items_per_page = null, $with = null)
    {
        $request = $this->restAccountsAddressesContactRelationsGetRequest($id, $contact_id, $type_id, $address_id, $is_primary, $page, $items_per_page, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse2001' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse2001', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse2001';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse2001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesContactRelationsGetAsync
     *
     * List address contact relations
     *
     * @param  int $id Filter that restricts the search result to address contact relations with a specific ID (optional)
     * @param  int $contact_id Filter that restricts the search result to contacts with a specific ID (optional)
     * @param  int $type_id Filter that restricts the search result to address types with a specific ID (optional)
     * @param  int $address_id Filter that restricts the search result to addresses with a specific ID (optional)
     * @param  bool $is_primary Filter that restricts the search result depending on the flag used. If the flag isPrimary&#x3D;true is set, the filter restricts the search result to addresses that are primary addresses. If the flag isPrimary&#x3D;false is set, the filter restricts the search results to addresses that are not primary addresses. If no flag is set, both primary and non-primary addresses are listed. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  string $with Includes the specified address contact relation information in the results. The following parameters are available: contact and address. More than one parameter should be separated by commas. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesContactRelationsGetAsync($id = null, $contact_id = null, $type_id = null, $address_id = null, $is_primary = null, $page = null, $items_per_page = null, $with = null)
    {
        return $this->restAccountsAddressesContactRelationsGetAsyncWithHttpInfo($id, $contact_id, $type_id, $address_id, $is_primary, $page, $items_per_page, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesContactRelationsGetAsyncWithHttpInfo
     *
     * List address contact relations
     *
     * @param  int $id Filter that restricts the search result to address contact relations with a specific ID (optional)
     * @param  int $contact_id Filter that restricts the search result to contacts with a specific ID (optional)
     * @param  int $type_id Filter that restricts the search result to address types with a specific ID (optional)
     * @param  int $address_id Filter that restricts the search result to addresses with a specific ID (optional)
     * @param  bool $is_primary Filter that restricts the search result depending on the flag used. If the flag isPrimary&#x3D;true is set, the filter restricts the search result to addresses that are primary addresses. If the flag isPrimary&#x3D;false is set, the filter restricts the search results to addresses that are not primary addresses. If no flag is set, both primary and non-primary addresses are listed. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  string $with Includes the specified address contact relation information in the results. The following parameters are available: contact and address. More than one parameter should be separated by commas. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesContactRelationsGetAsyncWithHttpInfo($id = null, $contact_id = null, $type_id = null, $address_id = null, $is_primary = null, $page = null, $items_per_page = null, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse2001';
        $request = $this->restAccountsAddressesContactRelationsGetRequest($id, $contact_id, $type_id, $address_id, $is_primary, $page, $items_per_page, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesContactRelationsGet'
     *
     * @param  int $id Filter that restricts the search result to address contact relations with a specific ID (optional)
     * @param  int $contact_id Filter that restricts the search result to contacts with a specific ID (optional)
     * @param  int $type_id Filter that restricts the search result to address types with a specific ID (optional)
     * @param  int $address_id Filter that restricts the search result to addresses with a specific ID (optional)
     * @param  bool $is_primary Filter that restricts the search result depending on the flag used. If the flag isPrimary&#x3D;true is set, the filter restricts the search result to addresses that are primary addresses. If the flag isPrimary&#x3D;false is set, the filter restricts the search results to addresses that are not primary addresses. If no flag is set, both primary and non-primary addresses are listed. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  string $with Includes the specified address contact relation information in the results. The following parameters are available: contact and address. More than one parameter should be separated by commas. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesContactRelationsGetRequest($id = null, $contact_id = null, $type_id = null, $address_id = null, $is_primary = null, $page = null, $items_per_page = null, $with = null)
    {

        $resourcePath = '/rest/accounts/addresses/contact_relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($id)) {
            $id = ObjectSerializer::serializeCollection($id, '', true);
        }
        if ($id !== null) {
            $queryParams['id'] = $id;
        }
        // query params
        if (is_array($contact_id)) {
            $contact_id = ObjectSerializer::serializeCollection($contact_id, '', true);
        }
        if ($contact_id !== null) {
            $queryParams['contactId'] = $contact_id;
        }
        // query params
        if (is_array($type_id)) {
            $type_id = ObjectSerializer::serializeCollection($type_id, '', true);
        }
        if ($type_id !== null) {
            $queryParams['typeId'] = $type_id;
        }
        // query params
        if (is_array($address_id)) {
            $address_id = ObjectSerializer::serializeCollection($address_id, '', true);
        }
        if ($address_id !== null) {
            $queryParams['addressId'] = $address_id;
        }
        // query params
        if (is_array($is_primary)) {
            $is_primary = ObjectSerializer::serializeCollection($is_primary, '', true);
        }
        if ($is_primary !== null) {
            $queryParams['isPrimary'] = $is_primary;
        }
        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesContactRelationsPost
     *
     * Create address contact relations
     *
     * @param  \OpenAPI\Client\Model\InlineObject6 $_rest_accounts_addresses_contact_relations _rest_accounts_addresses_contact_relations (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AddressContactRelation[]
     */
    public function restAccountsAddressesContactRelationsPost($_rest_accounts_addresses_contact_relations = null)
    {
        list($response) = $this->restAccountsAddressesContactRelationsPostWithHttpInfo($_rest_accounts_addresses_contact_relations);
        return $response;
    }

    /**
     * Operation restAccountsAddressesContactRelationsPostWithHttpInfo
     *
     * Create address contact relations
     *
     * @param  \OpenAPI\Client\Model\InlineObject6 $_rest_accounts_addresses_contact_relations (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AddressContactRelation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesContactRelationsPostWithHttpInfo($_rest_accounts_addresses_contact_relations = null)
    {
        $request = $this->restAccountsAddressesContactRelationsPostRequest($_rest_accounts_addresses_contact_relations);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AddressContactRelation[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AddressContactRelation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AddressContactRelation[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AddressContactRelation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesContactRelationsPostAsync
     *
     * Create address contact relations
     *
     * @param  \OpenAPI\Client\Model\InlineObject6 $_rest_accounts_addresses_contact_relations (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesContactRelationsPostAsync($_rest_accounts_addresses_contact_relations = null)
    {
        return $this->restAccountsAddressesContactRelationsPostAsyncWithHttpInfo($_rest_accounts_addresses_contact_relations)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesContactRelationsPostAsyncWithHttpInfo
     *
     * Create address contact relations
     *
     * @param  \OpenAPI\Client\Model\InlineObject6 $_rest_accounts_addresses_contact_relations (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesContactRelationsPostAsyncWithHttpInfo($_rest_accounts_addresses_contact_relations = null)
    {
        $returnType = '\OpenAPI\Client\Model\AddressContactRelation[]';
        $request = $this->restAccountsAddressesContactRelationsPostRequest($_rest_accounts_addresses_contact_relations);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesContactRelationsPost'
     *
     * @param  \OpenAPI\Client\Model\InlineObject6 $_rest_accounts_addresses_contact_relations (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesContactRelationsPostRequest($_rest_accounts_addresses_contact_relations = null)
    {

        $resourcePath = '/rest/accounts/addresses/contact_relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_addresses_contact_relations)) {
            $_tempBody = $_rest_accounts_addresses_contact_relations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesContactRelationsPut
     *
     * Update address contact relations
     *
     * @param  \OpenAPI\Client\Model\InlineObject5 $_rest_accounts_addresses_contact_relations _rest_accounts_addresses_contact_relations (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AddressContactRelation[]
     */
    public function restAccountsAddressesContactRelationsPut($_rest_accounts_addresses_contact_relations = null)
    {
        list($response) = $this->restAccountsAddressesContactRelationsPutWithHttpInfo($_rest_accounts_addresses_contact_relations);
        return $response;
    }

    /**
     * Operation restAccountsAddressesContactRelationsPutWithHttpInfo
     *
     * Update address contact relations
     *
     * @param  \OpenAPI\Client\Model\InlineObject5 $_rest_accounts_addresses_contact_relations (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AddressContactRelation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesContactRelationsPutWithHttpInfo($_rest_accounts_addresses_contact_relations = null)
    {
        $request = $this->restAccountsAddressesContactRelationsPutRequest($_rest_accounts_addresses_contact_relations);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AddressContactRelation[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AddressContactRelation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AddressContactRelation[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AddressContactRelation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesContactRelationsPutAsync
     *
     * Update address contact relations
     *
     * @param  \OpenAPI\Client\Model\InlineObject5 $_rest_accounts_addresses_contact_relations (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesContactRelationsPutAsync($_rest_accounts_addresses_contact_relations = null)
    {
        return $this->restAccountsAddressesContactRelationsPutAsyncWithHttpInfo($_rest_accounts_addresses_contact_relations)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesContactRelationsPutAsyncWithHttpInfo
     *
     * Update address contact relations
     *
     * @param  \OpenAPI\Client\Model\InlineObject5 $_rest_accounts_addresses_contact_relations (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesContactRelationsPutAsyncWithHttpInfo($_rest_accounts_addresses_contact_relations = null)
    {
        $returnType = '\OpenAPI\Client\Model\AddressContactRelation[]';
        $request = $this->restAccountsAddressesContactRelationsPutRequest($_rest_accounts_addresses_contact_relations);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesContactRelationsPut'
     *
     * @param  \OpenAPI\Client\Model\InlineObject5 $_rest_accounts_addresses_contact_relations (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesContactRelationsPutRequest($_rest_accounts_addresses_contact_relations = null)
    {

        $resourcePath = '/rest/accounts/addresses/contact_relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_addresses_contact_relations)) {
            $_tempBody = $_rest_accounts_addresses_contact_relations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesGet
     *
     * Get all available addresses
     *
     * @param  string $updated_to Filter that restricts the search result to addresses that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_from Filter that restricts the search result to addresses that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $created_to Filter that restricts the search result to addresses that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $created_from Filter that restricts the search result to addresses that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $with Includes the specified address information in the results. The following parameters are available: contactRelations, orderRelations. More than one parameter should be separated by commas. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Address
     */
    public function restAccountsAddressesGet($updated_to = null, $updated_from = null, $created_to = null, $created_from = null, $with = null, $page = null, $items_per_page = null)
    {
        list($response) = $this->restAccountsAddressesGetWithHttpInfo($updated_to, $updated_from, $created_to, $created_from, $with, $page, $items_per_page);
        return $response;
    }

    /**
     * Operation restAccountsAddressesGetWithHttpInfo
     *
     * Get all available addresses
     *
     * @param  string $updated_to Filter that restricts the search result to addresses that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_from Filter that restricts the search result to addresses that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $created_to Filter that restricts the search result to addresses that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $created_from Filter that restricts the search result to addresses that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $with Includes the specified address information in the results. The following parameters are available: contactRelations, orderRelations. More than one parameter should be separated by commas. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Address, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesGetWithHttpInfo($updated_to = null, $updated_from = null, $created_to = null, $created_from = null, $with = null, $page = null, $items_per_page = null)
    {
        $request = $this->restAccountsAddressesGetRequest($updated_to, $updated_from, $created_to, $created_from, $with, $page, $items_per_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Address' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Address', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Address';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Address',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesGetAsync
     *
     * Get all available addresses
     *
     * @param  string $updated_to Filter that restricts the search result to addresses that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_from Filter that restricts the search result to addresses that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $created_to Filter that restricts the search result to addresses that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $created_from Filter that restricts the search result to addresses that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $with Includes the specified address information in the results. The following parameters are available: contactRelations, orderRelations. More than one parameter should be separated by commas. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesGetAsync($updated_to = null, $updated_from = null, $created_to = null, $created_from = null, $with = null, $page = null, $items_per_page = null)
    {
        return $this->restAccountsAddressesGetAsyncWithHttpInfo($updated_to, $updated_from, $created_to, $created_from, $with, $page, $items_per_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesGetAsyncWithHttpInfo
     *
     * Get all available addresses
     *
     * @param  string $updated_to Filter that restricts the search result to addresses that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_from Filter that restricts the search result to addresses that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $created_to Filter that restricts the search result to addresses that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $created_from Filter that restricts the search result to addresses that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $with Includes the specified address information in the results. The following parameters are available: contactRelations, orderRelations. More than one parameter should be separated by commas. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesGetAsyncWithHttpInfo($updated_to = null, $updated_from = null, $created_to = null, $created_from = null, $with = null, $page = null, $items_per_page = null)
    {
        $returnType = '\OpenAPI\Client\Model\Address';
        $request = $this->restAccountsAddressesGetRequest($updated_to, $updated_from, $created_to, $created_from, $with, $page, $items_per_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesGet'
     *
     * @param  string $updated_to Filter that restricts the search result to addresses that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_from Filter that restricts the search result to addresses that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $created_to Filter that restricts the search result to addresses that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $created_from Filter that restricts the search result to addresses that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $with Includes the specified address information in the results. The following parameters are available: contactRelations, orderRelations. More than one parameter should be separated by commas. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesGetRequest($updated_to = null, $updated_from = null, $created_to = null, $created_from = null, $with = null, $page = null, $items_per_page = null)
    {

        $resourcePath = '/rest/accounts/addresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($updated_to)) {
            $updated_to = ObjectSerializer::serializeCollection($updated_to, '', true);
        }
        if ($updated_to !== null) {
            $queryParams['updatedTo'] = $updated_to;
        }
        // query params
        if (is_array($updated_from)) {
            $updated_from = ObjectSerializer::serializeCollection($updated_from, '', true);
        }
        if ($updated_from !== null) {
            $queryParams['updatedFrom'] = $updated_from;
        }
        // query params
        if (is_array($created_to)) {
            $created_to = ObjectSerializer::serializeCollection($created_to, '', true);
        }
        if ($created_to !== null) {
            $queryParams['createdTo'] = $created_to;
        }
        // query params
        if (is_array($created_from)) {
            $created_from = ObjectSerializer::serializeCollection($created_from, '', true);
        }
        if ($created_from !== null) {
            $queryParams['createdFrom'] = $created_from;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }
        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesOptionTypesGet
     *
     * List address option types
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AddressOptionType[]
     */
    public function restAccountsAddressesOptionTypesGet()
    {
        list($response) = $this->restAccountsAddressesOptionTypesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountsAddressesOptionTypesGetWithHttpInfo
     *
     * List address option types
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AddressOptionType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesOptionTypesGetWithHttpInfo()
    {
        $request = $this->restAccountsAddressesOptionTypesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AddressOptionType[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AddressOptionType[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AddressOptionType[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AddressOptionType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesOptionTypesGetAsync
     *
     * List address option types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionTypesGetAsync()
    {
        return $this->restAccountsAddressesOptionTypesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesOptionTypesGetAsyncWithHttpInfo
     *
     * List address option types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionTypesGetAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\AddressOptionType[]';
        $request = $this->restAccountsAddressesOptionTypesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesOptionTypesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesOptionTypesGetRequest()
    {

        $resourcePath = '/rest/accounts/addresses/option_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdDelete
     *
     * Delete address option type
     *
     * @param  int $option_type_id The ID of the address option type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdDelete($option_type_id)
    {
        $this->restAccountsAddressesOptionTypesOptionTypeIdDeleteWithHttpInfo($option_type_id);
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdDeleteWithHttpInfo
     *
     * Delete address option type
     *
     * @param  int $option_type_id The ID of the address option type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdDeleteWithHttpInfo($option_type_id)
    {
        $request = $this->restAccountsAddressesOptionTypesOptionTypeIdDeleteRequest($option_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdDeleteAsync
     *
     * Delete address option type
     *
     * @param  int $option_type_id The ID of the address option type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdDeleteAsync($option_type_id)
    {
        return $this->restAccountsAddressesOptionTypesOptionTypeIdDeleteAsyncWithHttpInfo($option_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdDeleteAsyncWithHttpInfo
     *
     * Delete address option type
     *
     * @param  int $option_type_id The ID of the address option type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdDeleteAsyncWithHttpInfo($option_type_id)
    {
        $returnType = '';
        $request = $this->restAccountsAddressesOptionTypesOptionTypeIdDeleteRequest($option_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesOptionTypesOptionTypeIdDelete'
     *
     * @param  int $option_type_id The ID of the address option type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesOptionTypesOptionTypeIdDeleteRequest($option_type_id)
    {
        // verify the required parameter 'option_type_id' is set
        if ($option_type_id === null || (is_array($option_type_id) && count($option_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_type_id when calling restAccountsAddressesOptionTypesOptionTypeIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/addresses/option_types/{optionTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionTypeId' . '}',
                ObjectSerializer::toPathValue($option_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdGet
     *
     * Get address option type
     *
     * @param  int $option_type_id The ID of the address option type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AddressOptionType
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdGet($option_type_id)
    {
        list($response) = $this->restAccountsAddressesOptionTypesOptionTypeIdGetWithHttpInfo($option_type_id);
        return $response;
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdGetWithHttpInfo
     *
     * Get address option type
     *
     * @param  int $option_type_id The ID of the address option type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AddressOptionType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdGetWithHttpInfo($option_type_id)
    {
        $request = $this->restAccountsAddressesOptionTypesOptionTypeIdGetRequest($option_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AddressOptionType' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AddressOptionType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AddressOptionType';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AddressOptionType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdGetAsync
     *
     * Get address option type
     *
     * @param  int $option_type_id The ID of the address option type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdGetAsync($option_type_id)
    {
        return $this->restAccountsAddressesOptionTypesOptionTypeIdGetAsyncWithHttpInfo($option_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdGetAsyncWithHttpInfo
     *
     * Get address option type
     *
     * @param  int $option_type_id The ID of the address option type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdGetAsyncWithHttpInfo($option_type_id)
    {
        $returnType = '\OpenAPI\Client\Model\AddressOptionType';
        $request = $this->restAccountsAddressesOptionTypesOptionTypeIdGetRequest($option_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesOptionTypesOptionTypeIdGet'
     *
     * @param  int $option_type_id The ID of the address option type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesOptionTypesOptionTypeIdGetRequest($option_type_id)
    {
        // verify the required parameter 'option_type_id' is set
        if ($option_type_id === null || (is_array($option_type_id) && count($option_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_type_id when calling restAccountsAddressesOptionTypesOptionTypeIdGet'
            );
        }

        $resourcePath = '/rest/accounts/addresses/option_types/{optionTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionTypeId' . '}',
                ObjectSerializer::toPathValue($option_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdPut
     *
     * Update address option type
     *
     * @param  int $option_type_id The ID of the address option type (required)
     * @param  \OpenAPI\Client\Model\InlineObject8 $_rest_accounts_addresses_option_types_option_type_id _rest_accounts_addresses_option_types_option_type_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AddressOptionType
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdPut($option_type_id, $_rest_accounts_addresses_option_types_option_type_id = null)
    {
        list($response) = $this->restAccountsAddressesOptionTypesOptionTypeIdPutWithHttpInfo($option_type_id, $_rest_accounts_addresses_option_types_option_type_id);
        return $response;
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdPutWithHttpInfo
     *
     * Update address option type
     *
     * @param  int $option_type_id The ID of the address option type (required)
     * @param  \OpenAPI\Client\Model\InlineObject8 $_rest_accounts_addresses_option_types_option_type_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AddressOptionType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdPutWithHttpInfo($option_type_id, $_rest_accounts_addresses_option_types_option_type_id = null)
    {
        $request = $this->restAccountsAddressesOptionTypesOptionTypeIdPutRequest($option_type_id, $_rest_accounts_addresses_option_types_option_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AddressOptionType' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AddressOptionType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AddressOptionType';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AddressOptionType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdPutAsync
     *
     * Update address option type
     *
     * @param  int $option_type_id The ID of the address option type (required)
     * @param  \OpenAPI\Client\Model\InlineObject8 $_rest_accounts_addresses_option_types_option_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdPutAsync($option_type_id, $_rest_accounts_addresses_option_types_option_type_id = null)
    {
        return $this->restAccountsAddressesOptionTypesOptionTypeIdPutAsyncWithHttpInfo($option_type_id, $_rest_accounts_addresses_option_types_option_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdPutAsyncWithHttpInfo
     *
     * Update address option type
     *
     * @param  int $option_type_id The ID of the address option type (required)
     * @param  \OpenAPI\Client\Model\InlineObject8 $_rest_accounts_addresses_option_types_option_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdPutAsyncWithHttpInfo($option_type_id, $_rest_accounts_addresses_option_types_option_type_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\AddressOptionType';
        $request = $this->restAccountsAddressesOptionTypesOptionTypeIdPutRequest($option_type_id, $_rest_accounts_addresses_option_types_option_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesOptionTypesOptionTypeIdPut'
     *
     * @param  int $option_type_id The ID of the address option type (required)
     * @param  \OpenAPI\Client\Model\InlineObject8 $_rest_accounts_addresses_option_types_option_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesOptionTypesOptionTypeIdPutRequest($option_type_id, $_rest_accounts_addresses_option_types_option_type_id = null)
    {
        // verify the required parameter 'option_type_id' is set
        if ($option_type_id === null || (is_array($option_type_id) && count($option_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_type_id when calling restAccountsAddressesOptionTypesOptionTypeIdPut'
            );
        }

        $resourcePath = '/rest/accounts/addresses/option_types/{optionTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionTypeId' . '}',
                ObjectSerializer::toPathValue($option_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_addresses_option_types_option_type_id)) {
            $_tempBody = $_rest_accounts_addresses_option_types_option_type_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesOptionTypesPost
     *
     * Create address option type
     *
     * @param  \OpenAPI\Client\Model\InlineObject7 $_rest_accounts_addresses_option_types _rest_accounts_addresses_option_types (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AddressOptionType
     */
    public function restAccountsAddressesOptionTypesPost($_rest_accounts_addresses_option_types = null)
    {
        list($response) = $this->restAccountsAddressesOptionTypesPostWithHttpInfo($_rest_accounts_addresses_option_types);
        return $response;
    }

    /**
     * Operation restAccountsAddressesOptionTypesPostWithHttpInfo
     *
     * Create address option type
     *
     * @param  \OpenAPI\Client\Model\InlineObject7 $_rest_accounts_addresses_option_types (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AddressOptionType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesOptionTypesPostWithHttpInfo($_rest_accounts_addresses_option_types = null)
    {
        $request = $this->restAccountsAddressesOptionTypesPostRequest($_rest_accounts_addresses_option_types);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AddressOptionType' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AddressOptionType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AddressOptionType';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AddressOptionType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesOptionTypesPostAsync
     *
     * Create address option type
     *
     * @param  \OpenAPI\Client\Model\InlineObject7 $_rest_accounts_addresses_option_types (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionTypesPostAsync($_rest_accounts_addresses_option_types = null)
    {
        return $this->restAccountsAddressesOptionTypesPostAsyncWithHttpInfo($_rest_accounts_addresses_option_types)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesOptionTypesPostAsyncWithHttpInfo
     *
     * Create address option type
     *
     * @param  \OpenAPI\Client\Model\InlineObject7 $_rest_accounts_addresses_option_types (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionTypesPostAsyncWithHttpInfo($_rest_accounts_addresses_option_types = null)
    {
        $returnType = '\OpenAPI\Client\Model\AddressOptionType';
        $request = $this->restAccountsAddressesOptionTypesPostRequest($_rest_accounts_addresses_option_types);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesOptionTypesPost'
     *
     * @param  \OpenAPI\Client\Model\InlineObject7 $_rest_accounts_addresses_option_types (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesOptionTypesPostRequest($_rest_accounts_addresses_option_types = null)
    {

        $resourcePath = '/rest/accounts/addresses/option_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_addresses_option_types)) {
            $_tempBody = $_rest_accounts_addresses_option_types;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdDelete
     *
     * Delete address option by option ID
     *
     * @param  int $option_id The ID of the address option (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsAddressesOptionsOptionIdDelete($option_id)
    {
        $this->restAccountsAddressesOptionsOptionIdDeleteWithHttpInfo($option_id);
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdDeleteWithHttpInfo
     *
     * Delete address option by option ID
     *
     * @param  int $option_id The ID of the address option (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesOptionsOptionIdDeleteWithHttpInfo($option_id)
    {
        $request = $this->restAccountsAddressesOptionsOptionIdDeleteRequest($option_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdDeleteAsync
     *
     * Delete address option by option ID
     *
     * @param  int $option_id The ID of the address option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionsOptionIdDeleteAsync($option_id)
    {
        return $this->restAccountsAddressesOptionsOptionIdDeleteAsyncWithHttpInfo($option_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdDeleteAsyncWithHttpInfo
     *
     * Delete address option by option ID
     *
     * @param  int $option_id The ID of the address option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionsOptionIdDeleteAsyncWithHttpInfo($option_id)
    {
        $returnType = '';
        $request = $this->restAccountsAddressesOptionsOptionIdDeleteRequest($option_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesOptionsOptionIdDelete'
     *
     * @param  int $option_id The ID of the address option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesOptionsOptionIdDeleteRequest($option_id)
    {
        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_id when calling restAccountsAddressesOptionsOptionIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/addresses/options/{optionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionId' . '}',
                ObjectSerializer::toPathValue($option_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdGet
     *
     * Get address option
     *
     * @param  int $option_id The ID of the address option (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AddressOption
     */
    public function restAccountsAddressesOptionsOptionIdGet($option_id)
    {
        list($response) = $this->restAccountsAddressesOptionsOptionIdGetWithHttpInfo($option_id);
        return $response;
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdGetWithHttpInfo
     *
     * Get address option
     *
     * @param  int $option_id The ID of the address option (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AddressOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesOptionsOptionIdGetWithHttpInfo($option_id)
    {
        $request = $this->restAccountsAddressesOptionsOptionIdGetRequest($option_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AddressOption' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AddressOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AddressOption';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AddressOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdGetAsync
     *
     * Get address option
     *
     * @param  int $option_id The ID of the address option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionsOptionIdGetAsync($option_id)
    {
        return $this->restAccountsAddressesOptionsOptionIdGetAsyncWithHttpInfo($option_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdGetAsyncWithHttpInfo
     *
     * Get address option
     *
     * @param  int $option_id The ID of the address option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionsOptionIdGetAsyncWithHttpInfo($option_id)
    {
        $returnType = '\OpenAPI\Client\Model\AddressOption';
        $request = $this->restAccountsAddressesOptionsOptionIdGetRequest($option_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesOptionsOptionIdGet'
     *
     * @param  int $option_id The ID of the address option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesOptionsOptionIdGetRequest($option_id)
    {
        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_id when calling restAccountsAddressesOptionsOptionIdGet'
            );
        }

        $resourcePath = '/rest/accounts/addresses/options/{optionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionId' . '}',
                ObjectSerializer::toPathValue($option_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdPut
     *
     * Update address option
     *
     * @param  int $option_id The ID of the address option (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AddressOption
     */
    public function restAccountsAddressesOptionsOptionIdPut($option_id)
    {
        list($response) = $this->restAccountsAddressesOptionsOptionIdPutWithHttpInfo($option_id);
        return $response;
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdPutWithHttpInfo
     *
     * Update address option
     *
     * @param  int $option_id The ID of the address option (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AddressOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesOptionsOptionIdPutWithHttpInfo($option_id)
    {
        $request = $this->restAccountsAddressesOptionsOptionIdPutRequest($option_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AddressOption' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AddressOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AddressOption';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AddressOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdPutAsync
     *
     * Update address option
     *
     * @param  int $option_id The ID of the address option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionsOptionIdPutAsync($option_id)
    {
        return $this->restAccountsAddressesOptionsOptionIdPutAsyncWithHttpInfo($option_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdPutAsyncWithHttpInfo
     *
     * Update address option
     *
     * @param  int $option_id The ID of the address option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionsOptionIdPutAsyncWithHttpInfo($option_id)
    {
        $returnType = '\OpenAPI\Client\Model\AddressOption';
        $request = $this->restAccountsAddressesOptionsOptionIdPutRequest($option_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesOptionsOptionIdPut'
     *
     * @param  int $option_id The ID of the address option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesOptionsOptionIdPutRequest($option_id)
    {
        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_id when calling restAccountsAddressesOptionsOptionIdPut'
            );
        }

        $resourcePath = '/rest/accounts/addresses/options/{optionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionId' . '}',
                ObjectSerializer::toPathValue($option_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdDelete
     *
     * Delete address POS relation
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdDelete($address_pos_relation_id)
    {
        $this->restAccountsAddressesPosRelationsAddressPosRelationIdDeleteWithHttpInfo($address_pos_relation_id);
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdDeleteWithHttpInfo
     *
     * Delete address POS relation
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdDeleteWithHttpInfo($address_pos_relation_id)
    {
        $request = $this->restAccountsAddressesPosRelationsAddressPosRelationIdDeleteRequest($address_pos_relation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdDeleteAsync
     *
     * Delete address POS relation
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdDeleteAsync($address_pos_relation_id)
    {
        return $this->restAccountsAddressesPosRelationsAddressPosRelationIdDeleteAsyncWithHttpInfo($address_pos_relation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdDeleteAsyncWithHttpInfo
     *
     * Delete address POS relation
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdDeleteAsyncWithHttpInfo($address_pos_relation_id)
    {
        $returnType = '';
        $request = $this->restAccountsAddressesPosRelationsAddressPosRelationIdDeleteRequest($address_pos_relation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesPosRelationsAddressPosRelationIdDelete'
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesPosRelationsAddressPosRelationIdDeleteRequest($address_pos_relation_id)
    {
        // verify the required parameter 'address_pos_relation_id' is set
        if ($address_pos_relation_id === null || (is_array($address_pos_relation_id) && count($address_pos_relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_pos_relation_id when calling restAccountsAddressesPosRelationsAddressPosRelationIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/addresses/pos_relations/{addressPosRelationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($address_pos_relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressPosRelationId' . '}',
                ObjectSerializer::toPathValue($address_pos_relation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdGet
     *
     * Get address POS relation
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AddressPosRelation
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdGet($address_pos_relation_id)
    {
        list($response) = $this->restAccountsAddressesPosRelationsAddressPosRelationIdGetWithHttpInfo($address_pos_relation_id);
        return $response;
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdGetWithHttpInfo
     *
     * Get address POS relation
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AddressPosRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdGetWithHttpInfo($address_pos_relation_id)
    {
        $request = $this->restAccountsAddressesPosRelationsAddressPosRelationIdGetRequest($address_pos_relation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AddressPosRelation' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AddressPosRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AddressPosRelation';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AddressPosRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdGetAsync
     *
     * Get address POS relation
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdGetAsync($address_pos_relation_id)
    {
        return $this->restAccountsAddressesPosRelationsAddressPosRelationIdGetAsyncWithHttpInfo($address_pos_relation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdGetAsyncWithHttpInfo
     *
     * Get address POS relation
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdGetAsyncWithHttpInfo($address_pos_relation_id)
    {
        $returnType = '\OpenAPI\Client\Model\AddressPosRelation';
        $request = $this->restAccountsAddressesPosRelationsAddressPosRelationIdGetRequest($address_pos_relation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesPosRelationsAddressPosRelationIdGet'
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesPosRelationsAddressPosRelationIdGetRequest($address_pos_relation_id)
    {
        // verify the required parameter 'address_pos_relation_id' is set
        if ($address_pos_relation_id === null || (is_array($address_pos_relation_id) && count($address_pos_relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_pos_relation_id when calling restAccountsAddressesPosRelationsAddressPosRelationIdGet'
            );
        }

        $resourcePath = '/rest/accounts/addresses/pos_relations/{addressPosRelationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($address_pos_relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressPosRelationId' . '}',
                ObjectSerializer::toPathValue($address_pos_relation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdPut
     *
     * Update address POS relation
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AddressPosRelation
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdPut($address_pos_relation_id)
    {
        list($response) = $this->restAccountsAddressesPosRelationsAddressPosRelationIdPutWithHttpInfo($address_pos_relation_id);
        return $response;
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdPutWithHttpInfo
     *
     * Update address POS relation
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AddressPosRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdPutWithHttpInfo($address_pos_relation_id)
    {
        $request = $this->restAccountsAddressesPosRelationsAddressPosRelationIdPutRequest($address_pos_relation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AddressPosRelation' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AddressPosRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AddressPosRelation';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AddressPosRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdPutAsync
     *
     * Update address POS relation
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdPutAsync($address_pos_relation_id)
    {
        return $this->restAccountsAddressesPosRelationsAddressPosRelationIdPutAsyncWithHttpInfo($address_pos_relation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdPutAsyncWithHttpInfo
     *
     * Update address POS relation
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdPutAsyncWithHttpInfo($address_pos_relation_id)
    {
        $returnType = '\OpenAPI\Client\Model\AddressPosRelation';
        $request = $this->restAccountsAddressesPosRelationsAddressPosRelationIdPutRequest($address_pos_relation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesPosRelationsAddressPosRelationIdPut'
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesPosRelationsAddressPosRelationIdPutRequest($address_pos_relation_id)
    {
        // verify the required parameter 'address_pos_relation_id' is set
        if ($address_pos_relation_id === null || (is_array($address_pos_relation_id) && count($address_pos_relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_pos_relation_id when calling restAccountsAddressesPosRelationsAddressPosRelationIdPut'
            );
        }

        $resourcePath = '/rest/accounts/addresses/pos_relations/{addressPosRelationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($address_pos_relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressPosRelationId' . '}',
                ObjectSerializer::toPathValue($address_pos_relation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesPosRelationsGet
     *
     * List address POS relations
     *
     * @param  int $page page (optional)
     * @param  int $items_per_page items per page (optional)
     * @param  string $with Includes the specified address pos relation information in the results. The following parameters are available: address and type. More than one parameter should be separated by commas. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse2002
     */
    public function restAccountsAddressesPosRelationsGet($page = null, $items_per_page = null, $with = null)
    {
        list($response) = $this->restAccountsAddressesPosRelationsGetWithHttpInfo($page, $items_per_page, $with);
        return $response;
    }

    /**
     * Operation restAccountsAddressesPosRelationsGetWithHttpInfo
     *
     * List address POS relations
     *
     * @param  int $page page (optional)
     * @param  int $items_per_page items per page (optional)
     * @param  string $with Includes the specified address pos relation information in the results. The following parameters are available: address and type. More than one parameter should be separated by commas. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse2002, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesPosRelationsGetWithHttpInfo($page = null, $items_per_page = null, $with = null)
    {
        $request = $this->restAccountsAddressesPosRelationsGetRequest($page, $items_per_page, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse2002' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse2002', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse2002';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse2002',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesPosRelationsGetAsync
     *
     * List address POS relations
     *
     * @param  int $page page (optional)
     * @param  int $items_per_page items per page (optional)
     * @param  string $with Includes the specified address pos relation information in the results. The following parameters are available: address and type. More than one parameter should be separated by commas. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesPosRelationsGetAsync($page = null, $items_per_page = null, $with = null)
    {
        return $this->restAccountsAddressesPosRelationsGetAsyncWithHttpInfo($page, $items_per_page, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesPosRelationsGetAsyncWithHttpInfo
     *
     * List address POS relations
     *
     * @param  int $page page (optional)
     * @param  int $items_per_page items per page (optional)
     * @param  string $with Includes the specified address pos relation information in the results. The following parameters are available: address and type. More than one parameter should be separated by commas. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesPosRelationsGetAsyncWithHttpInfo($page = null, $items_per_page = null, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse2002';
        $request = $this->restAccountsAddressesPosRelationsGetRequest($page, $items_per_page, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesPosRelationsGet'
     *
     * @param  int $page page (optional)
     * @param  int $items_per_page items per page (optional)
     * @param  string $with Includes the specified address pos relation information in the results. The following parameters are available: address and type. More than one parameter should be separated by commas. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesPosRelationsGetRequest($page = null, $items_per_page = null, $with = null)
    {

        $resourcePath = '/rest/accounts/addresses/pos_relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesPosRelationsPost
     *
     * Create address POS relation
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AddressPosRelation
     */
    public function restAccountsAddressesPosRelationsPost()
    {
        list($response) = $this->restAccountsAddressesPosRelationsPostWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountsAddressesPosRelationsPostWithHttpInfo
     *
     * Create address POS relation
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AddressPosRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesPosRelationsPostWithHttpInfo()
    {
        $request = $this->restAccountsAddressesPosRelationsPostRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AddressPosRelation' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AddressPosRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AddressPosRelation';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AddressPosRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesPosRelationsPostAsync
     *
     * Create address POS relation
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesPosRelationsPostAsync()
    {
        return $this->restAccountsAddressesPosRelationsPostAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesPosRelationsPostAsyncWithHttpInfo
     *
     * Create address POS relation
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesPosRelationsPostAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\AddressPosRelation';
        $request = $this->restAccountsAddressesPosRelationsPostRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesPosRelationsPost'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesPosRelationsPostRequest()
    {

        $resourcePath = '/rest/accounts/addresses/pos_relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesPost
     *
     * Create address
     *
     * @param  \OpenAPI\Client\Model\InlineObject4 $_rest_accounts_addresses _rest_accounts_addresses (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Address
     */
    public function restAccountsAddressesPost($_rest_accounts_addresses = null)
    {
        list($response) = $this->restAccountsAddressesPostWithHttpInfo($_rest_accounts_addresses);
        return $response;
    }

    /**
     * Operation restAccountsAddressesPostWithHttpInfo
     *
     * Create address
     *
     * @param  \OpenAPI\Client\Model\InlineObject4 $_rest_accounts_addresses (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Address, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesPostWithHttpInfo($_rest_accounts_addresses = null)
    {
        $request = $this->restAccountsAddressesPostRequest($_rest_accounts_addresses);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Address' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Address', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Address';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Address',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesPostAsync
     *
     * Create address
     *
     * @param  \OpenAPI\Client\Model\InlineObject4 $_rest_accounts_addresses (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesPostAsync($_rest_accounts_addresses = null)
    {
        return $this->restAccountsAddressesPostAsyncWithHttpInfo($_rest_accounts_addresses)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesPostAsyncWithHttpInfo
     *
     * Create address
     *
     * @param  \OpenAPI\Client\Model\InlineObject4 $_rest_accounts_addresses (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesPostAsyncWithHttpInfo($_rest_accounts_addresses = null)
    {
        $returnType = '\OpenAPI\Client\Model\Address';
        $request = $this->restAccountsAddressesPostRequest($_rest_accounts_addresses);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesPost'
     *
     * @param  \OpenAPI\Client\Model\InlineObject4 $_rest_accounts_addresses (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesPostRequest($_rest_accounts_addresses = null)
    {

        $resourcePath = '/rest/accounts/addresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_addresses)) {
            $_tempBody = $_rest_accounts_addresses;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesRelationTypesGet
     *
     * List address relation types
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AddressRelationType[]
     */
    public function restAccountsAddressesRelationTypesGet()
    {
        list($response) = $this->restAccountsAddressesRelationTypesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountsAddressesRelationTypesGetWithHttpInfo
     *
     * List address relation types
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AddressRelationType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesRelationTypesGetWithHttpInfo()
    {
        $request = $this->restAccountsAddressesRelationTypesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AddressRelationType[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AddressRelationType[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AddressRelationType[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AddressRelationType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesRelationTypesGetAsync
     *
     * List address relation types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesRelationTypesGetAsync()
    {
        return $this->restAccountsAddressesRelationTypesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesRelationTypesGetAsyncWithHttpInfo
     *
     * List address relation types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesRelationTypesGetAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\AddressRelationType[]';
        $request = $this->restAccountsAddressesRelationTypesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesRelationTypesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesRelationTypesGetRequest()
    {

        $resourcePath = '/rest/accounts/addresses/relation_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesRelationsTypesApplicationsApplicationLangGet
     *
     * List address relation types
     *
     * @param  string $application The application type (required)
     * @param  string $lang The language as ISO 639-1 code (e.g. &#x60;en&#x60; for English) (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restAccountsAddressesRelationsTypesApplicationsApplicationLangGet($application, $lang)
    {
        list($response) = $this->restAccountsAddressesRelationsTypesApplicationsApplicationLangGetWithHttpInfo($application, $lang);
        return $response;
    }

    /**
     * Operation restAccountsAddressesRelationsTypesApplicationsApplicationLangGetWithHttpInfo
     *
     * List address relation types
     *
     * @param  string $application The application type (required)
     * @param  string $lang The language as ISO 639-1 code (e.g. &#x60;en&#x60; for English) (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesRelationsTypesApplicationsApplicationLangGetWithHttpInfo($application, $lang)
    {
        $request = $this->restAccountsAddressesRelationsTypesApplicationsApplicationLangGetRequest($application, $lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesRelationsTypesApplicationsApplicationLangGetAsync
     *
     * List address relation types
     *
     * @param  string $application The application type (required)
     * @param  string $lang The language as ISO 639-1 code (e.g. &#x60;en&#x60; for English) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesRelationsTypesApplicationsApplicationLangGetAsync($application, $lang)
    {
        return $this->restAccountsAddressesRelationsTypesApplicationsApplicationLangGetAsyncWithHttpInfo($application, $lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesRelationsTypesApplicationsApplicationLangGetAsyncWithHttpInfo
     *
     * List address relation types
     *
     * @param  string $application The application type (required)
     * @param  string $lang The language as ISO 639-1 code (e.g. &#x60;en&#x60; for English) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesRelationsTypesApplicationsApplicationLangGetAsyncWithHttpInfo($application, $lang)
    {
        $returnType = 'object';
        $request = $this->restAccountsAddressesRelationsTypesApplicationsApplicationLangGetRequest($application, $lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesRelationsTypesApplicationsApplicationLangGet'
     *
     * @param  string $application The application type (required)
     * @param  string $lang The language as ISO 639-1 code (e.g. &#x60;en&#x60; for English) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesRelationsTypesApplicationsApplicationLangGetRequest($application, $lang)
    {
        // verify the required parameter 'application' is set
        if ($application === null || (is_array($application) && count($application) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application when calling restAccountsAddressesRelationsTypesApplicationsApplicationLangGet'
            );
        }
        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lang when calling restAccountsAddressesRelationsTypesApplicationsApplicationLangGet'
            );
        }

        $resourcePath = '/rest/accounts/addresses/relations/types/applications/{application}/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($application !== null) {
            $resourcePath = str_replace(
                '{' . 'application' . '}',
                ObjectSerializer::toPathValue($application),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsPost
     *
     * Create address warehouse relation
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AddressWarehouseRelation
     */
    public function restAccountsAddressesWarehouseRelationsPost()
    {
        list($response) = $this->restAccountsAddressesWarehouseRelationsPostWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsPostWithHttpInfo
     *
     * Create address warehouse relation
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AddressWarehouseRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesWarehouseRelationsPostWithHttpInfo()
    {
        $request = $this->restAccountsAddressesWarehouseRelationsPostRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AddressWarehouseRelation' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AddressWarehouseRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AddressWarehouseRelation';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AddressWarehouseRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsPostAsync
     *
     * Create address warehouse relation
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesWarehouseRelationsPostAsync()
    {
        return $this->restAccountsAddressesWarehouseRelationsPostAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsPostAsyncWithHttpInfo
     *
     * Create address warehouse relation
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesWarehouseRelationsPostAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\AddressWarehouseRelation';
        $request = $this->restAccountsAddressesWarehouseRelationsPostRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesWarehouseRelationsPost'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesWarehouseRelationsPostRequest()
    {

        $resourcePath = '/rest/accounts/addresses/warehouse_relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsRelationIdDelete
     *
     * Delete address warehouse relation
     *
     * @param  int $relation_id The ID of the address warehouse relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdDelete($relation_id)
    {
        $this->restAccountsAddressesWarehouseRelationsRelationIdDeleteWithHttpInfo($relation_id);
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsRelationIdDeleteWithHttpInfo
     *
     * Delete address warehouse relation
     *
     * @param  int $relation_id The ID of the address warehouse relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdDeleteWithHttpInfo($relation_id)
    {
        $request = $this->restAccountsAddressesWarehouseRelationsRelationIdDeleteRequest($relation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsRelationIdDeleteAsync
     *
     * Delete address warehouse relation
     *
     * @param  int $relation_id The ID of the address warehouse relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdDeleteAsync($relation_id)
    {
        return $this->restAccountsAddressesWarehouseRelationsRelationIdDeleteAsyncWithHttpInfo($relation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsRelationIdDeleteAsyncWithHttpInfo
     *
     * Delete address warehouse relation
     *
     * @param  int $relation_id The ID of the address warehouse relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdDeleteAsyncWithHttpInfo($relation_id)
    {
        $returnType = '';
        $request = $this->restAccountsAddressesWarehouseRelationsRelationIdDeleteRequest($relation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesWarehouseRelationsRelationIdDelete'
     *
     * @param  int $relation_id The ID of the address warehouse relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesWarehouseRelationsRelationIdDeleteRequest($relation_id)
    {
        // verify the required parameter 'relation_id' is set
        if ($relation_id === null || (is_array($relation_id) && count($relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relation_id when calling restAccountsAddressesWarehouseRelationsRelationIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/addresses/warehouse_relations/{relationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationId' . '}',
                ObjectSerializer::toPathValue($relation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsRelationIdPut
     *
     * Update address warehouse relation
     *
     * @param  int $relation_id The ID of the address warehouse relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AddressWarehouseRelation
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdPut($relation_id)
    {
        list($response) = $this->restAccountsAddressesWarehouseRelationsRelationIdPutWithHttpInfo($relation_id);
        return $response;
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsRelationIdPutWithHttpInfo
     *
     * Update address warehouse relation
     *
     * @param  int $relation_id The ID of the address warehouse relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AddressWarehouseRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdPutWithHttpInfo($relation_id)
    {
        $request = $this->restAccountsAddressesWarehouseRelationsRelationIdPutRequest($relation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AddressWarehouseRelation' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AddressWarehouseRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AddressWarehouseRelation';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AddressWarehouseRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsRelationIdPutAsync
     *
     * Update address warehouse relation
     *
     * @param  int $relation_id The ID of the address warehouse relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdPutAsync($relation_id)
    {
        return $this->restAccountsAddressesWarehouseRelationsRelationIdPutAsyncWithHttpInfo($relation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsRelationIdPutAsyncWithHttpInfo
     *
     * Update address warehouse relation
     *
     * @param  int $relation_id The ID of the address warehouse relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdPutAsyncWithHttpInfo($relation_id)
    {
        $returnType = '\OpenAPI\Client\Model\AddressWarehouseRelation';
        $request = $this->restAccountsAddressesWarehouseRelationsRelationIdPutRequest($relation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesWarehouseRelationsRelationIdPut'
     *
     * @param  int $relation_id The ID of the address warehouse relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesWarehouseRelationsRelationIdPutRequest($relation_id)
    {
        // verify the required parameter 'relation_id' is set
        if ($relation_id === null || (is_array($relation_id) && count($relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relation_id when calling restAccountsAddressesWarehouseRelationsRelationIdPut'
            );
        }

        $resourcePath = '/rest/accounts/addresses/warehouse_relations/{relationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationId' . '}',
                ObjectSerializer::toPathValue($relation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactRelationsAccountContactRelationIdDelete
     *
     * Delete account contact relation
     *
     * @param  int $account_contact_relation_id The ID of the account contact relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactRelationsAccountContactRelationIdDelete($account_contact_relation_id)
    {
        $this->restAccountsContactRelationsAccountContactRelationIdDeleteWithHttpInfo($account_contact_relation_id);
    }

    /**
     * Operation restAccountsContactRelationsAccountContactRelationIdDeleteWithHttpInfo
     *
     * Delete account contact relation
     *
     * @param  int $account_contact_relation_id The ID of the account contact relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactRelationsAccountContactRelationIdDeleteWithHttpInfo($account_contact_relation_id)
    {
        $request = $this->restAccountsContactRelationsAccountContactRelationIdDeleteRequest($account_contact_relation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactRelationsAccountContactRelationIdDeleteAsync
     *
     * Delete account contact relation
     *
     * @param  int $account_contact_relation_id The ID of the account contact relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactRelationsAccountContactRelationIdDeleteAsync($account_contact_relation_id)
    {
        return $this->restAccountsContactRelationsAccountContactRelationIdDeleteAsyncWithHttpInfo($account_contact_relation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactRelationsAccountContactRelationIdDeleteAsyncWithHttpInfo
     *
     * Delete account contact relation
     *
     * @param  int $account_contact_relation_id The ID of the account contact relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactRelationsAccountContactRelationIdDeleteAsyncWithHttpInfo($account_contact_relation_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactRelationsAccountContactRelationIdDeleteRequest($account_contact_relation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactRelationsAccountContactRelationIdDelete'
     *
     * @param  int $account_contact_relation_id The ID of the account contact relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactRelationsAccountContactRelationIdDeleteRequest($account_contact_relation_id)
    {
        // verify the required parameter 'account_contact_relation_id' is set
        if ($account_contact_relation_id === null || (is_array($account_contact_relation_id) && count($account_contact_relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_contact_relation_id when calling restAccountsContactRelationsAccountContactRelationIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/contact_relations/{accountContactRelationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_contact_relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountContactRelationId' . '}',
                ObjectSerializer::toPathValue($account_contact_relation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactRelationsAccountContactRelationIdGet
     *
     * Get account contact relation
     *
     * @param  int $account_contact_relation_id The ID of the account contact relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AccountContactRelation
     */
    public function restAccountsContactRelationsAccountContactRelationIdGet($account_contact_relation_id)
    {
        list($response) = $this->restAccountsContactRelationsAccountContactRelationIdGetWithHttpInfo($account_contact_relation_id);
        return $response;
    }

    /**
     * Operation restAccountsContactRelationsAccountContactRelationIdGetWithHttpInfo
     *
     * Get account contact relation
     *
     * @param  int $account_contact_relation_id The ID of the account contact relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AccountContactRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactRelationsAccountContactRelationIdGetWithHttpInfo($account_contact_relation_id)
    {
        $request = $this->restAccountsContactRelationsAccountContactRelationIdGetRequest($account_contact_relation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AccountContactRelation' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AccountContactRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AccountContactRelation';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AccountContactRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactRelationsAccountContactRelationIdGetAsync
     *
     * Get account contact relation
     *
     * @param  int $account_contact_relation_id The ID of the account contact relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactRelationsAccountContactRelationIdGetAsync($account_contact_relation_id)
    {
        return $this->restAccountsContactRelationsAccountContactRelationIdGetAsyncWithHttpInfo($account_contact_relation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactRelationsAccountContactRelationIdGetAsyncWithHttpInfo
     *
     * Get account contact relation
     *
     * @param  int $account_contact_relation_id The ID of the account contact relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactRelationsAccountContactRelationIdGetAsyncWithHttpInfo($account_contact_relation_id)
    {
        $returnType = '\OpenAPI\Client\Model\AccountContactRelation';
        $request = $this->restAccountsContactRelationsAccountContactRelationIdGetRequest($account_contact_relation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactRelationsAccountContactRelationIdGet'
     *
     * @param  int $account_contact_relation_id The ID of the account contact relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactRelationsAccountContactRelationIdGetRequest($account_contact_relation_id)
    {
        // verify the required parameter 'account_contact_relation_id' is set
        if ($account_contact_relation_id === null || (is_array($account_contact_relation_id) && count($account_contact_relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_contact_relation_id when calling restAccountsContactRelationsAccountContactRelationIdGet'
            );
        }

        $resourcePath = '/rest/accounts/contact_relations/{accountContactRelationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_contact_relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountContactRelationId' . '}',
                ObjectSerializer::toPathValue($account_contact_relation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdDelete
     *
     * Delete bank account
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsBanksContactBankIdDelete($contact_bank_id)
    {
        $this->restAccountsContactsBanksContactBankIdDeleteWithHttpInfo($contact_bank_id);
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdDeleteWithHttpInfo
     *
     * Delete bank account
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsBanksContactBankIdDeleteWithHttpInfo($contact_bank_id)
    {
        $request = $this->restAccountsContactsBanksContactBankIdDeleteRequest($contact_bank_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdDeleteAsync
     *
     * Delete bank account
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsBanksContactBankIdDeleteAsync($contact_bank_id)
    {
        return $this->restAccountsContactsBanksContactBankIdDeleteAsyncWithHttpInfo($contact_bank_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdDeleteAsyncWithHttpInfo
     *
     * Delete bank account
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsBanksContactBankIdDeleteAsyncWithHttpInfo($contact_bank_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsBanksContactBankIdDeleteRequest($contact_bank_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsBanksContactBankIdDelete'
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsBanksContactBankIdDeleteRequest($contact_bank_id)
    {
        // verify the required parameter 'contact_bank_id' is set
        if ($contact_bank_id === null || (is_array($contact_bank_id) && count($contact_bank_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_bank_id when calling restAccountsContactsBanksContactBankIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/contacts/banks/{contactBankId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_bank_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactBankId' . '}',
                ObjectSerializer::toPathValue($contact_bank_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdGet
     *
     * Get bank account
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactBank
     */
    public function restAccountsContactsBanksContactBankIdGet($contact_bank_id)
    {
        list($response) = $this->restAccountsContactsBanksContactBankIdGetWithHttpInfo($contact_bank_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdGetWithHttpInfo
     *
     * Get bank account
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactBank, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsBanksContactBankIdGetWithHttpInfo($contact_bank_id)
    {
        $request = $this->restAccountsContactsBanksContactBankIdGetRequest($contact_bank_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactBank' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactBank', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactBank';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactBank',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdGetAsync
     *
     * Get bank account
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsBanksContactBankIdGetAsync($contact_bank_id)
    {
        return $this->restAccountsContactsBanksContactBankIdGetAsyncWithHttpInfo($contact_bank_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdGetAsyncWithHttpInfo
     *
     * Get bank account
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsBanksContactBankIdGetAsyncWithHttpInfo($contact_bank_id)
    {
        $returnType = '\OpenAPI\Client\Model\ContactBank';
        $request = $this->restAccountsContactsBanksContactBankIdGetRequest($contact_bank_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsBanksContactBankIdGet'
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsBanksContactBankIdGetRequest($contact_bank_id)
    {
        // verify the required parameter 'contact_bank_id' is set
        if ($contact_bank_id === null || (is_array($contact_bank_id) && count($contact_bank_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_bank_id when calling restAccountsContactsBanksContactBankIdGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/banks/{contactBankId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_bank_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactBankId' . '}',
                ObjectSerializer::toPathValue($contact_bank_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdPut
     *
     * Update bank account
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     * @param  \OpenAPI\Client\Model\InlineObject13 $_rest_accounts_contacts_banks_contact_bank_id _rest_accounts_contacts_banks_contact_bank_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactBank
     */
    public function restAccountsContactsBanksContactBankIdPut($contact_bank_id, $_rest_accounts_contacts_banks_contact_bank_id = null)
    {
        list($response) = $this->restAccountsContactsBanksContactBankIdPutWithHttpInfo($contact_bank_id, $_rest_accounts_contacts_banks_contact_bank_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdPutWithHttpInfo
     *
     * Update bank account
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     * @param  \OpenAPI\Client\Model\InlineObject13 $_rest_accounts_contacts_banks_contact_bank_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactBank, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsBanksContactBankIdPutWithHttpInfo($contact_bank_id, $_rest_accounts_contacts_banks_contact_bank_id = null)
    {
        $request = $this->restAccountsContactsBanksContactBankIdPutRequest($contact_bank_id, $_rest_accounts_contacts_banks_contact_bank_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactBank' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactBank', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactBank';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactBank',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdPutAsync
     *
     * Update bank account
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     * @param  \OpenAPI\Client\Model\InlineObject13 $_rest_accounts_contacts_banks_contact_bank_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsBanksContactBankIdPutAsync($contact_bank_id, $_rest_accounts_contacts_banks_contact_bank_id = null)
    {
        return $this->restAccountsContactsBanksContactBankIdPutAsyncWithHttpInfo($contact_bank_id, $_rest_accounts_contacts_banks_contact_bank_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdPutAsyncWithHttpInfo
     *
     * Update bank account
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     * @param  \OpenAPI\Client\Model\InlineObject13 $_rest_accounts_contacts_banks_contact_bank_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsBanksContactBankIdPutAsyncWithHttpInfo($contact_bank_id, $_rest_accounts_contacts_banks_contact_bank_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\ContactBank';
        $request = $this->restAccountsContactsBanksContactBankIdPutRequest($contact_bank_id, $_rest_accounts_contacts_banks_contact_bank_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsBanksContactBankIdPut'
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     * @param  \OpenAPI\Client\Model\InlineObject13 $_rest_accounts_contacts_banks_contact_bank_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsBanksContactBankIdPutRequest($contact_bank_id, $_rest_accounts_contacts_banks_contact_bank_id = null)
    {
        // verify the required parameter 'contact_bank_id' is set
        if ($contact_bank_id === null || (is_array($contact_bank_id) && count($contact_bank_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_bank_id when calling restAccountsContactsBanksContactBankIdPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/banks/{contactBankId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_bank_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactBankId' . '}',
                ObjectSerializer::toPathValue($contact_bank_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_contacts_banks_contact_bank_id)) {
            $_tempBody = $_rest_accounts_contacts_banks_contact_bank_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsBanksPost
     *
     * Create bank account
     *
     * @param  \OpenAPI\Client\Model\InlineObject12 $_rest_accounts_contacts_banks _rest_accounts_contacts_banks (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactBank
     */
    public function restAccountsContactsBanksPost($_rest_accounts_contacts_banks = null)
    {
        list($response) = $this->restAccountsContactsBanksPostWithHttpInfo($_rest_accounts_contacts_banks);
        return $response;
    }

    /**
     * Operation restAccountsContactsBanksPostWithHttpInfo
     *
     * Create bank account
     *
     * @param  \OpenAPI\Client\Model\InlineObject12 $_rest_accounts_contacts_banks (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactBank, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsBanksPostWithHttpInfo($_rest_accounts_contacts_banks = null)
    {
        $request = $this->restAccountsContactsBanksPostRequest($_rest_accounts_contacts_banks);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactBank' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactBank', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactBank';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactBank',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsBanksPostAsync
     *
     * Create bank account
     *
     * @param  \OpenAPI\Client\Model\InlineObject12 $_rest_accounts_contacts_banks (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsBanksPostAsync($_rest_accounts_contacts_banks = null)
    {
        return $this->restAccountsContactsBanksPostAsyncWithHttpInfo($_rest_accounts_contacts_banks)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsBanksPostAsyncWithHttpInfo
     *
     * Create bank account
     *
     * @param  \OpenAPI\Client\Model\InlineObject12 $_rest_accounts_contacts_banks (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsBanksPostAsyncWithHttpInfo($_rest_accounts_contacts_banks = null)
    {
        $returnType = '\OpenAPI\Client\Model\ContactBank';
        $request = $this->restAccountsContactsBanksPostRequest($_rest_accounts_contacts_banks);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsBanksPost'
     *
     * @param  \OpenAPI\Client\Model\InlineObject12 $_rest_accounts_contacts_banks (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsBanksPostRequest($_rest_accounts_contacts_banks = null)
    {

        $resourcePath = '/rest/accounts/contacts/banks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_contacts_banks)) {
            $_tempBody = $_rest_accounts_contacts_banks;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsClassesContactClassIdGet
     *
     * Get contact class
     *
     * @param  int $contact_class_id The ID of the contact class (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restAccountsContactsClassesContactClassIdGet($contact_class_id)
    {
        list($response) = $this->restAccountsContactsClassesContactClassIdGetWithHttpInfo($contact_class_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsClassesContactClassIdGetWithHttpInfo
     *
     * Get contact class
     *
     * @param  int $contact_class_id The ID of the contact class (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsClassesContactClassIdGetWithHttpInfo($contact_class_id)
    {
        $request = $this->restAccountsContactsClassesContactClassIdGetRequest($contact_class_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsClassesContactClassIdGetAsync
     *
     * Get contact class
     *
     * @param  int $contact_class_id The ID of the contact class (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsClassesContactClassIdGetAsync($contact_class_id)
    {
        return $this->restAccountsContactsClassesContactClassIdGetAsyncWithHttpInfo($contact_class_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsClassesContactClassIdGetAsyncWithHttpInfo
     *
     * Get contact class
     *
     * @param  int $contact_class_id The ID of the contact class (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsClassesContactClassIdGetAsyncWithHttpInfo($contact_class_id)
    {
        $returnType = 'object';
        $request = $this->restAccountsContactsClassesContactClassIdGetRequest($contact_class_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsClassesContactClassIdGet'
     *
     * @param  int $contact_class_id The ID of the contact class (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsClassesContactClassIdGetRequest($contact_class_id)
    {
        // verify the required parameter 'contact_class_id' is set
        if ($contact_class_id === null || (is_array($contact_class_id) && count($contact_class_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_class_id when calling restAccountsContactsClassesContactClassIdGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/classes/{contactClassId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_class_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactClassId' . '}',
                ObjectSerializer::toPathValue($contact_class_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsClassesGet
     *
     * List contact classes
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function restAccountsContactsClassesGet()
    {
        list($response) = $this->restAccountsContactsClassesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountsContactsClassesGetWithHttpInfo
     *
     * List contact classes
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsClassesGetWithHttpInfo()
    {
        $request = $this->restAccountsContactsClassesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsClassesGetAsync
     *
     * List contact classes
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsClassesGetAsync()
    {
        return $this->restAccountsContactsClassesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsClassesGetAsyncWithHttpInfo
     *
     * List contact classes
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsClassesGetAsyncWithHttpInfo()
    {
        $returnType = 'object[]';
        $request = $this->restAccountsContactsClassesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsClassesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsClassesGetRequest()
    {

        $resourcePath = '/rest/accounts/contacts/classes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactEventsContactEventIdDelete
     *
     * Delete contact event
     *
     * @param  int $contact_event_id The ID of the contact event (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsContactEventsContactEventIdDelete($contact_event_id)
    {
        $this->restAccountsContactsContactEventsContactEventIdDeleteWithHttpInfo($contact_event_id);
    }

    /**
     * Operation restAccountsContactsContactEventsContactEventIdDeleteWithHttpInfo
     *
     * Delete contact event
     *
     * @param  int $contact_event_id The ID of the contact event (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactEventsContactEventIdDeleteWithHttpInfo($contact_event_id)
    {
        $request = $this->restAccountsContactsContactEventsContactEventIdDeleteRequest($contact_event_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactEventsContactEventIdDeleteAsync
     *
     * Delete contact event
     *
     * @param  int $contact_event_id The ID of the contact event (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactEventsContactEventIdDeleteAsync($contact_event_id)
    {
        return $this->restAccountsContactsContactEventsContactEventIdDeleteAsyncWithHttpInfo($contact_event_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactEventsContactEventIdDeleteAsyncWithHttpInfo
     *
     * Delete contact event
     *
     * @param  int $contact_event_id The ID of the contact event (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactEventsContactEventIdDeleteAsyncWithHttpInfo($contact_event_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsContactEventsContactEventIdDeleteRequest($contact_event_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactEventsContactEventIdDelete'
     *
     * @param  int $contact_event_id The ID of the contact event (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactEventsContactEventIdDeleteRequest($contact_event_id)
    {
        // verify the required parameter 'contact_event_id' is set
        if ($contact_event_id === null || (is_array($contact_event_id) && count($contact_event_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_event_id when calling restAccountsContactsContactEventsContactEventIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/contacts/contact_events/{contactEventId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_event_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactEventId' . '}',
                ObjectSerializer::toPathValue($contact_event_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactEventsContactEventIdPut
     *
     * Update contact event
     *
     * @param  int $contact_event_id The ID of the contact event (required)
     * @param  \OpenAPI\Client\Model\InlineObject15 $_rest_accounts_contacts_contact_events_contact_event_id _rest_accounts_contacts_contact_events_contact_event_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactEvent
     */
    public function restAccountsContactsContactEventsContactEventIdPut($contact_event_id, $_rest_accounts_contacts_contact_events_contact_event_id = null)
    {
        list($response) = $this->restAccountsContactsContactEventsContactEventIdPutWithHttpInfo($contact_event_id, $_rest_accounts_contacts_contact_events_contact_event_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactEventsContactEventIdPutWithHttpInfo
     *
     * Update contact event
     *
     * @param  int $contact_event_id The ID of the contact event (required)
     * @param  \OpenAPI\Client\Model\InlineObject15 $_rest_accounts_contacts_contact_events_contact_event_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactEventsContactEventIdPutWithHttpInfo($contact_event_id, $_rest_accounts_contacts_contact_events_contact_event_id = null)
    {
        $request = $this->restAccountsContactsContactEventsContactEventIdPutRequest($contact_event_id, $_rest_accounts_contacts_contact_events_contact_event_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactEvent' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactEvent', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactEvent';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactEvent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactEventsContactEventIdPutAsync
     *
     * Update contact event
     *
     * @param  int $contact_event_id The ID of the contact event (required)
     * @param  \OpenAPI\Client\Model\InlineObject15 $_rest_accounts_contacts_contact_events_contact_event_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactEventsContactEventIdPutAsync($contact_event_id, $_rest_accounts_contacts_contact_events_contact_event_id = null)
    {
        return $this->restAccountsContactsContactEventsContactEventIdPutAsyncWithHttpInfo($contact_event_id, $_rest_accounts_contacts_contact_events_contact_event_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactEventsContactEventIdPutAsyncWithHttpInfo
     *
     * Update contact event
     *
     * @param  int $contact_event_id The ID of the contact event (required)
     * @param  \OpenAPI\Client\Model\InlineObject15 $_rest_accounts_contacts_contact_events_contact_event_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactEventsContactEventIdPutAsyncWithHttpInfo($contact_event_id, $_rest_accounts_contacts_contact_events_contact_event_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\ContactEvent';
        $request = $this->restAccountsContactsContactEventsContactEventIdPutRequest($contact_event_id, $_rest_accounts_contacts_contact_events_contact_event_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactEventsContactEventIdPut'
     *
     * @param  int $contact_event_id The ID of the contact event (required)
     * @param  \OpenAPI\Client\Model\InlineObject15 $_rest_accounts_contacts_contact_events_contact_event_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactEventsContactEventIdPutRequest($contact_event_id, $_rest_accounts_contacts_contact_events_contact_event_id = null)
    {
        // verify the required parameter 'contact_event_id' is set
        if ($contact_event_id === null || (is_array($contact_event_id) && count($contact_event_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_event_id when calling restAccountsContactsContactEventsContactEventIdPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/contact_events/{contactEventId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_event_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactEventId' . '}',
                ObjectSerializer::toPathValue($contact_event_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_contacts_contact_events_contact_event_id)) {
            $_tempBody = $_rest_accounts_contacts_contact_events_contact_event_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactEventsGet
     *
     * List contact events
     *
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse2004
     */
    public function restAccountsContactsContactEventsGet($page = null, $items_per_page = null)
    {
        list($response) = $this->restAccountsContactsContactEventsGetWithHttpInfo($page, $items_per_page);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactEventsGetWithHttpInfo
     *
     * List contact events
     *
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse2004, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactEventsGetWithHttpInfo($page = null, $items_per_page = null)
    {
        $request = $this->restAccountsContactsContactEventsGetRequest($page, $items_per_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse2004' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse2004', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse2004';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse2004',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactEventsGetAsync
     *
     * List contact events
     *
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactEventsGetAsync($page = null, $items_per_page = null)
    {
        return $this->restAccountsContactsContactEventsGetAsyncWithHttpInfo($page, $items_per_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactEventsGetAsyncWithHttpInfo
     *
     * List contact events
     *
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactEventsGetAsyncWithHttpInfo($page = null, $items_per_page = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse2004';
        $request = $this->restAccountsContactsContactEventsGetRequest($page, $items_per_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactEventsGet'
     *
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactEventsGetRequest($page = null, $items_per_page = null)
    {

        $resourcePath = '/rest/accounts/contacts/contact_events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactEventsPost
     *
     * Create contact event
     *
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  \OpenAPI\Client\Model\InlineObject14 $_rest_accounts_contacts_contact_events _rest_accounts_contacts_contact_events (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactEvent
     */
    public function restAccountsContactsContactEventsPost($page = null, $items_per_page = null, $_rest_accounts_contacts_contact_events = null)
    {
        list($response) = $this->restAccountsContactsContactEventsPostWithHttpInfo($page, $items_per_page, $_rest_accounts_contacts_contact_events);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactEventsPostWithHttpInfo
     *
     * Create contact event
     *
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  \OpenAPI\Client\Model\InlineObject14 $_rest_accounts_contacts_contact_events (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactEventsPostWithHttpInfo($page = null, $items_per_page = null, $_rest_accounts_contacts_contact_events = null)
    {
        $request = $this->restAccountsContactsContactEventsPostRequest($page, $items_per_page, $_rest_accounts_contacts_contact_events);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactEvent' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactEvent', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactEvent';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactEvent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactEventsPostAsync
     *
     * Create contact event
     *
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  \OpenAPI\Client\Model\InlineObject14 $_rest_accounts_contacts_contact_events (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactEventsPostAsync($page = null, $items_per_page = null, $_rest_accounts_contacts_contact_events = null)
    {
        return $this->restAccountsContactsContactEventsPostAsyncWithHttpInfo($page, $items_per_page, $_rest_accounts_contacts_contact_events)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactEventsPostAsyncWithHttpInfo
     *
     * Create contact event
     *
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  \OpenAPI\Client\Model\InlineObject14 $_rest_accounts_contacts_contact_events (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactEventsPostAsyncWithHttpInfo($page = null, $items_per_page = null, $_rest_accounts_contacts_contact_events = null)
    {
        $returnType = '\OpenAPI\Client\Model\ContactEvent';
        $request = $this->restAccountsContactsContactEventsPostRequest($page, $items_per_page, $_rest_accounts_contacts_contact_events);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactEventsPost'
     *
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  \OpenAPI\Client\Model\InlineObject14 $_rest_accounts_contacts_contact_events (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactEventsPostRequest($page = null, $items_per_page = null, $_rest_accounts_contacts_contact_events = null)
    {

        $resourcePath = '/rest/accounts/contacts/contact_events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }



        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_contacts_contact_events)) {
            $_tempBody = $_rest_accounts_contacts_contact_events;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactEventsTypesPreviewGet
     *
     * Get contact event types as a key/value array
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function restAccountsContactsContactEventsTypesPreviewGet()
    {
        list($response) = $this->restAccountsContactsContactEventsTypesPreviewGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountsContactsContactEventsTypesPreviewGetWithHttpInfo
     *
     * Get contact event types as a key/value array
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactEventsTypesPreviewGetWithHttpInfo()
    {
        $request = $this->restAccountsContactsContactEventsTypesPreviewGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactEventsTypesPreviewGetAsync
     *
     * Get contact event types as a key/value array
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactEventsTypesPreviewGetAsync()
    {
        return $this->restAccountsContactsContactEventsTypesPreviewGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactEventsTypesPreviewGetAsyncWithHttpInfo
     *
     * Get contact event types as a key/value array
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactEventsTypesPreviewGetAsyncWithHttpInfo()
    {
        $returnType = 'object[]';
        $request = $this->restAccountsContactsContactEventsTypesPreviewGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactEventsTypesPreviewGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactEventsTypesPreviewGetRequest()
    {

        $resourcePath = '/rest/accounts/contacts/contact_events/types/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataLoginUrlGet
     *
     * Get login URL
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsContactIdAccessDataLoginUrlGet($contact_id)
    {
        $this->restAccountsContactsContactIdAccessDataLoginUrlGetWithHttpInfo($contact_id);
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataLoginUrlGetWithHttpInfo
     *
     * Get login URL
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAccessDataLoginUrlGetWithHttpInfo($contact_id)
    {
        $request = $this->restAccountsContactsContactIdAccessDataLoginUrlGetRequest($contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataLoginUrlGetAsync
     *
     * Get login URL
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccessDataLoginUrlGetAsync($contact_id)
    {
        return $this->restAccountsContactsContactIdAccessDataLoginUrlGetAsyncWithHttpInfo($contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataLoginUrlGetAsyncWithHttpInfo
     *
     * Get login URL
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccessDataLoginUrlGetAsyncWithHttpInfo($contact_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsContactIdAccessDataLoginUrlGetRequest($contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAccessDataLoginUrlGet'
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAccessDataLoginUrlGetRequest($contact_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAccessDataLoginUrlGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/access_data/login_url';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataNewPasswordPut
     *
     * Send password link for contact
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restAccountsContactsContactIdAccessDataNewPasswordPut($password, $contact_id)
    {
        list($response) = $this->restAccountsContactsContactIdAccessDataNewPasswordPutWithHttpInfo($password, $contact_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataNewPasswordPutWithHttpInfo
     *
     * Send password link for contact
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAccessDataNewPasswordPutWithHttpInfo($password, $contact_id)
    {
        $request = $this->restAccountsContactsContactIdAccessDataNewPasswordPutRequest($password, $contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataNewPasswordPutAsync
     *
     * Send password link for contact
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccessDataNewPasswordPutAsync($password, $contact_id)
    {
        return $this->restAccountsContactsContactIdAccessDataNewPasswordPutAsyncWithHttpInfo($password, $contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataNewPasswordPutAsyncWithHttpInfo
     *
     * Send password link for contact
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccessDataNewPasswordPutAsyncWithHttpInfo($password, $contact_id)
    {
        $returnType = 'object';
        $request = $this->restAccountsContactsContactIdAccessDataNewPasswordPutRequest($password, $contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAccessDataNewPasswordPut'
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAccessDataNewPasswordPutRequest($password, $contact_id)
    {
        // verify the required parameter 'password' is set
        if ($password === null || (is_array($password) && count($password) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $password when calling restAccountsContactsContactIdAccessDataNewPasswordPut'
            );
        }
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAccessDataNewPasswordPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/access_data/new_password';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($password)) {
            $password = ObjectSerializer::serializeCollection($password, '', true);
        }
        if ($password !== null) {
            $queryParams['password'] = $password;
        }


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataSetPasswordPut
     *
     * Update password for contact
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restAccountsContactsContactIdAccessDataSetPasswordPut($password, $contact_id)
    {
        list($response) = $this->restAccountsContactsContactIdAccessDataSetPasswordPutWithHttpInfo($password, $contact_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataSetPasswordPutWithHttpInfo
     *
     * Update password for contact
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAccessDataSetPasswordPutWithHttpInfo($password, $contact_id)
    {
        $request = $this->restAccountsContactsContactIdAccessDataSetPasswordPutRequest($password, $contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataSetPasswordPutAsync
     *
     * Update password for contact
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccessDataSetPasswordPutAsync($password, $contact_id)
    {
        return $this->restAccountsContactsContactIdAccessDataSetPasswordPutAsyncWithHttpInfo($password, $contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataSetPasswordPutAsyncWithHttpInfo
     *
     * Update password for contact
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccessDataSetPasswordPutAsyncWithHttpInfo($password, $contact_id)
    {
        $returnType = 'object';
        $request = $this->restAccountsContactsContactIdAccessDataSetPasswordPutRequest($password, $contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAccessDataSetPasswordPut'
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAccessDataSetPasswordPutRequest($password, $contact_id)
    {
        // verify the required parameter 'password' is set
        if ($password === null || (is_array($password) && count($password) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $password when calling restAccountsContactsContactIdAccessDataSetPasswordPut'
            );
        }
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAccessDataSetPasswordPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/access_data/set_password';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($password)) {
            $password = ObjectSerializer::serializeCollection($password, '', true);
        }
        if ($password !== null) {
            $queryParams['password'] = $password;
        }


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataUnblockUserPut
     *
     * Unblock contact
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restAccountsContactsContactIdAccessDataUnblockUserPut($contact_id)
    {
        list($response) = $this->restAccountsContactsContactIdAccessDataUnblockUserPutWithHttpInfo($contact_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataUnblockUserPutWithHttpInfo
     *
     * Unblock contact
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAccessDataUnblockUserPutWithHttpInfo($contact_id)
    {
        $request = $this->restAccountsContactsContactIdAccessDataUnblockUserPutRequest($contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataUnblockUserPutAsync
     *
     * Unblock contact
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccessDataUnblockUserPutAsync($contact_id)
    {
        return $this->restAccountsContactsContactIdAccessDataUnblockUserPutAsyncWithHttpInfo($contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataUnblockUserPutAsyncWithHttpInfo
     *
     * Unblock contact
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccessDataUnblockUserPutAsyncWithHttpInfo($contact_id)
    {
        $returnType = 'object';
        $request = $this->restAccountsContactsContactIdAccessDataUnblockUserPutRequest($contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAccessDataUnblockUserPut'
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAccessDataUnblockUserPutRequest($contact_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAccessDataUnblockUserPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/access_data/unblock_user';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdDelete
     *
     * Delete account of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsContactIdAccountsAccountIdDelete($contact_id, $account_id)
    {
        $this->restAccountsContactsContactIdAccountsAccountIdDeleteWithHttpInfo($contact_id, $account_id);
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdDeleteWithHttpInfo
     *
     * Delete account of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAccountsAccountIdDeleteWithHttpInfo($contact_id, $account_id)
    {
        $request = $this->restAccountsContactsContactIdAccountsAccountIdDeleteRequest($contact_id, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdDeleteAsync
     *
     * Delete account of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccountsAccountIdDeleteAsync($contact_id, $account_id)
    {
        return $this->restAccountsContactsContactIdAccountsAccountIdDeleteAsyncWithHttpInfo($contact_id, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdDeleteAsyncWithHttpInfo
     *
     * Delete account of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccountsAccountIdDeleteAsyncWithHttpInfo($contact_id, $account_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsContactIdAccountsAccountIdDeleteRequest($contact_id, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAccountsAccountIdDelete'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAccountsAccountIdDeleteRequest($contact_id, $account_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAccountsAccountIdDelete'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling restAccountsContactsContactIdAccountsAccountIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdGet
     *
     * Get account of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Account
     */
    public function restAccountsContactsContactIdAccountsAccountIdGet($contact_id, $account_id)
    {
        list($response) = $this->restAccountsContactsContactIdAccountsAccountIdGetWithHttpInfo($contact_id, $account_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdGetWithHttpInfo
     *
     * Get account of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Account, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAccountsAccountIdGetWithHttpInfo($contact_id, $account_id)
    {
        $request = $this->restAccountsContactsContactIdAccountsAccountIdGetRequest($contact_id, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Account' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Account', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Account';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Account',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdGetAsync
     *
     * Get account of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccountsAccountIdGetAsync($contact_id, $account_id)
    {
        return $this->restAccountsContactsContactIdAccountsAccountIdGetAsyncWithHttpInfo($contact_id, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdGetAsyncWithHttpInfo
     *
     * Get account of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccountsAccountIdGetAsyncWithHttpInfo($contact_id, $account_id)
    {
        $returnType = '\OpenAPI\Client\Model\Account';
        $request = $this->restAccountsContactsContactIdAccountsAccountIdGetRequest($contact_id, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAccountsAccountIdGet'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAccountsAccountIdGetRequest($contact_id, $account_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAccountsAccountIdGet'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling restAccountsContactsContactIdAccountsAccountIdGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdPut
     *
     * Update account
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Account
     */
    public function restAccountsContactsContactIdAccountsAccountIdPut($contact_id, $account_id)
    {
        list($response) = $this->restAccountsContactsContactIdAccountsAccountIdPutWithHttpInfo($contact_id, $account_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdPutWithHttpInfo
     *
     * Update account
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Account, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAccountsAccountIdPutWithHttpInfo($contact_id, $account_id)
    {
        $request = $this->restAccountsContactsContactIdAccountsAccountIdPutRequest($contact_id, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Account' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Account', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Account';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Account',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdPutAsync
     *
     * Update account
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccountsAccountIdPutAsync($contact_id, $account_id)
    {
        return $this->restAccountsContactsContactIdAccountsAccountIdPutAsyncWithHttpInfo($contact_id, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdPutAsyncWithHttpInfo
     *
     * Update account
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccountsAccountIdPutAsyncWithHttpInfo($contact_id, $account_id)
    {
        $returnType = '\OpenAPI\Client\Model\Account';
        $request = $this->restAccountsContactsContactIdAccountsAccountIdPutRequest($contact_id, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAccountsAccountIdPut'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAccountsAccountIdPutRequest($contact_id, $account_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAccountsAccountIdPut'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling restAccountsContactsContactIdAccountsAccountIdPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAccountsPost
     *
     * Create account for existing contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  \OpenAPI\Client\Model\InlineObject27 $_rest_accounts_contacts_contact_id_accounts _rest_accounts_contacts_contact_id_accounts (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Account
     */
    public function restAccountsContactsContactIdAccountsPost($contact_id, $_rest_accounts_contacts_contact_id_accounts = null)
    {
        list($response) = $this->restAccountsContactsContactIdAccountsPostWithHttpInfo($contact_id, $_rest_accounts_contacts_contact_id_accounts);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAccountsPostWithHttpInfo
     *
     * Create account for existing contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  \OpenAPI\Client\Model\InlineObject27 $_rest_accounts_contacts_contact_id_accounts (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Account, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAccountsPostWithHttpInfo($contact_id, $_rest_accounts_contacts_contact_id_accounts = null)
    {
        $request = $this->restAccountsContactsContactIdAccountsPostRequest($contact_id, $_rest_accounts_contacts_contact_id_accounts);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Account' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Account', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Account';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Account',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAccountsPostAsync
     *
     * Create account for existing contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  \OpenAPI\Client\Model\InlineObject27 $_rest_accounts_contacts_contact_id_accounts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccountsPostAsync($contact_id, $_rest_accounts_contacts_contact_id_accounts = null)
    {
        return $this->restAccountsContactsContactIdAccountsPostAsyncWithHttpInfo($contact_id, $_rest_accounts_contacts_contact_id_accounts)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAccountsPostAsyncWithHttpInfo
     *
     * Create account for existing contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  \OpenAPI\Client\Model\InlineObject27 $_rest_accounts_contacts_contact_id_accounts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccountsPostAsyncWithHttpInfo($contact_id, $_rest_accounts_contacts_contact_id_accounts = null)
    {
        $returnType = '\OpenAPI\Client\Model\Account';
        $request = $this->restAccountsContactsContactIdAccountsPostRequest($contact_id, $_rest_accounts_contacts_contact_id_accounts);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAccountsPost'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  \OpenAPI\Client\Model\InlineObject27 $_rest_accounts_contacts_contact_id_accounts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAccountsPostRequest($contact_id, $_rest_accounts_contacts_contact_id_accounts = null)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAccountsPost'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_contacts_contact_id_accounts)) {
            $_tempBody = $_rest_accounts_contacts_contact_id_accounts;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdDelete
     *
     * Delete address of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsContactIdAddressesAddressIdDelete($contact_id, $address_id, $type_id = null)
    {
        $this->restAccountsContactsContactIdAddressesAddressIdDeleteWithHttpInfo($contact_id, $address_id, $type_id);
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdDeleteWithHttpInfo
     *
     * Delete address of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAddressesAddressIdDeleteWithHttpInfo($contact_id, $address_id, $type_id = null)
    {
        $request = $this->restAccountsContactsContactIdAddressesAddressIdDeleteRequest($contact_id, $address_id, $type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdDeleteAsync
     *
     * Delete address of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressIdDeleteAsync($contact_id, $address_id, $type_id = null)
    {
        return $this->restAccountsContactsContactIdAddressesAddressIdDeleteAsyncWithHttpInfo($contact_id, $address_id, $type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdDeleteAsyncWithHttpInfo
     *
     * Delete address of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressIdDeleteAsyncWithHttpInfo($contact_id, $address_id, $type_id = null)
    {
        $returnType = '';
        $request = $this->restAccountsContactsContactIdAddressesAddressIdDeleteRequest($contact_id, $address_id, $type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAddressesAddressIdDelete'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAddressesAddressIdDeleteRequest($contact_id, $address_id, $type_id = null)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAddressesAddressIdDelete'
            );
        }
        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsContactsContactIdAddressesAddressIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/addresses/{addressId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($type_id)) {
            $type_id = ObjectSerializer::serializeCollection($type_id, '', true);
        }
        if ($type_id !== null) {
            $queryParams['typeId'] = $type_id;
        }


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }
        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdPut
     *
     * Update address of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  bool $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Address
     */
    public function restAccountsContactsContactIdAddressesAddressIdPut($contact_id, $address_id, $is_primary = null, $type_id = null)
    {
        list($response) = $this->restAccountsContactsContactIdAddressesAddressIdPutWithHttpInfo($contact_id, $address_id, $is_primary, $type_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdPutWithHttpInfo
     *
     * Update address of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  bool $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Address, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAddressesAddressIdPutWithHttpInfo($contact_id, $address_id, $is_primary = null, $type_id = null)
    {
        $request = $this->restAccountsContactsContactIdAddressesAddressIdPutRequest($contact_id, $address_id, $is_primary, $type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Address' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Address', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Address';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Address',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdPutAsync
     *
     * Update address of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  bool $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressIdPutAsync($contact_id, $address_id, $is_primary = null, $type_id = null)
    {
        return $this->restAccountsContactsContactIdAddressesAddressIdPutAsyncWithHttpInfo($contact_id, $address_id, $is_primary, $type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdPutAsyncWithHttpInfo
     *
     * Update address of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  bool $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressIdPutAsyncWithHttpInfo($contact_id, $address_id, $is_primary = null, $type_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\Address';
        $request = $this->restAccountsContactsContactIdAddressesAddressIdPutRequest($contact_id, $address_id, $is_primary, $type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAddressesAddressIdPut'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  bool $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAddressesAddressIdPutRequest($contact_id, $address_id, $is_primary = null, $type_id = null)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAddressesAddressIdPut'
            );
        }
        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsContactsContactIdAddressesAddressIdPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/addresses/{addressId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($is_primary)) {
            $is_primary = ObjectSerializer::serializeCollection($is_primary, '', true);
        }
        if ($is_primary !== null) {
            $queryParams['isPrimary'] = $is_primary;
        }
        // query params
        if (is_array($type_id)) {
            $type_id = ObjectSerializer::serializeCollection($type_id, '', true);
        }
        if ($type_id !== null) {
            $queryParams['typeId'] = $type_id;
        }


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }
        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut
     *
     * Set contact address per address type as primary address
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $address_type_id The ID of the address type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AddressContactRelation
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut($contact_id, $address_id, $address_type_id)
    {
        list($response) = $this->restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutWithHttpInfo($contact_id, $address_id, $address_type_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutWithHttpInfo
     *
     * Set contact address per address type as primary address
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $address_type_id The ID of the address type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AddressContactRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutWithHttpInfo($contact_id, $address_id, $address_type_id)
    {
        $request = $this->restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutRequest($contact_id, $address_id, $address_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AddressContactRelation' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AddressContactRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AddressContactRelation';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AddressContactRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutAsync
     *
     * Set contact address per address type as primary address
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $address_type_id The ID of the address type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutAsync($contact_id, $address_id, $address_type_id)
    {
        return $this->restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutAsyncWithHttpInfo($contact_id, $address_id, $address_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutAsyncWithHttpInfo
     *
     * Set contact address per address type as primary address
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $address_type_id The ID of the address type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutAsyncWithHttpInfo($contact_id, $address_id, $address_type_id)
    {
        $returnType = '\OpenAPI\Client\Model\AddressContactRelation';
        $request = $this->restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutRequest($contact_id, $address_id, $address_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $address_type_id The ID of the address type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutRequest($contact_id, $address_id, $address_type_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut'
            );
        }
        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut'
            );
        }
        // verify the required parameter 'address_type_id' is set
        if ($address_type_id === null || (is_array($address_type_id) && count($address_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_type_id when calling restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/addresses/{addressId}/types/{addressTypeId}/primary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }
        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }
        // path params
        if ($address_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressTypeId' . '}',
                ObjectSerializer::toPathValue($address_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut
     *
     * Reset contact primary address
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $address_type_id The ID of the address type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AddressContactRelation
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut($contact_id, $address_id, $address_type_id)
    {
        list($response) = $this->restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutWithHttpInfo($contact_id, $address_id, $address_type_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutWithHttpInfo
     *
     * Reset contact primary address
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $address_type_id The ID of the address type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AddressContactRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutWithHttpInfo($contact_id, $address_id, $address_type_id)
    {
        $request = $this->restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutRequest($contact_id, $address_id, $address_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AddressContactRelation' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AddressContactRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AddressContactRelation';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AddressContactRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutAsync
     *
     * Reset contact primary address
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $address_type_id The ID of the address type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutAsync($contact_id, $address_id, $address_type_id)
    {
        return $this->restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutAsyncWithHttpInfo($contact_id, $address_id, $address_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutAsyncWithHttpInfo
     *
     * Reset contact primary address
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $address_type_id The ID of the address type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutAsyncWithHttpInfo($contact_id, $address_id, $address_type_id)
    {
        $returnType = '\OpenAPI\Client\Model\AddressContactRelation';
        $request = $this->restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutRequest($contact_id, $address_id, $address_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $address_type_id The ID of the address type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutRequest($contact_id, $address_id, $address_type_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut'
            );
        }
        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut'
            );
        }
        // verify the required parameter 'address_type_id' is set
        if ($address_type_id === null || (is_array($address_type_id) && count($address_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_type_id when calling restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/addresses/{addressId}/types/{addressTypeId}/reset_primary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }
        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }
        // path params
        if ($address_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressTypeId' . '}',
                ObjectSerializer::toPathValue($address_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesPost
     *
     * Create address for existing contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  bool $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \OpenAPI\Client\Model\InlineObject28 $_rest_accounts_contacts_contact_id_addresses _rest_accounts_contacts_contact_id_addresses (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Address
     */
    public function restAccountsContactsContactIdAddressesPost($contact_id, $is_primary = null, $type_id = null, $_rest_accounts_contacts_contact_id_addresses = null)
    {
        list($response) = $this->restAccountsContactsContactIdAddressesPostWithHttpInfo($contact_id, $is_primary, $type_id, $_rest_accounts_contacts_contact_id_addresses);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAddressesPostWithHttpInfo
     *
     * Create address for existing contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  bool $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \OpenAPI\Client\Model\InlineObject28 $_rest_accounts_contacts_contact_id_addresses (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Address, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAddressesPostWithHttpInfo($contact_id, $is_primary = null, $type_id = null, $_rest_accounts_contacts_contact_id_addresses = null)
    {
        $request = $this->restAccountsContactsContactIdAddressesPostRequest($contact_id, $is_primary, $type_id, $_rest_accounts_contacts_contact_id_addresses);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Address' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Address', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Address';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Address',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAddressesPostAsync
     *
     * Create address for existing contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  bool $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \OpenAPI\Client\Model\InlineObject28 $_rest_accounts_contacts_contact_id_addresses (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesPostAsync($contact_id, $is_primary = null, $type_id = null, $_rest_accounts_contacts_contact_id_addresses = null)
    {
        return $this->restAccountsContactsContactIdAddressesPostAsyncWithHttpInfo($contact_id, $is_primary, $type_id, $_rest_accounts_contacts_contact_id_addresses)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesPostAsyncWithHttpInfo
     *
     * Create address for existing contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  bool $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \OpenAPI\Client\Model\InlineObject28 $_rest_accounts_contacts_contact_id_addresses (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesPostAsyncWithHttpInfo($contact_id, $is_primary = null, $type_id = null, $_rest_accounts_contacts_contact_id_addresses = null)
    {
        $returnType = '\OpenAPI\Client\Model\Address';
        $request = $this->restAccountsContactsContactIdAddressesPostRequest($contact_id, $is_primary, $type_id, $_rest_accounts_contacts_contact_id_addresses);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAddressesPost'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  bool $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \OpenAPI\Client\Model\InlineObject28 $_rest_accounts_contacts_contact_id_addresses (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAddressesPostRequest($contact_id, $is_primary = null, $type_id = null, $_rest_accounts_contacts_contact_id_addresses = null)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAddressesPost'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/addresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($is_primary)) {
            $is_primary = ObjectSerializer::serializeCollection($is_primary, '', true);
        }
        if ($is_primary !== null) {
            $queryParams['isPrimary'] = $is_primary;
        }
        // query params
        if (is_array($type_id)) {
            $type_id = ObjectSerializer::serializeCollection($type_id, '', true);
        }
        if ($type_id !== null) {
            $queryParams['typeId'] = $type_id;
        }


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_contacts_contact_id_addresses)) {
            $_tempBody = $_rest_accounts_contacts_contact_id_addresses;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesPrimaryGet
     *
     * Get primary or last created addresses of contact
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restAccountsContactsContactIdAddressesPrimaryGet($contact_id)
    {
        list($response) = $this->restAccountsContactsContactIdAddressesPrimaryGetWithHttpInfo($contact_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAddressesPrimaryGetWithHttpInfo
     *
     * Get primary or last created addresses of contact
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAddressesPrimaryGetWithHttpInfo($contact_id)
    {
        $request = $this->restAccountsContactsContactIdAddressesPrimaryGetRequest($contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAddressesPrimaryGetAsync
     *
     * Get primary or last created addresses of contact
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesPrimaryGetAsync($contact_id)
    {
        return $this->restAccountsContactsContactIdAddressesPrimaryGetAsyncWithHttpInfo($contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesPrimaryGetAsyncWithHttpInfo
     *
     * Get primary or last created addresses of contact
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesPrimaryGetAsyncWithHttpInfo($contact_id)
    {
        $returnType = 'object';
        $request = $this->restAccountsContactsContactIdAddressesPrimaryGetRequest($contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAddressesPrimaryGet'
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAddressesPrimaryGetRequest($contact_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAddressesPrimaryGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/addresses/primary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdBanksGet
     *
     * List bank accounts
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $items_per_page The number of items per page (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactBank[]
     */
    public function restAccountsContactsContactIdBanksGet($contact_id, $items_per_page = null)
    {
        list($response) = $this->restAccountsContactsContactIdBanksGetWithHttpInfo($contact_id, $items_per_page);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdBanksGetWithHttpInfo
     *
     * List bank accounts
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $items_per_page The number of items per page (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactBank[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdBanksGetWithHttpInfo($contact_id, $items_per_page = null)
    {
        $request = $this->restAccountsContactsContactIdBanksGetRequest($contact_id, $items_per_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactBank[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactBank[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactBank[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactBank[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdBanksGetAsync
     *
     * List bank accounts
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $items_per_page The number of items per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdBanksGetAsync($contact_id, $items_per_page = null)
    {
        return $this->restAccountsContactsContactIdBanksGetAsyncWithHttpInfo($contact_id, $items_per_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdBanksGetAsyncWithHttpInfo
     *
     * List bank accounts
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $items_per_page The number of items per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdBanksGetAsyncWithHttpInfo($contact_id, $items_per_page = null)
    {
        $returnType = '\OpenAPI\Client\Model\ContactBank[]';
        $request = $this->restAccountsContactsContactIdBanksGetRequest($contact_id, $items_per_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdBanksGet'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $items_per_page The number of items per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdBanksGetRequest($contact_id, $items_per_page = null)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdBanksGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/banks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdContactEventsGet
     *
     * List contact events by contact ID
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse2004
     */
    public function restAccountsContactsContactIdContactEventsGet($contact_id, $page = null, $items_per_page = null)
    {
        list($response) = $this->restAccountsContactsContactIdContactEventsGetWithHttpInfo($contact_id, $page, $items_per_page);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdContactEventsGetWithHttpInfo
     *
     * List contact events by contact ID
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse2004, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdContactEventsGetWithHttpInfo($contact_id, $page = null, $items_per_page = null)
    {
        $request = $this->restAccountsContactsContactIdContactEventsGetRequest($contact_id, $page, $items_per_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse2004' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse2004', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse2004';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse2004',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdContactEventsGetAsync
     *
     * List contact events by contact ID
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdContactEventsGetAsync($contact_id, $page = null, $items_per_page = null)
    {
        return $this->restAccountsContactsContactIdContactEventsGetAsyncWithHttpInfo($contact_id, $page, $items_per_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdContactEventsGetAsyncWithHttpInfo
     *
     * List contact events by contact ID
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdContactEventsGetAsyncWithHttpInfo($contact_id, $page = null, $items_per_page = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse2004';
        $request = $this->restAccountsContactsContactIdContactEventsGetRequest($contact_id, $page, $items_per_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdContactEventsGet'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdContactEventsGetRequest($contact_id, $page = null, $items_per_page = null)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdContactEventsGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/contact_events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdDelete
     *
     * Delete contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  bool $check_existing_orders Flag that checks if the contact is linked to orders. If the contact is linked to orders, CustomerDeleteException is thrown and the contact will not be deleted. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsContactIdDelete($contact_id, $check_existing_orders = null)
    {
        $this->restAccountsContactsContactIdDeleteWithHttpInfo($contact_id, $check_existing_orders);
    }

    /**
     * Operation restAccountsContactsContactIdDeleteWithHttpInfo
     *
     * Delete contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  bool $check_existing_orders Flag that checks if the contact is linked to orders. If the contact is linked to orders, CustomerDeleteException is thrown and the contact will not be deleted. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdDeleteWithHttpInfo($contact_id, $check_existing_orders = null)
    {
        $request = $this->restAccountsContactsContactIdDeleteRequest($contact_id, $check_existing_orders);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdDeleteAsync
     *
     * Delete contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  bool $check_existing_orders Flag that checks if the contact is linked to orders. If the contact is linked to orders, CustomerDeleteException is thrown and the contact will not be deleted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdDeleteAsync($contact_id, $check_existing_orders = null)
    {
        return $this->restAccountsContactsContactIdDeleteAsyncWithHttpInfo($contact_id, $check_existing_orders)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdDeleteAsyncWithHttpInfo
     *
     * Delete contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  bool $check_existing_orders Flag that checks if the contact is linked to orders. If the contact is linked to orders, CustomerDeleteException is thrown and the contact will not be deleted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdDeleteAsyncWithHttpInfo($contact_id, $check_existing_orders = null)
    {
        $returnType = '';
        $request = $this->restAccountsContactsContactIdDeleteRequest($contact_id, $check_existing_orders);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdDelete'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  bool $check_existing_orders Flag that checks if the contact is linked to orders. If the contact is linked to orders, CustomerDeleteException is thrown and the contact will not be deleted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdDeleteRequest($contact_id, $check_existing_orders = null)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($check_existing_orders)) {
            $check_existing_orders = ObjectSerializer::serializeCollection($check_existing_orders, '', true);
        }
        if ($check_existing_orders !== null) {
            $queryParams['checkExistingOrders'] = $check_existing_orders;
        }


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdGet
     *
     * Get contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts. More than one parameter should be separated by commas. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Contact
     */
    public function restAccountsContactsContactIdGet($contact_id, $with = null)
    {
        list($response) = $this->restAccountsContactsContactIdGetWithHttpInfo($contact_id, $with);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdGetWithHttpInfo
     *
     * Get contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts. More than one parameter should be separated by commas. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Contact, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdGetWithHttpInfo($contact_id, $with = null)
    {
        $request = $this->restAccountsContactsContactIdGetRequest($contact_id, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Contact' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Contact', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Contact';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Contact',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdGetAsync
     *
     * Get contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts. More than one parameter should be separated by commas. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdGetAsync($contact_id, $with = null)
    {
        return $this->restAccountsContactsContactIdGetAsyncWithHttpInfo($contact_id, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdGetAsyncWithHttpInfo
     *
     * Get contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts. More than one parameter should be separated by commas. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdGetAsyncWithHttpInfo($contact_id, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\Contact';
        $request = $this->restAccountsContactsContactIdGetRequest($contact_id, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdGet'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts. More than one parameter should be separated by commas. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdGetRequest($contact_id, $with = null)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsDelete
     *
     * Delete contact option
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsContactIdOptionsDelete($contact_id)
    {
        $this->restAccountsContactsContactIdOptionsDeleteWithHttpInfo($contact_id);
    }

    /**
     * Operation restAccountsContactsContactIdOptionsDeleteWithHttpInfo
     *
     * Delete contact option
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdOptionsDeleteWithHttpInfo($contact_id)
    {
        $request = $this->restAccountsContactsContactIdOptionsDeleteRequest($contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdOptionsDeleteAsync
     *
     * Delete contact option
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsDeleteAsync($contact_id)
    {
        return $this->restAccountsContactsContactIdOptionsDeleteAsyncWithHttpInfo($contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsDeleteAsyncWithHttpInfo
     *
     * Delete contact option
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsDeleteAsyncWithHttpInfo($contact_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsContactIdOptionsDeleteRequest($contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdOptionsDelete'
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdOptionsDeleteRequest($contact_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdOptionsDelete'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsGet
     *
     * List contact options
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $type_id The ID of the type (optional)
     * @param  int $sub_type_id The ID of the sub type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactOption[]
     */
    public function restAccountsContactsContactIdOptionsGet($contact_id, $type_id = null, $sub_type_id = null)
    {
        list($response) = $this->restAccountsContactsContactIdOptionsGetWithHttpInfo($contact_id, $type_id, $sub_type_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdOptionsGetWithHttpInfo
     *
     * List contact options
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $type_id The ID of the type (optional)
     * @param  int $sub_type_id The ID of the sub type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactOption[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdOptionsGetWithHttpInfo($contact_id, $type_id = null, $sub_type_id = null)
    {
        $request = $this->restAccountsContactsContactIdOptionsGetRequest($contact_id, $type_id, $sub_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactOption[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactOption[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactOption[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactOption[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdOptionsGetAsync
     *
     * List contact options
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $type_id The ID of the type (optional)
     * @param  int $sub_type_id The ID of the sub type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsGetAsync($contact_id, $type_id = null, $sub_type_id = null)
    {
        return $this->restAccountsContactsContactIdOptionsGetAsyncWithHttpInfo($contact_id, $type_id, $sub_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsGetAsyncWithHttpInfo
     *
     * List contact options
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $type_id The ID of the type (optional)
     * @param  int $sub_type_id The ID of the sub type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsGetAsyncWithHttpInfo($contact_id, $type_id = null, $sub_type_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\ContactOption[]';
        $request = $this->restAccountsContactsContactIdOptionsGetRequest($contact_id, $type_id, $sub_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdOptionsGet'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $type_id The ID of the type (optional)
     * @param  int $sub_type_id The ID of the sub type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdOptionsGetRequest($contact_id, $type_id = null, $sub_type_id = null)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdOptionsGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($type_id)) {
            $type_id = ObjectSerializer::serializeCollection($type_id, '', true);
        }
        if ($type_id !== null) {
            $queryParams['typeId'] = $type_id;
        }
        // query params
        if (is_array($sub_type_id)) {
            $sub_type_id = ObjectSerializer::serializeCollection($sub_type_id, '', true);
        }
        if ($sub_type_id !== null) {
            $queryParams['subTypeId'] = $sub_type_id;
        }


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsPost
     *
     * Create contact option
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactOption[]
     */
    public function restAccountsContactsContactIdOptionsPost($contact_id)
    {
        list($response) = $this->restAccountsContactsContactIdOptionsPostWithHttpInfo($contact_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdOptionsPostWithHttpInfo
     *
     * Create contact option
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactOption[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdOptionsPostWithHttpInfo($contact_id)
    {
        $request = $this->restAccountsContactsContactIdOptionsPostRequest($contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactOption[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactOption[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactOption[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactOption[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdOptionsPostAsync
     *
     * Create contact option
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsPostAsync($contact_id)
    {
        return $this->restAccountsContactsContactIdOptionsPostAsyncWithHttpInfo($contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsPostAsyncWithHttpInfo
     *
     * Create contact option
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsPostAsyncWithHttpInfo($contact_id)
    {
        $returnType = '\OpenAPI\Client\Model\ContactOption[]';
        $request = $this->restAccountsContactsContactIdOptionsPostRequest($contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdOptionsPost'
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdOptionsPostRequest($contact_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdOptionsPost'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsPut
     *
     * Update contact option
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactOption[]
     */
    public function restAccountsContactsContactIdOptionsPut($contact_id)
    {
        list($response) = $this->restAccountsContactsContactIdOptionsPutWithHttpInfo($contact_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdOptionsPutWithHttpInfo
     *
     * Update contact option
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactOption[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdOptionsPutWithHttpInfo($contact_id)
    {
        $request = $this->restAccountsContactsContactIdOptionsPutRequest($contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactOption[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactOption[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactOption[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactOption[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdOptionsPutAsync
     *
     * Update contact option
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsPutAsync($contact_id)
    {
        return $this->restAccountsContactsContactIdOptionsPutAsyncWithHttpInfo($contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsPutAsyncWithHttpInfo
     *
     * Update contact option
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsPutAsyncWithHttpInfo($contact_id)
    {
        $returnType = '\OpenAPI\Client\Model\ContactOption[]';
        $request = $this->restAccountsContactsContactIdOptionsPutRequest($contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdOptionsPut'
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdOptionsPutRequest($contact_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdOptionsPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsValidateGet
     *
     * Validate contact option by given value
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restAccountsContactsContactIdOptionsValidateGet($contact_id)
    {
        list($response) = $this->restAccountsContactsContactIdOptionsValidateGetWithHttpInfo($contact_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdOptionsValidateGetWithHttpInfo
     *
     * Validate contact option by given value
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdOptionsValidateGetWithHttpInfo($contact_id)
    {
        $request = $this->restAccountsContactsContactIdOptionsValidateGetRequest($contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdOptionsValidateGetAsync
     *
     * Validate contact option by given value
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsValidateGetAsync($contact_id)
    {
        return $this->restAccountsContactsContactIdOptionsValidateGetAsyncWithHttpInfo($contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsValidateGetAsyncWithHttpInfo
     *
     * Validate contact option by given value
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsValidateGetAsyncWithHttpInfo($contact_id)
    {
        $returnType = 'object';
        $request = $this->restAccountsContactsContactIdOptionsValidateGetRequest($contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdOptionsValidateGet'
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdOptionsValidateGetRequest($contact_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdOptionsValidateGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/options/validate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdPut
     *
     * Update contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $tag_relationships When this parameter is used, the current relations between contacts and tags will be deleted and replaced by the given ones. If the parameter is not used, the current relations remain. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject26 $_rest_accounts_contacts_contact_id _rest_accounts_contacts_contact_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Contact
     */
    public function restAccountsContactsContactIdPut($contact_id, $tag_relationships = null, $_rest_accounts_contacts_contact_id = null)
    {
        list($response) = $this->restAccountsContactsContactIdPutWithHttpInfo($contact_id, $tag_relationships, $_rest_accounts_contacts_contact_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdPutWithHttpInfo
     *
     * Update contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $tag_relationships When this parameter is used, the current relations between contacts and tags will be deleted and replaced by the given ones. If the parameter is not used, the current relations remain. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject26 $_rest_accounts_contacts_contact_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Contact, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdPutWithHttpInfo($contact_id, $tag_relationships = null, $_rest_accounts_contacts_contact_id = null)
    {
        $request = $this->restAccountsContactsContactIdPutRequest($contact_id, $tag_relationships, $_rest_accounts_contacts_contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Contact' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Contact', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Contact';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Contact',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdPutAsync
     *
     * Update contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $tag_relationships When this parameter is used, the current relations between contacts and tags will be deleted and replaced by the given ones. If the parameter is not used, the current relations remain. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject26 $_rest_accounts_contacts_contact_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdPutAsync($contact_id, $tag_relationships = null, $_rest_accounts_contacts_contact_id = null)
    {
        return $this->restAccountsContactsContactIdPutAsyncWithHttpInfo($contact_id, $tag_relationships, $_rest_accounts_contacts_contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdPutAsyncWithHttpInfo
     *
     * Update contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $tag_relationships When this parameter is used, the current relations between contacts and tags will be deleted and replaced by the given ones. If the parameter is not used, the current relations remain. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject26 $_rest_accounts_contacts_contact_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdPutAsyncWithHttpInfo($contact_id, $tag_relationships = null, $_rest_accounts_contacts_contact_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\Contact';
        $request = $this->restAccountsContactsContactIdPutRequest($contact_id, $tag_relationships, $_rest_accounts_contacts_contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdPut'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $tag_relationships When this parameter is used, the current relations between contacts and tags will be deleted and replaced by the given ones. If the parameter is not used, the current relations remain. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject26 $_rest_accounts_contacts_contact_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdPutRequest($contact_id, $tag_relationships = null, $_rest_accounts_contacts_contact_id = null)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($tag_relationships)) {
            $tag_relationships = ObjectSerializer::serializeCollection($tag_relationships, '', true);
        }
        if ($tag_relationships !== null) {
            $queryParams['tagRelationships'] = $tag_relationships;
        }


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_contacts_contact_id)) {
            $_tempBody = $_rest_accounts_contacts_contact_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdRelatedDataGet
     *
     * List contact related data
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Contact
     */
    public function restAccountsContactsContactIdRelatedDataGet($contact_id)
    {
        list($response) = $this->restAccountsContactsContactIdRelatedDataGetWithHttpInfo($contact_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdRelatedDataGetWithHttpInfo
     *
     * List contact related data
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Contact, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdRelatedDataGetWithHttpInfo($contact_id)
    {
        $request = $this->restAccountsContactsContactIdRelatedDataGetRequest($contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Contact' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Contact', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Contact';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Contact',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdRelatedDataGetAsync
     *
     * List contact related data
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdRelatedDataGetAsync($contact_id)
    {
        return $this->restAccountsContactsContactIdRelatedDataGetAsyncWithHttpInfo($contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdRelatedDataGetAsyncWithHttpInfo
     *
     * List contact related data
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdRelatedDataGetAsyncWithHttpInfo($contact_id)
    {
        $returnType = '\OpenAPI\Client\Model\Contact';
        $request = $this->restAccountsContactsContactIdRelatedDataGetRequest($contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdRelatedDataGet'
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdRelatedDataGetRequest($contact_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdRelatedDataGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/related_data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdVcardGet
     *
     * Get vcard filestream of contact
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restAccountsContactsContactIdVcardGet($contact_id)
    {
        list($response) = $this->restAccountsContactsContactIdVcardGetWithHttpInfo($contact_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdVcardGetWithHttpInfo
     *
     * Get vcard filestream of contact
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdVcardGetWithHttpInfo($contact_id)
    {
        $request = $this->restAccountsContactsContactIdVcardGetRequest($contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdVcardGetAsync
     *
     * Get vcard filestream of contact
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdVcardGetAsync($contact_id)
    {
        return $this->restAccountsContactsContactIdVcardGetAsyncWithHttpInfo($contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdVcardGetAsyncWithHttpInfo
     *
     * Get vcard filestream of contact
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdVcardGetAsyncWithHttpInfo($contact_id)
    {
        $returnType = 'object';
        $request = $this->restAccountsContactsContactIdVcardGetRequest($contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdVcardGet'
     *
     * @param  int $contact_id The ID of the contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdVcardGetRequest($contact_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdVcardGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/vcard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdDelete
     *
     * Delete contact department
     *
     * @param  int $department_id The ID of the department (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsDepartmentsDepartmentIdDelete($department_id)
    {
        $this->restAccountsContactsDepartmentsDepartmentIdDeleteWithHttpInfo($department_id);
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdDeleteWithHttpInfo
     *
     * Delete contact department
     *
     * @param  int $department_id The ID of the department (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsDepartmentsDepartmentIdDeleteWithHttpInfo($department_id)
    {
        $request = $this->restAccountsContactsDepartmentsDepartmentIdDeleteRequest($department_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdDeleteAsync
     *
     * Delete contact department
     *
     * @param  int $department_id The ID of the department (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsDepartmentsDepartmentIdDeleteAsync($department_id)
    {
        return $this->restAccountsContactsDepartmentsDepartmentIdDeleteAsyncWithHttpInfo($department_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdDeleteAsyncWithHttpInfo
     *
     * Delete contact department
     *
     * @param  int $department_id The ID of the department (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsDepartmentsDepartmentIdDeleteAsyncWithHttpInfo($department_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsDepartmentsDepartmentIdDeleteRequest($department_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsDepartmentsDepartmentIdDelete'
     *
     * @param  int $department_id The ID of the department (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsDepartmentsDepartmentIdDeleteRequest($department_id)
    {
        // verify the required parameter 'department_id' is set
        if ($department_id === null || (is_array($department_id) && count($department_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $department_id when calling restAccountsContactsDepartmentsDepartmentIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/contacts/departments/{departmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($department_id !== null) {
            $resourcePath = str_replace(
                '{' . 'departmentId' . '}',
                ObjectSerializer::toPathValue($department_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdGet
     *
     * Get contact department
     *
     * @param  int $department_id The ID of the department (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactDepartment
     */
    public function restAccountsContactsDepartmentsDepartmentIdGet($department_id)
    {
        list($response) = $this->restAccountsContactsDepartmentsDepartmentIdGetWithHttpInfo($department_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdGetWithHttpInfo
     *
     * Get contact department
     *
     * @param  int $department_id The ID of the department (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactDepartment, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsDepartmentsDepartmentIdGetWithHttpInfo($department_id)
    {
        $request = $this->restAccountsContactsDepartmentsDepartmentIdGetRequest($department_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactDepartment' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactDepartment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactDepartment';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactDepartment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdGetAsync
     *
     * Get contact department
     *
     * @param  int $department_id The ID of the department (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsDepartmentsDepartmentIdGetAsync($department_id)
    {
        return $this->restAccountsContactsDepartmentsDepartmentIdGetAsyncWithHttpInfo($department_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdGetAsyncWithHttpInfo
     *
     * Get contact department
     *
     * @param  int $department_id The ID of the department (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsDepartmentsDepartmentIdGetAsyncWithHttpInfo($department_id)
    {
        $returnType = '\OpenAPI\Client\Model\ContactDepartment';
        $request = $this->restAccountsContactsDepartmentsDepartmentIdGetRequest($department_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsDepartmentsDepartmentIdGet'
     *
     * @param  int $department_id The ID of the department (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsDepartmentsDepartmentIdGetRequest($department_id)
    {
        // verify the required parameter 'department_id' is set
        if ($department_id === null || (is_array($department_id) && count($department_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $department_id when calling restAccountsContactsDepartmentsDepartmentIdGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/departments/{departmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($department_id !== null) {
            $resourcePath = str_replace(
                '{' . 'departmentId' . '}',
                ObjectSerializer::toPathValue($department_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdPut
     *
     * Update contact department
     *
     * @param  int $department_id The ID of the department (required)
     * @param  \OpenAPI\Client\Model\InlineObject17 $_rest_accounts_contacts_departments_department_id _rest_accounts_contacts_departments_department_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactDepartment
     */
    public function restAccountsContactsDepartmentsDepartmentIdPut($department_id, $_rest_accounts_contacts_departments_department_id = null)
    {
        list($response) = $this->restAccountsContactsDepartmentsDepartmentIdPutWithHttpInfo($department_id, $_rest_accounts_contacts_departments_department_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdPutWithHttpInfo
     *
     * Update contact department
     *
     * @param  int $department_id The ID of the department (required)
     * @param  \OpenAPI\Client\Model\InlineObject17 $_rest_accounts_contacts_departments_department_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactDepartment, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsDepartmentsDepartmentIdPutWithHttpInfo($department_id, $_rest_accounts_contacts_departments_department_id = null)
    {
        $request = $this->restAccountsContactsDepartmentsDepartmentIdPutRequest($department_id, $_rest_accounts_contacts_departments_department_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactDepartment' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactDepartment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactDepartment';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactDepartment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdPutAsync
     *
     * Update contact department
     *
     * @param  int $department_id The ID of the department (required)
     * @param  \OpenAPI\Client\Model\InlineObject17 $_rest_accounts_contacts_departments_department_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsDepartmentsDepartmentIdPutAsync($department_id, $_rest_accounts_contacts_departments_department_id = null)
    {
        return $this->restAccountsContactsDepartmentsDepartmentIdPutAsyncWithHttpInfo($department_id, $_rest_accounts_contacts_departments_department_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdPutAsyncWithHttpInfo
     *
     * Update contact department
     *
     * @param  int $department_id The ID of the department (required)
     * @param  \OpenAPI\Client\Model\InlineObject17 $_rest_accounts_contacts_departments_department_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsDepartmentsDepartmentIdPutAsyncWithHttpInfo($department_id, $_rest_accounts_contacts_departments_department_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\ContactDepartment';
        $request = $this->restAccountsContactsDepartmentsDepartmentIdPutRequest($department_id, $_rest_accounts_contacts_departments_department_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsDepartmentsDepartmentIdPut'
     *
     * @param  int $department_id The ID of the department (required)
     * @param  \OpenAPI\Client\Model\InlineObject17 $_rest_accounts_contacts_departments_department_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsDepartmentsDepartmentIdPutRequest($department_id, $_rest_accounts_contacts_departments_department_id = null)
    {
        // verify the required parameter 'department_id' is set
        if ($department_id === null || (is_array($department_id) && count($department_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $department_id when calling restAccountsContactsDepartmentsDepartmentIdPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/departments/{departmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($department_id !== null) {
            $resourcePath = str_replace(
                '{' . 'departmentId' . '}',
                ObjectSerializer::toPathValue($department_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_contacts_departments_department_id)) {
            $_tempBody = $_rest_accounts_contacts_departments_department_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsDepartmentsGet
     *
     * List contact departments
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactDepartment[]
     */
    public function restAccountsContactsDepartmentsGet()
    {
        list($response) = $this->restAccountsContactsDepartmentsGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountsContactsDepartmentsGetWithHttpInfo
     *
     * List contact departments
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactDepartment[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsDepartmentsGetWithHttpInfo()
    {
        $request = $this->restAccountsContactsDepartmentsGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactDepartment[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactDepartment[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactDepartment[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactDepartment[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsDepartmentsGetAsync
     *
     * List contact departments
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsDepartmentsGetAsync()
    {
        return $this->restAccountsContactsDepartmentsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsDepartmentsGetAsyncWithHttpInfo
     *
     * List contact departments
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsDepartmentsGetAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\ContactDepartment[]';
        $request = $this->restAccountsContactsDepartmentsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsDepartmentsGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsDepartmentsGetRequest()
    {

        $resourcePath = '/rest/accounts/contacts/departments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsDepartmentsPost
     *
     * Create contact department
     *
     * @param  \OpenAPI\Client\Model\InlineObject16 $_rest_accounts_contacts_departments _rest_accounts_contacts_departments (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactDepartment
     */
    public function restAccountsContactsDepartmentsPost($_rest_accounts_contacts_departments = null)
    {
        list($response) = $this->restAccountsContactsDepartmentsPostWithHttpInfo($_rest_accounts_contacts_departments);
        return $response;
    }

    /**
     * Operation restAccountsContactsDepartmentsPostWithHttpInfo
     *
     * Create contact department
     *
     * @param  \OpenAPI\Client\Model\InlineObject16 $_rest_accounts_contacts_departments (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactDepartment, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsDepartmentsPostWithHttpInfo($_rest_accounts_contacts_departments = null)
    {
        $request = $this->restAccountsContactsDepartmentsPostRequest($_rest_accounts_contacts_departments);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactDepartment' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactDepartment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactDepartment';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactDepartment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsDepartmentsPostAsync
     *
     * Create contact department
     *
     * @param  \OpenAPI\Client\Model\InlineObject16 $_rest_accounts_contacts_departments (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsDepartmentsPostAsync($_rest_accounts_contacts_departments = null)
    {
        return $this->restAccountsContactsDepartmentsPostAsyncWithHttpInfo($_rest_accounts_contacts_departments)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsDepartmentsPostAsyncWithHttpInfo
     *
     * Create contact department
     *
     * @param  \OpenAPI\Client\Model\InlineObject16 $_rest_accounts_contacts_departments (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsDepartmentsPostAsyncWithHttpInfo($_rest_accounts_contacts_departments = null)
    {
        $returnType = '\OpenAPI\Client\Model\ContactDepartment';
        $request = $this->restAccountsContactsDepartmentsPostRequest($_rest_accounts_contacts_departments);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsDepartmentsPost'
     *
     * @param  \OpenAPI\Client\Model\InlineObject16 $_rest_accounts_contacts_departments (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsDepartmentsPostRequest($_rest_accounts_contacts_departments = null)
    {

        $resourcePath = '/rest/accounts/contacts/departments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_contacts_departments)) {
            $_tempBody = $_rest_accounts_contacts_departments;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsGet
     *
     * List contacts
     *
     * @param  string $full_text Filter for a fulltext search (optional)
     * @param  string $contact_email Filter that restricts the search result to contacts resembling to the given email address (optional)
     * @param  string $email Filter that restricts the search result to contacts with a specific email address (optional)
     * @param  string $postal_code Filter that restricts the search result to contacts with a specific postcode (optional)
     * @param  int $plenty_id Filter that restricts the search result to contacts with a specific plentyId (optional)
     * @param  int $external_id Filter that restricts the search result to contacts with a specific externalId (optional)
     * @param  int $number Filter that restricts the search result to contacts with a specific number (optional)
     * @param  int $type_id Filter that restricts the search result to contacts with a specific contact type (optional)
     * @param  int $rating Filter that restricts the search result to contacts with a specific rating (optional)
     * @param  string $created_at_before Filter that restricts the search result to contacts that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $created_at_after Filter that restricts the search result to contacts that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_at_before Filter that restricts the search result to contacts that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_at_after Filter that restricts the search result to contacts that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $last_order_at_before Filter that restricts the search result to contacts whose last order was created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $last_order_at_after Filter that restricts the search result to contacts whose last order was created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts, options, orderSummary, primaryBillingAddress, contactOrders. More than one parameter should be separated by commas. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  string $newsletter_allowance_after Filter that restricts the search result to contacts who registered for the newsletter after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $newsletter_allowance_before Filter that restricts the search result to contacts who registered for the newsletter before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $newsletter_allowance Filter that restricts the search result to contacts who registered for the newsletter. Possible values: &#39;true&#39; and &#39;false&#39;. True: newsletter registration was successful. False: newsletter registration was not successful. (optional)
     * @param  int $contact_id Filter that restricts the search result to a specific contact (optional)
     * @param  string $contact_address Filter that restricts the search result to contacts with a specific address (optional)
     * @param  string $country_id Filter that restricts the search result to contacts with a specific country (optional)
     * @param  string $user_id Filter that restricts the search result to contacts with a specific user (optional)
     * @param  string $referrer_id Filter that restricts the search result to contacts with a specific referrer (optional)
     * @param  string $name Filter that restricts the search result to contacts with a specific name (optional)
     * @param  string $name_or_id Filter that restricts the search result to contacts with a specific name or ID. (optional)
     * @param  string $town Filter that restricts the search result to contacts with a specific town (optional)
     * @param  string $private_phone Filter that restricts the search result to contacts with a private phone number (optional)
     * @param  string $billing_address_id Filter that restricts the search result to contacts with a billing address with the ID provided (optional)
     * @param  string $delivery_address_id Filter that restricts the search result to contacts with a delivery address with the ID provided (optional)
     * @param  int $tag_ids Filter restricts the list of results to contacts with the specified tagIds. More than one ID should be separated by commas. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse2003
     */
    public function restAccountsContactsGet($full_text = null, $contact_email = null, $email = null, $postal_code = null, $plenty_id = null, $external_id = null, $number = null, $type_id = null, $rating = null, $created_at_before = null, $created_at_after = null, $updated_at_before = null, $updated_at_after = null, $last_order_at_before = null, $last_order_at_after = null, $with = null, $page = null, $items_per_page = null, $newsletter_allowance_after = null, $newsletter_allowance_before = null, $newsletter_allowance = null, $contact_id = null, $contact_address = null, $country_id = null, $user_id = null, $referrer_id = null, $name = null, $name_or_id = null, $town = null, $private_phone = null, $billing_address_id = null, $delivery_address_id = null, $tag_ids = null)
    {
        list($response) = $this->restAccountsContactsGetWithHttpInfo($full_text, $contact_email, $email, $postal_code, $plenty_id, $external_id, $number, $type_id, $rating, $created_at_before, $created_at_after, $updated_at_before, $updated_at_after, $last_order_at_before, $last_order_at_after, $with, $page, $items_per_page, $newsletter_allowance_after, $newsletter_allowance_before, $newsletter_allowance, $contact_id, $contact_address, $country_id, $user_id, $referrer_id, $name, $name_or_id, $town, $private_phone, $billing_address_id, $delivery_address_id, $tag_ids);
        return $response;
    }

    /**
     * Operation restAccountsContactsGetWithHttpInfo
     *
     * List contacts
     *
     * @param  string $full_text Filter for a fulltext search (optional)
     * @param  string $contact_email Filter that restricts the search result to contacts resembling to the given email address (optional)
     * @param  string $email Filter that restricts the search result to contacts with a specific email address (optional)
     * @param  string $postal_code Filter that restricts the search result to contacts with a specific postcode (optional)
     * @param  int $plenty_id Filter that restricts the search result to contacts with a specific plentyId (optional)
     * @param  int $external_id Filter that restricts the search result to contacts with a specific externalId (optional)
     * @param  int $number Filter that restricts the search result to contacts with a specific number (optional)
     * @param  int $type_id Filter that restricts the search result to contacts with a specific contact type (optional)
     * @param  int $rating Filter that restricts the search result to contacts with a specific rating (optional)
     * @param  string $created_at_before Filter that restricts the search result to contacts that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $created_at_after Filter that restricts the search result to contacts that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_at_before Filter that restricts the search result to contacts that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_at_after Filter that restricts the search result to contacts that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $last_order_at_before Filter that restricts the search result to contacts whose last order was created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $last_order_at_after Filter that restricts the search result to contacts whose last order was created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts, options, orderSummary, primaryBillingAddress, contactOrders. More than one parameter should be separated by commas. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  string $newsletter_allowance_after Filter that restricts the search result to contacts who registered for the newsletter after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $newsletter_allowance_before Filter that restricts the search result to contacts who registered for the newsletter before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $newsletter_allowance Filter that restricts the search result to contacts who registered for the newsletter. Possible values: &#39;true&#39; and &#39;false&#39;. True: newsletter registration was successful. False: newsletter registration was not successful. (optional)
     * @param  int $contact_id Filter that restricts the search result to a specific contact (optional)
     * @param  string $contact_address Filter that restricts the search result to contacts with a specific address (optional)
     * @param  string $country_id Filter that restricts the search result to contacts with a specific country (optional)
     * @param  string $user_id Filter that restricts the search result to contacts with a specific user (optional)
     * @param  string $referrer_id Filter that restricts the search result to contacts with a specific referrer (optional)
     * @param  string $name Filter that restricts the search result to contacts with a specific name (optional)
     * @param  string $name_or_id Filter that restricts the search result to contacts with a specific name or ID. (optional)
     * @param  string $town Filter that restricts the search result to contacts with a specific town (optional)
     * @param  string $private_phone Filter that restricts the search result to contacts with a private phone number (optional)
     * @param  string $billing_address_id Filter that restricts the search result to contacts with a billing address with the ID provided (optional)
     * @param  string $delivery_address_id Filter that restricts the search result to contacts with a delivery address with the ID provided (optional)
     * @param  int $tag_ids Filter restricts the list of results to contacts with the specified tagIds. More than one ID should be separated by commas. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse2003, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsGetWithHttpInfo($full_text = null, $contact_email = null, $email = null, $postal_code = null, $plenty_id = null, $external_id = null, $number = null, $type_id = null, $rating = null, $created_at_before = null, $created_at_after = null, $updated_at_before = null, $updated_at_after = null, $last_order_at_before = null, $last_order_at_after = null, $with = null, $page = null, $items_per_page = null, $newsletter_allowance_after = null, $newsletter_allowance_before = null, $newsletter_allowance = null, $contact_id = null, $contact_address = null, $country_id = null, $user_id = null, $referrer_id = null, $name = null, $name_or_id = null, $town = null, $private_phone = null, $billing_address_id = null, $delivery_address_id = null, $tag_ids = null)
    {
        $request = $this->restAccountsContactsGetRequest($full_text, $contact_email, $email, $postal_code, $plenty_id, $external_id, $number, $type_id, $rating, $created_at_before, $created_at_after, $updated_at_before, $updated_at_after, $last_order_at_before, $last_order_at_after, $with, $page, $items_per_page, $newsletter_allowance_after, $newsletter_allowance_before, $newsletter_allowance, $contact_id, $contact_address, $country_id, $user_id, $referrer_id, $name, $name_or_id, $town, $private_phone, $billing_address_id, $delivery_address_id, $tag_ids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse2003' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse2003', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse2003';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse2003',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsGetAsync
     *
     * List contacts
     *
     * @param  string $full_text Filter for a fulltext search (optional)
     * @param  string $contact_email Filter that restricts the search result to contacts resembling to the given email address (optional)
     * @param  string $email Filter that restricts the search result to contacts with a specific email address (optional)
     * @param  string $postal_code Filter that restricts the search result to contacts with a specific postcode (optional)
     * @param  int $plenty_id Filter that restricts the search result to contacts with a specific plentyId (optional)
     * @param  int $external_id Filter that restricts the search result to contacts with a specific externalId (optional)
     * @param  int $number Filter that restricts the search result to contacts with a specific number (optional)
     * @param  int $type_id Filter that restricts the search result to contacts with a specific contact type (optional)
     * @param  int $rating Filter that restricts the search result to contacts with a specific rating (optional)
     * @param  string $created_at_before Filter that restricts the search result to contacts that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $created_at_after Filter that restricts the search result to contacts that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_at_before Filter that restricts the search result to contacts that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_at_after Filter that restricts the search result to contacts that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $last_order_at_before Filter that restricts the search result to contacts whose last order was created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $last_order_at_after Filter that restricts the search result to contacts whose last order was created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts, options, orderSummary, primaryBillingAddress, contactOrders. More than one parameter should be separated by commas. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  string $newsletter_allowance_after Filter that restricts the search result to contacts who registered for the newsletter after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $newsletter_allowance_before Filter that restricts the search result to contacts who registered for the newsletter before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $newsletter_allowance Filter that restricts the search result to contacts who registered for the newsletter. Possible values: &#39;true&#39; and &#39;false&#39;. True: newsletter registration was successful. False: newsletter registration was not successful. (optional)
     * @param  int $contact_id Filter that restricts the search result to a specific contact (optional)
     * @param  string $contact_address Filter that restricts the search result to contacts with a specific address (optional)
     * @param  string $country_id Filter that restricts the search result to contacts with a specific country (optional)
     * @param  string $user_id Filter that restricts the search result to contacts with a specific user (optional)
     * @param  string $referrer_id Filter that restricts the search result to contacts with a specific referrer (optional)
     * @param  string $name Filter that restricts the search result to contacts with a specific name (optional)
     * @param  string $name_or_id Filter that restricts the search result to contacts with a specific name or ID. (optional)
     * @param  string $town Filter that restricts the search result to contacts with a specific town (optional)
     * @param  string $private_phone Filter that restricts the search result to contacts with a private phone number (optional)
     * @param  string $billing_address_id Filter that restricts the search result to contacts with a billing address with the ID provided (optional)
     * @param  string $delivery_address_id Filter that restricts the search result to contacts with a delivery address with the ID provided (optional)
     * @param  int $tag_ids Filter restricts the list of results to contacts with the specified tagIds. More than one ID should be separated by commas. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsGetAsync($full_text = null, $contact_email = null, $email = null, $postal_code = null, $plenty_id = null, $external_id = null, $number = null, $type_id = null, $rating = null, $created_at_before = null, $created_at_after = null, $updated_at_before = null, $updated_at_after = null, $last_order_at_before = null, $last_order_at_after = null, $with = null, $page = null, $items_per_page = null, $newsletter_allowance_after = null, $newsletter_allowance_before = null, $newsletter_allowance = null, $contact_id = null, $contact_address = null, $country_id = null, $user_id = null, $referrer_id = null, $name = null, $name_or_id = null, $town = null, $private_phone = null, $billing_address_id = null, $delivery_address_id = null, $tag_ids = null)
    {
        return $this->restAccountsContactsGetAsyncWithHttpInfo($full_text, $contact_email, $email, $postal_code, $plenty_id, $external_id, $number, $type_id, $rating, $created_at_before, $created_at_after, $updated_at_before, $updated_at_after, $last_order_at_before, $last_order_at_after, $with, $page, $items_per_page, $newsletter_allowance_after, $newsletter_allowance_before, $newsletter_allowance, $contact_id, $contact_address, $country_id, $user_id, $referrer_id, $name, $name_or_id, $town, $private_phone, $billing_address_id, $delivery_address_id, $tag_ids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsGetAsyncWithHttpInfo
     *
     * List contacts
     *
     * @param  string $full_text Filter for a fulltext search (optional)
     * @param  string $contact_email Filter that restricts the search result to contacts resembling to the given email address (optional)
     * @param  string $email Filter that restricts the search result to contacts with a specific email address (optional)
     * @param  string $postal_code Filter that restricts the search result to contacts with a specific postcode (optional)
     * @param  int $plenty_id Filter that restricts the search result to contacts with a specific plentyId (optional)
     * @param  int $external_id Filter that restricts the search result to contacts with a specific externalId (optional)
     * @param  int $number Filter that restricts the search result to contacts with a specific number (optional)
     * @param  int $type_id Filter that restricts the search result to contacts with a specific contact type (optional)
     * @param  int $rating Filter that restricts the search result to contacts with a specific rating (optional)
     * @param  string $created_at_before Filter that restricts the search result to contacts that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $created_at_after Filter that restricts the search result to contacts that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_at_before Filter that restricts the search result to contacts that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_at_after Filter that restricts the search result to contacts that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $last_order_at_before Filter that restricts the search result to contacts whose last order was created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $last_order_at_after Filter that restricts the search result to contacts whose last order was created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts, options, orderSummary, primaryBillingAddress, contactOrders. More than one parameter should be separated by commas. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  string $newsletter_allowance_after Filter that restricts the search result to contacts who registered for the newsletter after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $newsletter_allowance_before Filter that restricts the search result to contacts who registered for the newsletter before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $newsletter_allowance Filter that restricts the search result to contacts who registered for the newsletter. Possible values: &#39;true&#39; and &#39;false&#39;. True: newsletter registration was successful. False: newsletter registration was not successful. (optional)
     * @param  int $contact_id Filter that restricts the search result to a specific contact (optional)
     * @param  string $contact_address Filter that restricts the search result to contacts with a specific address (optional)
     * @param  string $country_id Filter that restricts the search result to contacts with a specific country (optional)
     * @param  string $user_id Filter that restricts the search result to contacts with a specific user (optional)
     * @param  string $referrer_id Filter that restricts the search result to contacts with a specific referrer (optional)
     * @param  string $name Filter that restricts the search result to contacts with a specific name (optional)
     * @param  string $name_or_id Filter that restricts the search result to contacts with a specific name or ID. (optional)
     * @param  string $town Filter that restricts the search result to contacts with a specific town (optional)
     * @param  string $private_phone Filter that restricts the search result to contacts with a private phone number (optional)
     * @param  string $billing_address_id Filter that restricts the search result to contacts with a billing address with the ID provided (optional)
     * @param  string $delivery_address_id Filter that restricts the search result to contacts with a delivery address with the ID provided (optional)
     * @param  int $tag_ids Filter restricts the list of results to contacts with the specified tagIds. More than one ID should be separated by commas. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsGetAsyncWithHttpInfo($full_text = null, $contact_email = null, $email = null, $postal_code = null, $plenty_id = null, $external_id = null, $number = null, $type_id = null, $rating = null, $created_at_before = null, $created_at_after = null, $updated_at_before = null, $updated_at_after = null, $last_order_at_before = null, $last_order_at_after = null, $with = null, $page = null, $items_per_page = null, $newsletter_allowance_after = null, $newsletter_allowance_before = null, $newsletter_allowance = null, $contact_id = null, $contact_address = null, $country_id = null, $user_id = null, $referrer_id = null, $name = null, $name_or_id = null, $town = null, $private_phone = null, $billing_address_id = null, $delivery_address_id = null, $tag_ids = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse2003';
        $request = $this->restAccountsContactsGetRequest($full_text, $contact_email, $email, $postal_code, $plenty_id, $external_id, $number, $type_id, $rating, $created_at_before, $created_at_after, $updated_at_before, $updated_at_after, $last_order_at_before, $last_order_at_after, $with, $page, $items_per_page, $newsletter_allowance_after, $newsletter_allowance_before, $newsletter_allowance, $contact_id, $contact_address, $country_id, $user_id, $referrer_id, $name, $name_or_id, $town, $private_phone, $billing_address_id, $delivery_address_id, $tag_ids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsGet'
     *
     * @param  string $full_text Filter for a fulltext search (optional)
     * @param  string $contact_email Filter that restricts the search result to contacts resembling to the given email address (optional)
     * @param  string $email Filter that restricts the search result to contacts with a specific email address (optional)
     * @param  string $postal_code Filter that restricts the search result to contacts with a specific postcode (optional)
     * @param  int $plenty_id Filter that restricts the search result to contacts with a specific plentyId (optional)
     * @param  int $external_id Filter that restricts the search result to contacts with a specific externalId (optional)
     * @param  int $number Filter that restricts the search result to contacts with a specific number (optional)
     * @param  int $type_id Filter that restricts the search result to contacts with a specific contact type (optional)
     * @param  int $rating Filter that restricts the search result to contacts with a specific rating (optional)
     * @param  string $created_at_before Filter that restricts the search result to contacts that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $created_at_after Filter that restricts the search result to contacts that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_at_before Filter that restricts the search result to contacts that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_at_after Filter that restricts the search result to contacts that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $last_order_at_before Filter that restricts the search result to contacts whose last order was created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $last_order_at_after Filter that restricts the search result to contacts whose last order was created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts, options, orderSummary, primaryBillingAddress, contactOrders. More than one parameter should be separated by commas. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  string $newsletter_allowance_after Filter that restricts the search result to contacts who registered for the newsletter after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $newsletter_allowance_before Filter that restricts the search result to contacts who registered for the newsletter before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $newsletter_allowance Filter that restricts the search result to contacts who registered for the newsletter. Possible values: &#39;true&#39; and &#39;false&#39;. True: newsletter registration was successful. False: newsletter registration was not successful. (optional)
     * @param  int $contact_id Filter that restricts the search result to a specific contact (optional)
     * @param  string $contact_address Filter that restricts the search result to contacts with a specific address (optional)
     * @param  string $country_id Filter that restricts the search result to contacts with a specific country (optional)
     * @param  string $user_id Filter that restricts the search result to contacts with a specific user (optional)
     * @param  string $referrer_id Filter that restricts the search result to contacts with a specific referrer (optional)
     * @param  string $name Filter that restricts the search result to contacts with a specific name (optional)
     * @param  string $name_or_id Filter that restricts the search result to contacts with a specific name or ID. (optional)
     * @param  string $town Filter that restricts the search result to contacts with a specific town (optional)
     * @param  string $private_phone Filter that restricts the search result to contacts with a private phone number (optional)
     * @param  string $billing_address_id Filter that restricts the search result to contacts with a billing address with the ID provided (optional)
     * @param  string $delivery_address_id Filter that restricts the search result to contacts with a delivery address with the ID provided (optional)
     * @param  int $tag_ids Filter restricts the list of results to contacts with the specified tagIds. More than one ID should be separated by commas. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsGetRequest($full_text = null, $contact_email = null, $email = null, $postal_code = null, $plenty_id = null, $external_id = null, $number = null, $type_id = null, $rating = null, $created_at_before = null, $created_at_after = null, $updated_at_before = null, $updated_at_after = null, $last_order_at_before = null, $last_order_at_after = null, $with = null, $page = null, $items_per_page = null, $newsletter_allowance_after = null, $newsletter_allowance_before = null, $newsletter_allowance = null, $contact_id = null, $contact_address = null, $country_id = null, $user_id = null, $referrer_id = null, $name = null, $name_or_id = null, $town = null, $private_phone = null, $billing_address_id = null, $delivery_address_id = null, $tag_ids = null)
    {

        $resourcePath = '/rest/accounts/contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($full_text)) {
            $full_text = ObjectSerializer::serializeCollection($full_text, '', true);
        }
        if ($full_text !== null) {
            $queryParams['fullText'] = $full_text;
        }
        // query params
        if (is_array($contact_email)) {
            $contact_email = ObjectSerializer::serializeCollection($contact_email, '', true);
        }
        if ($contact_email !== null) {
            $queryParams['contactEmail'] = $contact_email;
        }
        // query params
        if (is_array($email)) {
            $email = ObjectSerializer::serializeCollection($email, '', true);
        }
        if ($email !== null) {
            $queryParams['email'] = $email;
        }
        // query params
        if (is_array($postal_code)) {
            $postal_code = ObjectSerializer::serializeCollection($postal_code, '', true);
        }
        if ($postal_code !== null) {
            $queryParams['postalCode'] = $postal_code;
        }
        // query params
        if (is_array($plenty_id)) {
            $plenty_id = ObjectSerializer::serializeCollection($plenty_id, '', true);
        }
        if ($plenty_id !== null) {
            $queryParams['plentyId'] = $plenty_id;
        }
        // query params
        if (is_array($external_id)) {
            $external_id = ObjectSerializer::serializeCollection($external_id, '', true);
        }
        if ($external_id !== null) {
            $queryParams['externalId'] = $external_id;
        }
        // query params
        if (is_array($number)) {
            $number = ObjectSerializer::serializeCollection($number, '', true);
        }
        if ($number !== null) {
            $queryParams['number'] = $number;
        }
        // query params
        if (is_array($type_id)) {
            $type_id = ObjectSerializer::serializeCollection($type_id, '', true);
        }
        if ($type_id !== null) {
            $queryParams['typeId'] = $type_id;
        }
        // query params
        if (is_array($rating)) {
            $rating = ObjectSerializer::serializeCollection($rating, '', true);
        }
        if ($rating !== null) {
            $queryParams['rating'] = $rating;
        }
        // query params
        if (is_array($created_at_before)) {
            $created_at_before = ObjectSerializer::serializeCollection($created_at_before, '', true);
        }
        if ($created_at_before !== null) {
            $queryParams['createdAtBefore'] = $created_at_before;
        }
        // query params
        if (is_array($created_at_after)) {
            $created_at_after = ObjectSerializer::serializeCollection($created_at_after, '', true);
        }
        if ($created_at_after !== null) {
            $queryParams['createdAtAfter'] = $created_at_after;
        }
        // query params
        if (is_array($updated_at_before)) {
            $updated_at_before = ObjectSerializer::serializeCollection($updated_at_before, '', true);
        }
        if ($updated_at_before !== null) {
            $queryParams['updatedAtBefore'] = $updated_at_before;
        }
        // query params
        if (is_array($updated_at_after)) {
            $updated_at_after = ObjectSerializer::serializeCollection($updated_at_after, '', true);
        }
        if ($updated_at_after !== null) {
            $queryParams['updatedAtAfter'] = $updated_at_after;
        }
        // query params
        if (is_array($last_order_at_before)) {
            $last_order_at_before = ObjectSerializer::serializeCollection($last_order_at_before, '', true);
        }
        if ($last_order_at_before !== null) {
            $queryParams['lastOrderAtBefore'] = $last_order_at_before;
        }
        // query params
        if (is_array($last_order_at_after)) {
            $last_order_at_after = ObjectSerializer::serializeCollection($last_order_at_after, '', true);
        }
        if ($last_order_at_after !== null) {
            $queryParams['lastOrderAtAfter'] = $last_order_at_after;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }
        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }
        // query params
        if (is_array($newsletter_allowance_after)) {
            $newsletter_allowance_after = ObjectSerializer::serializeCollection($newsletter_allowance_after, '', true);
        }
        if ($newsletter_allowance_after !== null) {
            $queryParams['newsletterAllowanceAfter'] = $newsletter_allowance_after;
        }
        // query params
        if (is_array($newsletter_allowance_before)) {
            $newsletter_allowance_before = ObjectSerializer::serializeCollection($newsletter_allowance_before, '', true);
        }
        if ($newsletter_allowance_before !== null) {
            $queryParams['newsletterAllowanceBefore'] = $newsletter_allowance_before;
        }
        // query params
        if (is_array($newsletter_allowance)) {
            $newsletter_allowance = ObjectSerializer::serializeCollection($newsletter_allowance, '', true);
        }
        if ($newsletter_allowance !== null) {
            $queryParams['newsletterAllowance'] = $newsletter_allowance;
        }
        // query params
        if (is_array($contact_id)) {
            $contact_id = ObjectSerializer::serializeCollection($contact_id, '', true);
        }
        if ($contact_id !== null) {
            $queryParams['contactId'] = $contact_id;
        }
        // query params
        if (is_array($contact_address)) {
            $contact_address = ObjectSerializer::serializeCollection($contact_address, '', true);
        }
        if ($contact_address !== null) {
            $queryParams['contactAddress'] = $contact_address;
        }
        // query params
        if (is_array($country_id)) {
            $country_id = ObjectSerializer::serializeCollection($country_id, '', true);
        }
        if ($country_id !== null) {
            $queryParams['countryId'] = $country_id;
        }
        // query params
        if (is_array($user_id)) {
            $user_id = ObjectSerializer::serializeCollection($user_id, '', true);
        }
        if ($user_id !== null) {
            $queryParams['userId'] = $user_id;
        }
        // query params
        if (is_array($referrer_id)) {
            $referrer_id = ObjectSerializer::serializeCollection($referrer_id, '', true);
        }
        if ($referrer_id !== null) {
            $queryParams['referrerId'] = $referrer_id;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($name_or_id)) {
            $name_or_id = ObjectSerializer::serializeCollection($name_or_id, '', true);
        }
        if ($name_or_id !== null) {
            $queryParams['nameOrId'] = $name_or_id;
        }
        // query params
        if (is_array($town)) {
            $town = ObjectSerializer::serializeCollection($town, '', true);
        }
        if ($town !== null) {
            $queryParams['town'] = $town;
        }
        // query params
        if (is_array($private_phone)) {
            $private_phone = ObjectSerializer::serializeCollection($private_phone, '', true);
        }
        if ($private_phone !== null) {
            $queryParams['privatePhone'] = $private_phone;
        }
        // query params
        if (is_array($billing_address_id)) {
            $billing_address_id = ObjectSerializer::serializeCollection($billing_address_id, '', true);
        }
        if ($billing_address_id !== null) {
            $queryParams['billingAddressId'] = $billing_address_id;
        }
        // query params
        if (is_array($delivery_address_id)) {
            $delivery_address_id = ObjectSerializer::serializeCollection($delivery_address_id, '', true);
        }
        if ($delivery_address_id !== null) {
            $queryParams['deliveryAddressId'] = $delivery_address_id;
        }
        // query params
        if (is_array($tag_ids)) {
            $tag_ids = ObjectSerializer::serializeCollection($tag_ids, '', true);
        }
        if ($tag_ids !== null) {
            $queryParams['tagIds'] = $tag_ids;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsGroupFunctionsGet
     *
     * List all group function related data
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restAccountsContactsGroupFunctionsGet()
    {
        list($response) = $this->restAccountsContactsGroupFunctionsGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountsContactsGroupFunctionsGetWithHttpInfo
     *
     * List all group function related data
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsGroupFunctionsGetWithHttpInfo()
    {
        $request = $this->restAccountsContactsGroupFunctionsGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsGroupFunctionsGetAsync
     *
     * List all group function related data
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsGroupFunctionsGetAsync()
    {
        return $this->restAccountsContactsGroupFunctionsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsGroupFunctionsGetAsyncWithHttpInfo
     *
     * List all group function related data
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsGroupFunctionsGetAsyncWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->restAccountsContactsGroupFunctionsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsGroupFunctionsGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsGroupFunctionsGetRequest()
    {

        $resourcePath = '/rest/accounts/contacts/group_functions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsGroupFunctionsPost
     *
     * Apply selected group function options for given contact IDs
     *
     * @param  int $contact_list A list of contact IDs (optional)
     * @param  int $email_template An email template ID (optional)
     * @param  int $newsletter A newsletter folder ID (optional)
     * @param  int $address_label_template An address label template ID (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restAccountsContactsGroupFunctionsPost($contact_list = null, $email_template = null, $newsletter = null, $address_label_template = null)
    {
        list($response) = $this->restAccountsContactsGroupFunctionsPostWithHttpInfo($contact_list, $email_template, $newsletter, $address_label_template);
        return $response;
    }

    /**
     * Operation restAccountsContactsGroupFunctionsPostWithHttpInfo
     *
     * Apply selected group function options for given contact IDs
     *
     * @param  int $contact_list A list of contact IDs (optional)
     * @param  int $email_template An email template ID (optional)
     * @param  int $newsletter A newsletter folder ID (optional)
     * @param  int $address_label_template An address label template ID (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsGroupFunctionsPostWithHttpInfo($contact_list = null, $email_template = null, $newsletter = null, $address_label_template = null)
    {
        $request = $this->restAccountsContactsGroupFunctionsPostRequest($contact_list, $email_template, $newsletter, $address_label_template);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsGroupFunctionsPostAsync
     *
     * Apply selected group function options for given contact IDs
     *
     * @param  int $contact_list A list of contact IDs (optional)
     * @param  int $email_template An email template ID (optional)
     * @param  int $newsletter A newsletter folder ID (optional)
     * @param  int $address_label_template An address label template ID (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsGroupFunctionsPostAsync($contact_list = null, $email_template = null, $newsletter = null, $address_label_template = null)
    {
        return $this->restAccountsContactsGroupFunctionsPostAsyncWithHttpInfo($contact_list, $email_template, $newsletter, $address_label_template)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsGroupFunctionsPostAsyncWithHttpInfo
     *
     * Apply selected group function options for given contact IDs
     *
     * @param  int $contact_list A list of contact IDs (optional)
     * @param  int $email_template An email template ID (optional)
     * @param  int $newsletter A newsletter folder ID (optional)
     * @param  int $address_label_template An address label template ID (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsGroupFunctionsPostAsyncWithHttpInfo($contact_list = null, $email_template = null, $newsletter = null, $address_label_template = null)
    {
        $returnType = 'object';
        $request = $this->restAccountsContactsGroupFunctionsPostRequest($contact_list, $email_template, $newsletter, $address_label_template);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsGroupFunctionsPost'
     *
     * @param  int $contact_list A list of contact IDs (optional)
     * @param  int $email_template An email template ID (optional)
     * @param  int $newsletter A newsletter folder ID (optional)
     * @param  int $address_label_template An address label template ID (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsGroupFunctionsPostRequest($contact_list = null, $email_template = null, $newsletter = null, $address_label_template = null)
    {

        $resourcePath = '/rest/accounts/contacts/group_functions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($contact_list)) {
            $contact_list = ObjectSerializer::serializeCollection($contact_list, '', true);
        }
        if ($contact_list !== null) {
            $queryParams['contactList'] = $contact_list;
        }
        // query params
        if (is_array($email_template)) {
            $email_template = ObjectSerializer::serializeCollection($email_template, '', true);
        }
        if ($email_template !== null) {
            $queryParams['emailTemplate'] = $email_template;
        }
        // query params
        if (is_array($newsletter)) {
            $newsletter = ObjectSerializer::serializeCollection($newsletter, '', true);
        }
        if ($newsletter !== null) {
            $queryParams['newsletter'] = $newsletter;
        }
        // query params
        if (is_array($address_label_template)) {
            $address_label_template = ObjectSerializer::serializeCollection($address_label_template, '', true);
        }
        if ($address_label_template !== null) {
            $queryParams['addressLabelTemplate'] = $address_label_template;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesGet
     *
     * List contact option sub-types
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactOptionSubType[]
     */
    public function restAccountsContactsOptionSubTypesGet()
    {
        list($response) = $this->restAccountsContactsOptionSubTypesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionSubTypesGetWithHttpInfo
     *
     * List contact option sub-types
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactOptionSubType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionSubTypesGetWithHttpInfo()
    {
        $request = $this->restAccountsContactsOptionSubTypesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactOptionSubType[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactOptionSubType[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactOptionSubType[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactOptionSubType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionSubTypesGetAsync
     *
     * List contact option sub-types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesGetAsync()
    {
        return $this->restAccountsContactsOptionSubTypesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesGetAsyncWithHttpInfo
     *
     * List contact option sub-types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesGetAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\ContactOptionSubType[]';
        $request = $this->restAccountsContactsOptionSubTypesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionSubTypesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionSubTypesGetRequest()
    {

        $resourcePath = '/rest/accounts/contacts/option_sub_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdDelete
     *
     * Delete contact option sub-type
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdDelete($option_sub_type_id)
    {
        $this->restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteWithHttpInfo($option_sub_type_id);
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteWithHttpInfo
     *
     * Delete contact option sub-type
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteWithHttpInfo($option_sub_type_id)
    {
        $request = $this->restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteRequest($option_sub_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteAsync
     *
     * Delete contact option sub-type
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteAsync($option_sub_type_id)
    {
        return $this->restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteAsyncWithHttpInfo($option_sub_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteAsyncWithHttpInfo
     *
     * Delete contact option sub-type
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteAsyncWithHttpInfo($option_sub_type_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteRequest($option_sub_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionSubTypesOptionSubTypeIdDelete'
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteRequest($option_sub_type_id)
    {
        // verify the required parameter 'option_sub_type_id' is set
        if ($option_sub_type_id === null || (is_array($option_sub_type_id) && count($option_sub_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_sub_type_id when calling restAccountsContactsOptionSubTypesOptionSubTypeIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/contacts/option_sub_types/{optionSubTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_sub_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionSubTypeId' . '}',
                ObjectSerializer::toPathValue($option_sub_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdGet
     *
     * Get contact option sub-type
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactOptionSubType
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdGet($option_sub_type_id)
    {
        list($response) = $this->restAccountsContactsOptionSubTypesOptionSubTypeIdGetWithHttpInfo($option_sub_type_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdGetWithHttpInfo
     *
     * Get contact option sub-type
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactOptionSubType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdGetWithHttpInfo($option_sub_type_id)
    {
        $request = $this->restAccountsContactsOptionSubTypesOptionSubTypeIdGetRequest($option_sub_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactOptionSubType' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactOptionSubType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactOptionSubType';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactOptionSubType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdGetAsync
     *
     * Get contact option sub-type
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdGetAsync($option_sub_type_id)
    {
        return $this->restAccountsContactsOptionSubTypesOptionSubTypeIdGetAsyncWithHttpInfo($option_sub_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdGetAsyncWithHttpInfo
     *
     * Get contact option sub-type
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdGetAsyncWithHttpInfo($option_sub_type_id)
    {
        $returnType = '\OpenAPI\Client\Model\ContactOptionSubType';
        $request = $this->restAccountsContactsOptionSubTypesOptionSubTypeIdGetRequest($option_sub_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionSubTypesOptionSubTypeIdGet'
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionSubTypesOptionSubTypeIdGetRequest($option_sub_type_id)
    {
        // verify the required parameter 'option_sub_type_id' is set
        if ($option_sub_type_id === null || (is_array($option_sub_type_id) && count($option_sub_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_sub_type_id when calling restAccountsContactsOptionSubTypesOptionSubTypeIdGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/option_sub_types/{optionSubTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_sub_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionSubTypeId' . '}',
                ObjectSerializer::toPathValue($option_sub_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdPut
     *
     * Update contact option sub-type
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     * @param  \OpenAPI\Client\Model\InlineObject19 $_rest_accounts_contacts_option_sub_types_option_sub_type_id _rest_accounts_contacts_option_sub_types_option_sub_type_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactOptionSubType
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdPut($option_sub_type_id, $_rest_accounts_contacts_option_sub_types_option_sub_type_id = null)
    {
        list($response) = $this->restAccountsContactsOptionSubTypesOptionSubTypeIdPutWithHttpInfo($option_sub_type_id, $_rest_accounts_contacts_option_sub_types_option_sub_type_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdPutWithHttpInfo
     *
     * Update contact option sub-type
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     * @param  \OpenAPI\Client\Model\InlineObject19 $_rest_accounts_contacts_option_sub_types_option_sub_type_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactOptionSubType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdPutWithHttpInfo($option_sub_type_id, $_rest_accounts_contacts_option_sub_types_option_sub_type_id = null)
    {
        $request = $this->restAccountsContactsOptionSubTypesOptionSubTypeIdPutRequest($option_sub_type_id, $_rest_accounts_contacts_option_sub_types_option_sub_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactOptionSubType' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactOptionSubType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactOptionSubType';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactOptionSubType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdPutAsync
     *
     * Update contact option sub-type
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     * @param  \OpenAPI\Client\Model\InlineObject19 $_rest_accounts_contacts_option_sub_types_option_sub_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdPutAsync($option_sub_type_id, $_rest_accounts_contacts_option_sub_types_option_sub_type_id = null)
    {
        return $this->restAccountsContactsOptionSubTypesOptionSubTypeIdPutAsyncWithHttpInfo($option_sub_type_id, $_rest_accounts_contacts_option_sub_types_option_sub_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdPutAsyncWithHttpInfo
     *
     * Update contact option sub-type
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     * @param  \OpenAPI\Client\Model\InlineObject19 $_rest_accounts_contacts_option_sub_types_option_sub_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdPutAsyncWithHttpInfo($option_sub_type_id, $_rest_accounts_contacts_option_sub_types_option_sub_type_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\ContactOptionSubType';
        $request = $this->restAccountsContactsOptionSubTypesOptionSubTypeIdPutRequest($option_sub_type_id, $_rest_accounts_contacts_option_sub_types_option_sub_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionSubTypesOptionSubTypeIdPut'
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     * @param  \OpenAPI\Client\Model\InlineObject19 $_rest_accounts_contacts_option_sub_types_option_sub_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionSubTypesOptionSubTypeIdPutRequest($option_sub_type_id, $_rest_accounts_contacts_option_sub_types_option_sub_type_id = null)
    {
        // verify the required parameter 'option_sub_type_id' is set
        if ($option_sub_type_id === null || (is_array($option_sub_type_id) && count($option_sub_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_sub_type_id when calling restAccountsContactsOptionSubTypesOptionSubTypeIdPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/option_sub_types/{optionSubTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_sub_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionSubTypeId' . '}',
                ObjectSerializer::toPathValue($option_sub_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_contacts_option_sub_types_option_sub_type_id)) {
            $_tempBody = $_rest_accounts_contacts_option_sub_types_option_sub_type_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesPost
     *
     * Create contact option sub-type
     *
     * @param  \OpenAPI\Client\Model\InlineObject18 $_rest_accounts_contacts_option_sub_types _rest_accounts_contacts_option_sub_types (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactOptionSubType
     */
    public function restAccountsContactsOptionSubTypesPost($_rest_accounts_contacts_option_sub_types = null)
    {
        list($response) = $this->restAccountsContactsOptionSubTypesPostWithHttpInfo($_rest_accounts_contacts_option_sub_types);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionSubTypesPostWithHttpInfo
     *
     * Create contact option sub-type
     *
     * @param  \OpenAPI\Client\Model\InlineObject18 $_rest_accounts_contacts_option_sub_types (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactOptionSubType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionSubTypesPostWithHttpInfo($_rest_accounts_contacts_option_sub_types = null)
    {
        $request = $this->restAccountsContactsOptionSubTypesPostRequest($_rest_accounts_contacts_option_sub_types);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactOptionSubType' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactOptionSubType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactOptionSubType';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactOptionSubType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionSubTypesPostAsync
     *
     * Create contact option sub-type
     *
     * @param  \OpenAPI\Client\Model\InlineObject18 $_rest_accounts_contacts_option_sub_types (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesPostAsync($_rest_accounts_contacts_option_sub_types = null)
    {
        return $this->restAccountsContactsOptionSubTypesPostAsyncWithHttpInfo($_rest_accounts_contacts_option_sub_types)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesPostAsyncWithHttpInfo
     *
     * Create contact option sub-type
     *
     * @param  \OpenAPI\Client\Model\InlineObject18 $_rest_accounts_contacts_option_sub_types (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesPostAsyncWithHttpInfo($_rest_accounts_contacts_option_sub_types = null)
    {
        $returnType = '\OpenAPI\Client\Model\ContactOptionSubType';
        $request = $this->restAccountsContactsOptionSubTypesPostRequest($_rest_accounts_contacts_option_sub_types);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionSubTypesPost'
     *
     * @param  \OpenAPI\Client\Model\InlineObject18 $_rest_accounts_contacts_option_sub_types (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionSubTypesPostRequest($_rest_accounts_contacts_option_sub_types = null)
    {

        $resourcePath = '/rest/accounts/contacts/option_sub_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_contacts_option_sub_types)) {
            $_tempBody = $_rest_accounts_contacts_option_sub_types;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionTypesGet
     *
     * List contact option types
     *
     * @param  string $with Lists possible option sub-types for each listed option if the parameter &#39;subTypes&#39; is set. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactOptionType[]
     */
    public function restAccountsContactsOptionTypesGet($with = null)
    {
        list($response) = $this->restAccountsContactsOptionTypesGetWithHttpInfo($with);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionTypesGetWithHttpInfo
     *
     * List contact option types
     *
     * @param  string $with Lists possible option sub-types for each listed option if the parameter &#39;subTypes&#39; is set. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactOptionType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionTypesGetWithHttpInfo($with = null)
    {
        $request = $this->restAccountsContactsOptionTypesGetRequest($with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactOptionType[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactOptionType[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactOptionType[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactOptionType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionTypesGetAsync
     *
     * List contact option types
     *
     * @param  string $with Lists possible option sub-types for each listed option if the parameter &#39;subTypes&#39; is set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionTypesGetAsync($with = null)
    {
        return $this->restAccountsContactsOptionTypesGetAsyncWithHttpInfo($with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionTypesGetAsyncWithHttpInfo
     *
     * List contact option types
     *
     * @param  string $with Lists possible option sub-types for each listed option if the parameter &#39;subTypes&#39; is set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionTypesGetAsyncWithHttpInfo($with = null)
    {
        $returnType = '\OpenAPI\Client\Model\ContactOptionType[]';
        $request = $this->restAccountsContactsOptionTypesGetRequest($with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionTypesGet'
     *
     * @param  string $with Lists possible option sub-types for each listed option if the parameter &#39;subTypes&#39; is set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionTypesGetRequest($with = null)
    {

        $resourcePath = '/rest/accounts/contacts/option_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdDelete
     *
     * Delete contact option type
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsOptionTypesOptionTypeIdDelete($option_type_id)
    {
        $this->restAccountsContactsOptionTypesOptionTypeIdDeleteWithHttpInfo($option_type_id);
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdDeleteWithHttpInfo
     *
     * Delete contact option type
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionTypesOptionTypeIdDeleteWithHttpInfo($option_type_id)
    {
        $request = $this->restAccountsContactsOptionTypesOptionTypeIdDeleteRequest($option_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdDeleteAsync
     *
     * Delete contact option type
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionTypesOptionTypeIdDeleteAsync($option_type_id)
    {
        return $this->restAccountsContactsOptionTypesOptionTypeIdDeleteAsyncWithHttpInfo($option_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdDeleteAsyncWithHttpInfo
     *
     * Delete contact option type
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionTypesOptionTypeIdDeleteAsyncWithHttpInfo($option_type_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsOptionTypesOptionTypeIdDeleteRequest($option_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionTypesOptionTypeIdDelete'
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionTypesOptionTypeIdDeleteRequest($option_type_id)
    {
        // verify the required parameter 'option_type_id' is set
        if ($option_type_id === null || (is_array($option_type_id) && count($option_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_type_id when calling restAccountsContactsOptionTypesOptionTypeIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/contacts/option_types/{optionTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionTypeId' . '}',
                ObjectSerializer::toPathValue($option_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdGet
     *
     * Get contact option type
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactOptionType
     */
    public function restAccountsContactsOptionTypesOptionTypeIdGet($option_type_id)
    {
        list($response) = $this->restAccountsContactsOptionTypesOptionTypeIdGetWithHttpInfo($option_type_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdGetWithHttpInfo
     *
     * Get contact option type
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactOptionType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionTypesOptionTypeIdGetWithHttpInfo($option_type_id)
    {
        $request = $this->restAccountsContactsOptionTypesOptionTypeIdGetRequest($option_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactOptionType' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactOptionType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactOptionType';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactOptionType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdGetAsync
     *
     * Get contact option type
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionTypesOptionTypeIdGetAsync($option_type_id)
    {
        return $this->restAccountsContactsOptionTypesOptionTypeIdGetAsyncWithHttpInfo($option_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdGetAsyncWithHttpInfo
     *
     * Get contact option type
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionTypesOptionTypeIdGetAsyncWithHttpInfo($option_type_id)
    {
        $returnType = '\OpenAPI\Client\Model\ContactOptionType';
        $request = $this->restAccountsContactsOptionTypesOptionTypeIdGetRequest($option_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionTypesOptionTypeIdGet'
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionTypesOptionTypeIdGetRequest($option_type_id)
    {
        // verify the required parameter 'option_type_id' is set
        if ($option_type_id === null || (is_array($option_type_id) && count($option_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_type_id when calling restAccountsContactsOptionTypesOptionTypeIdGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/option_types/{optionTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionTypeId' . '}',
                ObjectSerializer::toPathValue($option_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdPut
     *
     * Update contact option type
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     * @param  \OpenAPI\Client\Model\InlineObject21 $_rest_accounts_contacts_option_types_option_type_id _rest_accounts_contacts_option_types_option_type_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactOptionType
     */
    public function restAccountsContactsOptionTypesOptionTypeIdPut($option_type_id, $_rest_accounts_contacts_option_types_option_type_id = null)
    {
        list($response) = $this->restAccountsContactsOptionTypesOptionTypeIdPutWithHttpInfo($option_type_id, $_rest_accounts_contacts_option_types_option_type_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdPutWithHttpInfo
     *
     * Update contact option type
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     * @param  \OpenAPI\Client\Model\InlineObject21 $_rest_accounts_contacts_option_types_option_type_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactOptionType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionTypesOptionTypeIdPutWithHttpInfo($option_type_id, $_rest_accounts_contacts_option_types_option_type_id = null)
    {
        $request = $this->restAccountsContactsOptionTypesOptionTypeIdPutRequest($option_type_id, $_rest_accounts_contacts_option_types_option_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactOptionType' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactOptionType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactOptionType';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactOptionType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdPutAsync
     *
     * Update contact option type
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     * @param  \OpenAPI\Client\Model\InlineObject21 $_rest_accounts_contacts_option_types_option_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionTypesOptionTypeIdPutAsync($option_type_id, $_rest_accounts_contacts_option_types_option_type_id = null)
    {
        return $this->restAccountsContactsOptionTypesOptionTypeIdPutAsyncWithHttpInfo($option_type_id, $_rest_accounts_contacts_option_types_option_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdPutAsyncWithHttpInfo
     *
     * Update contact option type
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     * @param  \OpenAPI\Client\Model\InlineObject21 $_rest_accounts_contacts_option_types_option_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionTypesOptionTypeIdPutAsyncWithHttpInfo($option_type_id, $_rest_accounts_contacts_option_types_option_type_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\ContactOptionType';
        $request = $this->restAccountsContactsOptionTypesOptionTypeIdPutRequest($option_type_id, $_rest_accounts_contacts_option_types_option_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionTypesOptionTypeIdPut'
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     * @param  \OpenAPI\Client\Model\InlineObject21 $_rest_accounts_contacts_option_types_option_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionTypesOptionTypeIdPutRequest($option_type_id, $_rest_accounts_contacts_option_types_option_type_id = null)
    {
        // verify the required parameter 'option_type_id' is set
        if ($option_type_id === null || (is_array($option_type_id) && count($option_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_type_id when calling restAccountsContactsOptionTypesOptionTypeIdPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/option_types/{optionTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionTypeId' . '}',
                ObjectSerializer::toPathValue($option_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_contacts_option_types_option_type_id)) {
            $_tempBody = $_rest_accounts_contacts_option_types_option_type_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionTypesPost
     *
     * Create contact option type
     *
     * @param  \OpenAPI\Client\Model\InlineObject20 $_rest_accounts_contacts_option_types _rest_accounts_contacts_option_types (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactOptionType
     */
    public function restAccountsContactsOptionTypesPost($_rest_accounts_contacts_option_types = null)
    {
        list($response) = $this->restAccountsContactsOptionTypesPostWithHttpInfo($_rest_accounts_contacts_option_types);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionTypesPostWithHttpInfo
     *
     * Create contact option type
     *
     * @param  \OpenAPI\Client\Model\InlineObject20 $_rest_accounts_contacts_option_types (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactOptionType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionTypesPostWithHttpInfo($_rest_accounts_contacts_option_types = null)
    {
        $request = $this->restAccountsContactsOptionTypesPostRequest($_rest_accounts_contacts_option_types);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactOptionType' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactOptionType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactOptionType';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactOptionType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionTypesPostAsync
     *
     * Create contact option type
     *
     * @param  \OpenAPI\Client\Model\InlineObject20 $_rest_accounts_contacts_option_types (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionTypesPostAsync($_rest_accounts_contacts_option_types = null)
    {
        return $this->restAccountsContactsOptionTypesPostAsyncWithHttpInfo($_rest_accounts_contacts_option_types)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionTypesPostAsyncWithHttpInfo
     *
     * Create contact option type
     *
     * @param  \OpenAPI\Client\Model\InlineObject20 $_rest_accounts_contacts_option_types (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionTypesPostAsyncWithHttpInfo($_rest_accounts_contacts_option_types = null)
    {
        $returnType = '\OpenAPI\Client\Model\ContactOptionType';
        $request = $this->restAccountsContactsOptionTypesPostRequest($_rest_accounts_contacts_option_types);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionTypesPost'
     *
     * @param  \OpenAPI\Client\Model\InlineObject20 $_rest_accounts_contacts_option_types (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionTypesPostRequest($_rest_accounts_contacts_option_types = null)
    {

        $resourcePath = '/rest/accounts/contacts/option_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_contacts_option_types)) {
            $_tempBody = $_rest_accounts_contacts_option_types;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdDelete
     *
     * Delete contact option
     *
     * @param  int $option_id The ID of the option (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsOptionsOptionIdDelete($option_id)
    {
        $this->restAccountsContactsOptionsOptionIdDeleteWithHttpInfo($option_id);
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdDeleteWithHttpInfo
     *
     * Delete contact option
     *
     * @param  int $option_id The ID of the option (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionsOptionIdDeleteWithHttpInfo($option_id)
    {
        $request = $this->restAccountsContactsOptionsOptionIdDeleteRequest($option_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdDeleteAsync
     *
     * Delete contact option
     *
     * @param  int $option_id The ID of the option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionsOptionIdDeleteAsync($option_id)
    {
        return $this->restAccountsContactsOptionsOptionIdDeleteAsyncWithHttpInfo($option_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdDeleteAsyncWithHttpInfo
     *
     * Delete contact option
     *
     * @param  int $option_id The ID of the option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionsOptionIdDeleteAsyncWithHttpInfo($option_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsOptionsOptionIdDeleteRequest($option_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionsOptionIdDelete'
     *
     * @param  int $option_id The ID of the option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionsOptionIdDeleteRequest($option_id)
    {
        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_id when calling restAccountsContactsOptionsOptionIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/contacts/options/{optionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionId' . '}',
                ObjectSerializer::toPathValue($option_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdGet
     *
     * Get contact option
     *
     * @param  int $option_id The ID of the option (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactOption
     */
    public function restAccountsContactsOptionsOptionIdGet($option_id)
    {
        list($response) = $this->restAccountsContactsOptionsOptionIdGetWithHttpInfo($option_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdGetWithHttpInfo
     *
     * Get contact option
     *
     * @param  int $option_id The ID of the option (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionsOptionIdGetWithHttpInfo($option_id)
    {
        $request = $this->restAccountsContactsOptionsOptionIdGetRequest($option_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactOption' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactOption';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdGetAsync
     *
     * Get contact option
     *
     * @param  int $option_id The ID of the option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionsOptionIdGetAsync($option_id)
    {
        return $this->restAccountsContactsOptionsOptionIdGetAsyncWithHttpInfo($option_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdGetAsyncWithHttpInfo
     *
     * Get contact option
     *
     * @param  int $option_id The ID of the option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionsOptionIdGetAsyncWithHttpInfo($option_id)
    {
        $returnType = '\OpenAPI\Client\Model\ContactOption';
        $request = $this->restAccountsContactsOptionsOptionIdGetRequest($option_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionsOptionIdGet'
     *
     * @param  int $option_id The ID of the option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionsOptionIdGetRequest($option_id)
    {
        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_id when calling restAccountsContactsOptionsOptionIdGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/options/{optionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionId' . '}',
                ObjectSerializer::toPathValue($option_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdPut
     *
     * Update contact option
     *
     * @param  int $option_id The ID of the option (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactOption
     */
    public function restAccountsContactsOptionsOptionIdPut($option_id)
    {
        list($response) = $this->restAccountsContactsOptionsOptionIdPutWithHttpInfo($option_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdPutWithHttpInfo
     *
     * Update contact option
     *
     * @param  int $option_id The ID of the option (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionsOptionIdPutWithHttpInfo($option_id)
    {
        $request = $this->restAccountsContactsOptionsOptionIdPutRequest($option_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactOption' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactOption';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdPutAsync
     *
     * Update contact option
     *
     * @param  int $option_id The ID of the option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionsOptionIdPutAsync($option_id)
    {
        return $this->restAccountsContactsOptionsOptionIdPutAsyncWithHttpInfo($option_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdPutAsyncWithHttpInfo
     *
     * Update contact option
     *
     * @param  int $option_id The ID of the option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionsOptionIdPutAsyncWithHttpInfo($option_id)
    {
        $returnType = '\OpenAPI\Client\Model\ContactOption';
        $request = $this->restAccountsContactsOptionsOptionIdPutRequest($option_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionsOptionIdPut'
     *
     * @param  int $option_id The ID of the option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionsOptionIdPutRequest($option_id)
    {
        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_id when calling restAccountsContactsOptionsOptionIdPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/options/{optionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionId' . '}',
                ObjectSerializer::toPathValue($option_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsPositionsGet
     *
     * List contact positions
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactPosition[]
     */
    public function restAccountsContactsPositionsGet()
    {
        list($response) = $this->restAccountsContactsPositionsGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountsContactsPositionsGetWithHttpInfo
     *
     * List contact positions
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactPosition[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsPositionsGetWithHttpInfo()
    {
        $request = $this->restAccountsContactsPositionsGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactPosition[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactPosition[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactPosition[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactPosition[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsPositionsGetAsync
     *
     * List contact positions
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsPositionsGetAsync()
    {
        return $this->restAccountsContactsPositionsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsPositionsGetAsyncWithHttpInfo
     *
     * List contact positions
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsPositionsGetAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\ContactPosition[]';
        $request = $this->restAccountsContactsPositionsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsPositionsGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsPositionsGetRequest()
    {

        $resourcePath = '/rest/accounts/contacts/positions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdDelete
     *
     * Delete contact position
     *
     * @param  int $position_id The ID of the position (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsPositionsPositionIdDelete($position_id)
    {
        $this->restAccountsContactsPositionsPositionIdDeleteWithHttpInfo($position_id);
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdDeleteWithHttpInfo
     *
     * Delete contact position
     *
     * @param  int $position_id The ID of the position (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsPositionsPositionIdDeleteWithHttpInfo($position_id)
    {
        $request = $this->restAccountsContactsPositionsPositionIdDeleteRequest($position_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdDeleteAsync
     *
     * Delete contact position
     *
     * @param  int $position_id The ID of the position (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsPositionsPositionIdDeleteAsync($position_id)
    {
        return $this->restAccountsContactsPositionsPositionIdDeleteAsyncWithHttpInfo($position_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdDeleteAsyncWithHttpInfo
     *
     * Delete contact position
     *
     * @param  int $position_id The ID of the position (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsPositionsPositionIdDeleteAsyncWithHttpInfo($position_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsPositionsPositionIdDeleteRequest($position_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsPositionsPositionIdDelete'
     *
     * @param  int $position_id The ID of the position (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsPositionsPositionIdDeleteRequest($position_id)
    {
        // verify the required parameter 'position_id' is set
        if ($position_id === null || (is_array($position_id) && count($position_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $position_id when calling restAccountsContactsPositionsPositionIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/contacts/positions/{positionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($position_id !== null) {
            $resourcePath = str_replace(
                '{' . 'positionId' . '}',
                ObjectSerializer::toPathValue($position_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdGet
     *
     * Get contact position
     *
     * @param  int $position_id The ID of the position (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactPosition
     */
    public function restAccountsContactsPositionsPositionIdGet($position_id)
    {
        list($response) = $this->restAccountsContactsPositionsPositionIdGetWithHttpInfo($position_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdGetWithHttpInfo
     *
     * Get contact position
     *
     * @param  int $position_id The ID of the position (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactPosition, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsPositionsPositionIdGetWithHttpInfo($position_id)
    {
        $request = $this->restAccountsContactsPositionsPositionIdGetRequest($position_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactPosition' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactPosition', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactPosition';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactPosition',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdGetAsync
     *
     * Get contact position
     *
     * @param  int $position_id The ID of the position (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsPositionsPositionIdGetAsync($position_id)
    {
        return $this->restAccountsContactsPositionsPositionIdGetAsyncWithHttpInfo($position_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdGetAsyncWithHttpInfo
     *
     * Get contact position
     *
     * @param  int $position_id The ID of the position (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsPositionsPositionIdGetAsyncWithHttpInfo($position_id)
    {
        $returnType = '\OpenAPI\Client\Model\ContactPosition';
        $request = $this->restAccountsContactsPositionsPositionIdGetRequest($position_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsPositionsPositionIdGet'
     *
     * @param  int $position_id The ID of the position (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsPositionsPositionIdGetRequest($position_id)
    {
        // verify the required parameter 'position_id' is set
        if ($position_id === null || (is_array($position_id) && count($position_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $position_id when calling restAccountsContactsPositionsPositionIdGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/positions/{positionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($position_id !== null) {
            $resourcePath = str_replace(
                '{' . 'positionId' . '}',
                ObjectSerializer::toPathValue($position_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdPut
     *
     * Update contact position
     *
     * @param  int $position_id The ID of the position (required)
     * @param  \OpenAPI\Client\Model\InlineObject23 $_rest_accounts_contacts_positions_position_id _rest_accounts_contacts_positions_position_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactPosition
     */
    public function restAccountsContactsPositionsPositionIdPut($position_id, $_rest_accounts_contacts_positions_position_id = null)
    {
        list($response) = $this->restAccountsContactsPositionsPositionIdPutWithHttpInfo($position_id, $_rest_accounts_contacts_positions_position_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdPutWithHttpInfo
     *
     * Update contact position
     *
     * @param  int $position_id The ID of the position (required)
     * @param  \OpenAPI\Client\Model\InlineObject23 $_rest_accounts_contacts_positions_position_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactPosition, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsPositionsPositionIdPutWithHttpInfo($position_id, $_rest_accounts_contacts_positions_position_id = null)
    {
        $request = $this->restAccountsContactsPositionsPositionIdPutRequest($position_id, $_rest_accounts_contacts_positions_position_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactPosition' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactPosition', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactPosition';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactPosition',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdPutAsync
     *
     * Update contact position
     *
     * @param  int $position_id The ID of the position (required)
     * @param  \OpenAPI\Client\Model\InlineObject23 $_rest_accounts_contacts_positions_position_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsPositionsPositionIdPutAsync($position_id, $_rest_accounts_contacts_positions_position_id = null)
    {
        return $this->restAccountsContactsPositionsPositionIdPutAsyncWithHttpInfo($position_id, $_rest_accounts_contacts_positions_position_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdPutAsyncWithHttpInfo
     *
     * Update contact position
     *
     * @param  int $position_id The ID of the position (required)
     * @param  \OpenAPI\Client\Model\InlineObject23 $_rest_accounts_contacts_positions_position_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsPositionsPositionIdPutAsyncWithHttpInfo($position_id, $_rest_accounts_contacts_positions_position_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\ContactPosition';
        $request = $this->restAccountsContactsPositionsPositionIdPutRequest($position_id, $_rest_accounts_contacts_positions_position_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsPositionsPositionIdPut'
     *
     * @param  int $position_id The ID of the position (required)
     * @param  \OpenAPI\Client\Model\InlineObject23 $_rest_accounts_contacts_positions_position_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsPositionsPositionIdPutRequest($position_id, $_rest_accounts_contacts_positions_position_id = null)
    {
        // verify the required parameter 'position_id' is set
        if ($position_id === null || (is_array($position_id) && count($position_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $position_id when calling restAccountsContactsPositionsPositionIdPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/positions/{positionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($position_id !== null) {
            $resourcePath = str_replace(
                '{' . 'positionId' . '}',
                ObjectSerializer::toPathValue($position_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_contacts_positions_position_id)) {
            $_tempBody = $_rest_accounts_contacts_positions_position_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsPositionsPost
     *
     * Create contact position
     *
     * @param  \OpenAPI\Client\Model\InlineObject22 $_rest_accounts_contacts_positions _rest_accounts_contacts_positions (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactPosition
     */
    public function restAccountsContactsPositionsPost($_rest_accounts_contacts_positions = null)
    {
        list($response) = $this->restAccountsContactsPositionsPostWithHttpInfo($_rest_accounts_contacts_positions);
        return $response;
    }

    /**
     * Operation restAccountsContactsPositionsPostWithHttpInfo
     *
     * Create contact position
     *
     * @param  \OpenAPI\Client\Model\InlineObject22 $_rest_accounts_contacts_positions (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactPosition, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsPositionsPostWithHttpInfo($_rest_accounts_contacts_positions = null)
    {
        $request = $this->restAccountsContactsPositionsPostRequest($_rest_accounts_contacts_positions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactPosition' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactPosition', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactPosition';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactPosition',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsPositionsPostAsync
     *
     * Create contact position
     *
     * @param  \OpenAPI\Client\Model\InlineObject22 $_rest_accounts_contacts_positions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsPositionsPostAsync($_rest_accounts_contacts_positions = null)
    {
        return $this->restAccountsContactsPositionsPostAsyncWithHttpInfo($_rest_accounts_contacts_positions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsPositionsPostAsyncWithHttpInfo
     *
     * Create contact position
     *
     * @param  \OpenAPI\Client\Model\InlineObject22 $_rest_accounts_contacts_positions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsPositionsPostAsyncWithHttpInfo($_rest_accounts_contacts_positions = null)
    {
        $returnType = '\OpenAPI\Client\Model\ContactPosition';
        $request = $this->restAccountsContactsPositionsPostRequest($_rest_accounts_contacts_positions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsPositionsPost'
     *
     * @param  \OpenAPI\Client\Model\InlineObject22 $_rest_accounts_contacts_positions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsPositionsPostRequest($_rest_accounts_contacts_positions = null)
    {

        $resourcePath = '/rest/accounts/contacts/positions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_contacts_positions)) {
            $_tempBody = $_rest_accounts_contacts_positions;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsPost
     *
     * Create contact
     *
     * @param  \OpenAPI\Client\Model\InlineObject11 $_rest_accounts_contacts _rest_accounts_contacts (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Contact
     */
    public function restAccountsContactsPost($_rest_accounts_contacts = null)
    {
        list($response) = $this->restAccountsContactsPostWithHttpInfo($_rest_accounts_contacts);
        return $response;
    }

    /**
     * Operation restAccountsContactsPostWithHttpInfo
     *
     * Create contact
     *
     * @param  \OpenAPI\Client\Model\InlineObject11 $_rest_accounts_contacts (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Contact, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsPostWithHttpInfo($_rest_accounts_contacts = null)
    {
        $request = $this->restAccountsContactsPostRequest($_rest_accounts_contacts);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Contact' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Contact', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Contact';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Contact',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsPostAsync
     *
     * Create contact
     *
     * @param  \OpenAPI\Client\Model\InlineObject11 $_rest_accounts_contacts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsPostAsync($_rest_accounts_contacts = null)
    {
        return $this->restAccountsContactsPostAsyncWithHttpInfo($_rest_accounts_contacts)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsPostAsyncWithHttpInfo
     *
     * Create contact
     *
     * @param  \OpenAPI\Client\Model\InlineObject11 $_rest_accounts_contacts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsPostAsyncWithHttpInfo($_rest_accounts_contacts = null)
    {
        $returnType = '\OpenAPI\Client\Model\Contact';
        $request = $this->restAccountsContactsPostRequest($_rest_accounts_contacts);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsPost'
     *
     * @param  \OpenAPI\Client\Model\InlineObject11 $_rest_accounts_contacts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsPostRequest($_rest_accounts_contacts = null)
    {

        $resourcePath = '/rest/accounts/contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_contacts)) {
            $_tempBody = $_rest_accounts_contacts;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsTypesGet
     *
     * List contact types
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactType[]
     */
    public function restAccountsContactsTypesGet()
    {
        list($response) = $this->restAccountsContactsTypesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountsContactsTypesGetWithHttpInfo
     *
     * List contact types
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsTypesGetWithHttpInfo()
    {
        $request = $this->restAccountsContactsTypesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactType[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactType[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactType[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsTypesGetAsync
     *
     * List contact types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsTypesGetAsync()
    {
        return $this->restAccountsContactsTypesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsTypesGetAsyncWithHttpInfo
     *
     * List contact types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsTypesGetAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\ContactType[]';
        $request = $this->restAccountsContactsTypesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsTypesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsTypesGetRequest()
    {

        $resourcePath = '/rest/accounts/contacts/types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsTypesPost
     *
     * Create contact type
     *
     * @param  \OpenAPI\Client\Model\InlineObject24 $_rest_accounts_contacts_types _rest_accounts_contacts_types (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactType
     */
    public function restAccountsContactsTypesPost($_rest_accounts_contacts_types = null)
    {
        list($response) = $this->restAccountsContactsTypesPostWithHttpInfo($_rest_accounts_contacts_types);
        return $response;
    }

    /**
     * Operation restAccountsContactsTypesPostWithHttpInfo
     *
     * Create contact type
     *
     * @param  \OpenAPI\Client\Model\InlineObject24 $_rest_accounts_contacts_types (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsTypesPostWithHttpInfo($_rest_accounts_contacts_types = null)
    {
        $request = $this->restAccountsContactsTypesPostRequest($_rest_accounts_contacts_types);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactType' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactType';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsTypesPostAsync
     *
     * Create contact type
     *
     * @param  \OpenAPI\Client\Model\InlineObject24 $_rest_accounts_contacts_types (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsTypesPostAsync($_rest_accounts_contacts_types = null)
    {
        return $this->restAccountsContactsTypesPostAsyncWithHttpInfo($_rest_accounts_contacts_types)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsTypesPostAsyncWithHttpInfo
     *
     * Create contact type
     *
     * @param  \OpenAPI\Client\Model\InlineObject24 $_rest_accounts_contacts_types (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsTypesPostAsyncWithHttpInfo($_rest_accounts_contacts_types = null)
    {
        $returnType = '\OpenAPI\Client\Model\ContactType';
        $request = $this->restAccountsContactsTypesPostRequest($_rest_accounts_contacts_types);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsTypesPost'
     *
     * @param  \OpenAPI\Client\Model\InlineObject24 $_rest_accounts_contacts_types (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsTypesPostRequest($_rest_accounts_contacts_types = null)
    {

        $resourcePath = '/rest/accounts/contacts/types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_contacts_types)) {
            $_tempBody = $_rest_accounts_contacts_types;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsTypesTypeIdDelete
     *
     * Delete contact type
     *
     * @param  int $type_id The ID of the contact type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsTypesTypeIdDelete($type_id)
    {
        $this->restAccountsContactsTypesTypeIdDeleteWithHttpInfo($type_id);
    }

    /**
     * Operation restAccountsContactsTypesTypeIdDeleteWithHttpInfo
     *
     * Delete contact type
     *
     * @param  int $type_id The ID of the contact type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsTypesTypeIdDeleteWithHttpInfo($type_id)
    {
        $request = $this->restAccountsContactsTypesTypeIdDeleteRequest($type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsTypesTypeIdDeleteAsync
     *
     * Delete contact type
     *
     * @param  int $type_id The ID of the contact type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsTypesTypeIdDeleteAsync($type_id)
    {
        return $this->restAccountsContactsTypesTypeIdDeleteAsyncWithHttpInfo($type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsTypesTypeIdDeleteAsyncWithHttpInfo
     *
     * Delete contact type
     *
     * @param  int $type_id The ID of the contact type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsTypesTypeIdDeleteAsyncWithHttpInfo($type_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsTypesTypeIdDeleteRequest($type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsTypesTypeIdDelete'
     *
     * @param  int $type_id The ID of the contact type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsTypesTypeIdDeleteRequest($type_id)
    {
        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_id when calling restAccountsContactsTypesTypeIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/contacts/types/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsTypesTypeIdGet
     *
     * Get contact type
     *
     * @param  int $type_id The ID of the contact type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactType
     */
    public function restAccountsContactsTypesTypeIdGet($type_id)
    {
        list($response) = $this->restAccountsContactsTypesTypeIdGetWithHttpInfo($type_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsTypesTypeIdGetWithHttpInfo
     *
     * Get contact type
     *
     * @param  int $type_id The ID of the contact type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsTypesTypeIdGetWithHttpInfo($type_id)
    {
        $request = $this->restAccountsContactsTypesTypeIdGetRequest($type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactType' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactType';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsTypesTypeIdGetAsync
     *
     * Get contact type
     *
     * @param  int $type_id The ID of the contact type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsTypesTypeIdGetAsync($type_id)
    {
        return $this->restAccountsContactsTypesTypeIdGetAsyncWithHttpInfo($type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsTypesTypeIdGetAsyncWithHttpInfo
     *
     * Get contact type
     *
     * @param  int $type_id The ID of the contact type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsTypesTypeIdGetAsyncWithHttpInfo($type_id)
    {
        $returnType = '\OpenAPI\Client\Model\ContactType';
        $request = $this->restAccountsContactsTypesTypeIdGetRequest($type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsTypesTypeIdGet'
     *
     * @param  int $type_id The ID of the contact type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsTypesTypeIdGetRequest($type_id)
    {
        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_id when calling restAccountsContactsTypesTypeIdGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/types/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsTypesTypeIdPut
     *
     * Update contact type
     *
     * @param  int $type_id The ID of the contact type (required)
     * @param  \OpenAPI\Client\Model\InlineObject25 $_rest_accounts_contacts_types_type_id _rest_accounts_contacts_types_type_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactType
     */
    public function restAccountsContactsTypesTypeIdPut($type_id, $_rest_accounts_contacts_types_type_id = null)
    {
        list($response) = $this->restAccountsContactsTypesTypeIdPutWithHttpInfo($type_id, $_rest_accounts_contacts_types_type_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsTypesTypeIdPutWithHttpInfo
     *
     * Update contact type
     *
     * @param  int $type_id The ID of the contact type (required)
     * @param  \OpenAPI\Client\Model\InlineObject25 $_rest_accounts_contacts_types_type_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsTypesTypeIdPutWithHttpInfo($type_id, $_rest_accounts_contacts_types_type_id = null)
    {
        $request = $this->restAccountsContactsTypesTypeIdPutRequest($type_id, $_rest_accounts_contacts_types_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactType' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactType';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsTypesTypeIdPutAsync
     *
     * Update contact type
     *
     * @param  int $type_id The ID of the contact type (required)
     * @param  \OpenAPI\Client\Model\InlineObject25 $_rest_accounts_contacts_types_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsTypesTypeIdPutAsync($type_id, $_rest_accounts_contacts_types_type_id = null)
    {
        return $this->restAccountsContactsTypesTypeIdPutAsyncWithHttpInfo($type_id, $_rest_accounts_contacts_types_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsTypesTypeIdPutAsyncWithHttpInfo
     *
     * Update contact type
     *
     * @param  int $type_id The ID of the contact type (required)
     * @param  \OpenAPI\Client\Model\InlineObject25 $_rest_accounts_contacts_types_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsTypesTypeIdPutAsyncWithHttpInfo($type_id, $_rest_accounts_contacts_types_type_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\ContactType';
        $request = $this->restAccountsContactsTypesTypeIdPutRequest($type_id, $_rest_accounts_contacts_types_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsTypesTypeIdPut'
     *
     * @param  int $type_id The ID of the contact type (required)
     * @param  \OpenAPI\Client\Model\InlineObject25 $_rest_accounts_contacts_types_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsTypesTypeIdPutRequest($type_id, $_rest_accounts_contacts_types_type_id = null)
    {
        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_id when calling restAccountsContactsTypesTypeIdPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/types/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_accounts_contacts_types_type_id)) {
            $_tempBody = $_rest_accounts_contacts_types_type_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsGet
     *
     * List accounts
     *
     * @param  string $updated_at Filter that restricts the search result to accounts that were updated according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;eq:yyyy-mm-dd&#39; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;gt:yyyy-mm-dd&#39; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;gte:yyyy-mm-dd&#39; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;lt:yyyy-mm-dd&#39; (&lt;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;lte:yyyy-mm-dd&#39; (&lt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;                                    &lt;/ul&gt; (optional)
     * @param  string $created_at Filter that restricts the search result to accounts that were created according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;eq:yyyy-mm-dd&#39; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;gt:yyyy-mm-dd&#39; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;gte:yyyy-mm-dd&#39; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;lt:yyyy-mm-dd&#39; (&lt;)&lt;/li&gt;                                   &lt;li&gt;&#39;createdAt&#x3D;lte:yyyy-mm-dd&#39; (&lt;&#x3D;)&lt;/li&gt;                                   &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;          &lt;/ul&gt; (optional)
     * @param  string $company_name Filter that restricts the search result to accounts that have a company name according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;companyName&#x3D;like:expamle&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;companyName&#x3D;eq:example&#39; (&#x3D;)&lt;/li&gt;                                    &lt;/ul&gt; (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restAccountsGet($updated_at = null, $created_at = null, $company_name = null)
    {
        list($response) = $this->restAccountsGetWithHttpInfo($updated_at, $created_at, $company_name);
        return $response;
    }

    /**
     * Operation restAccountsGetWithHttpInfo
     *
     * List accounts
     *
     * @param  string $updated_at Filter that restricts the search result to accounts that were updated according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;eq:yyyy-mm-dd&#39; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;gt:yyyy-mm-dd&#39; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;gte:yyyy-mm-dd&#39; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;lt:yyyy-mm-dd&#39; (&lt;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;lte:yyyy-mm-dd&#39; (&lt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;                                    &lt;/ul&gt; (optional)
     * @param  string $created_at Filter that restricts the search result to accounts that were created according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;eq:yyyy-mm-dd&#39; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;gt:yyyy-mm-dd&#39; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;gte:yyyy-mm-dd&#39; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;lt:yyyy-mm-dd&#39; (&lt;)&lt;/li&gt;                                   &lt;li&gt;&#39;createdAt&#x3D;lte:yyyy-mm-dd&#39; (&lt;&#x3D;)&lt;/li&gt;                                   &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;          &lt;/ul&gt; (optional)
     * @param  string $company_name Filter that restricts the search result to accounts that have a company name according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;companyName&#x3D;like:expamle&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;companyName&#x3D;eq:example&#39; (&#x3D;)&lt;/li&gt;                                    &lt;/ul&gt; (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsGetWithHttpInfo($updated_at = null, $created_at = null, $company_name = null)
    {
        $request = $this->restAccountsGetRequest($updated_at, $created_at, $company_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsGetAsync
     *
     * List accounts
     *
     * @param  string $updated_at Filter that restricts the search result to accounts that were updated according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;eq:yyyy-mm-dd&#39; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;gt:yyyy-mm-dd&#39; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;gte:yyyy-mm-dd&#39; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;lt:yyyy-mm-dd&#39; (&lt;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;lte:yyyy-mm-dd&#39; (&lt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;                                    &lt;/ul&gt; (optional)
     * @param  string $created_at Filter that restricts the search result to accounts that were created according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;eq:yyyy-mm-dd&#39; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;gt:yyyy-mm-dd&#39; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;gte:yyyy-mm-dd&#39; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;lt:yyyy-mm-dd&#39; (&lt;)&lt;/li&gt;                                   &lt;li&gt;&#39;createdAt&#x3D;lte:yyyy-mm-dd&#39; (&lt;&#x3D;)&lt;/li&gt;                                   &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;          &lt;/ul&gt; (optional)
     * @param  string $company_name Filter that restricts the search result to accounts that have a company name according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;companyName&#x3D;like:expamle&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;companyName&#x3D;eq:example&#39; (&#x3D;)&lt;/li&gt;                                    &lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsGetAsync($updated_at = null, $created_at = null, $company_name = null)
    {
        return $this->restAccountsGetAsyncWithHttpInfo($updated_at, $created_at, $company_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsGetAsyncWithHttpInfo
     *
     * List accounts
     *
     * @param  string $updated_at Filter that restricts the search result to accounts that were updated according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;eq:yyyy-mm-dd&#39; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;gt:yyyy-mm-dd&#39; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;gte:yyyy-mm-dd&#39; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;lt:yyyy-mm-dd&#39; (&lt;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;lte:yyyy-mm-dd&#39; (&lt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;                                    &lt;/ul&gt; (optional)
     * @param  string $created_at Filter that restricts the search result to accounts that were created according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;eq:yyyy-mm-dd&#39; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;gt:yyyy-mm-dd&#39; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;gte:yyyy-mm-dd&#39; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;lt:yyyy-mm-dd&#39; (&lt;)&lt;/li&gt;                                   &lt;li&gt;&#39;createdAt&#x3D;lte:yyyy-mm-dd&#39; (&lt;&#x3D;)&lt;/li&gt;                                   &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;          &lt;/ul&gt; (optional)
     * @param  string $company_name Filter that restricts the search result to accounts that have a company name according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;companyName&#x3D;like:expamle&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;companyName&#x3D;eq:example&#39; (&#x3D;)&lt;/li&gt;                                    &lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsGetAsyncWithHttpInfo($updated_at = null, $created_at = null, $company_name = null)
    {
        $returnType = 'object';
        $request = $this->restAccountsGetRequest($updated_at, $created_at, $company_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsGet'
     *
     * @param  string $updated_at Filter that restricts the search result to accounts that were updated according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;eq:yyyy-mm-dd&#39; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;gt:yyyy-mm-dd&#39; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;gte:yyyy-mm-dd&#39; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;lt:yyyy-mm-dd&#39; (&lt;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;lte:yyyy-mm-dd&#39; (&lt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;                                    &lt;/ul&gt; (optional)
     * @param  string $created_at Filter that restricts the search result to accounts that were created according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;eq:yyyy-mm-dd&#39; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;gt:yyyy-mm-dd&#39; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;gte:yyyy-mm-dd&#39; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;lt:yyyy-mm-dd&#39; (&lt;)&lt;/li&gt;                                   &lt;li&gt;&#39;createdAt&#x3D;lte:yyyy-mm-dd&#39; (&lt;&#x3D;)&lt;/li&gt;                                   &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;          &lt;/ul&gt; (optional)
     * @param  string $company_name Filter that restricts the search result to accounts that have a company name according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;companyName&#x3D;like:expamle&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;companyName&#x3D;eq:example&#39; (&#x3D;)&lt;/li&gt;                                    &lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsGetRequest($updated_at = null, $created_at = null, $company_name = null)
    {

        $resourcePath = '/rest/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($updated_at)) {
            $updated_at = ObjectSerializer::serializeCollection($updated_at, '', true);
        }
        if ($updated_at !== null) {
            $queryParams['updatedAt'] = $updated_at;
        }
        // query params
        if (is_array($created_at)) {
            $created_at = ObjectSerializer::serializeCollection($created_at, '', true);
        }
        if ($created_at !== null) {
            $queryParams['createdAt'] = $created_at;
        }
        // query params
        if (is_array($company_name)) {
            $company_name = ObjectSerializer::serializeCollection($company_name, '', true);
        }
        if ($company_name !== null) {
            $queryParams['companyName'] = $company_name;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsPost
     *
     * Create account
     *
     * @param  \OpenAPI\Client\Model\InlineObject3 $_rest_accounts _rest_accounts (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Account
     */
    public function restAccountsPost($_rest_accounts = null)
    {
        list($response) = $this->restAccountsPostWithHttpInfo($_rest_accounts);
        return $response;
    }

    /**
     * Operation restAccountsPostWithHttpInfo
     *
     * Create account
     *
     * @param  \OpenAPI\Client\Model\InlineObject3 $_rest_accounts (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Account, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsPostWithHttpInfo($_rest_accounts = null)
    {
        $request = $this->restAccountsPostRequest($_rest_accounts);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Account' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Account', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Account';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Account',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsPostAsync
     *
     * Create account
     *
     * @param  \OpenAPI\Client\Model\InlineObject3 $_rest_accounts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsPostAsync($_rest_accounts = null)
    {
        return $this->restAccountsPostAsyncWithHttpInfo($_rest_accounts)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsPostAsyncWithHttpInfo
     *
     * Create account
     *
     * @param  \OpenAPI\Client\Model\InlineObject3 $_rest_accounts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsPostAsyncWithHttpInfo($_rest_accounts = null)
    {
        $returnType = '\OpenAPI\Client\Model\Account';
        $request = $this->restAccountsPostRequest($_rest_accounts);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsPost'
     *
     * @param  \OpenAPI\Client\Model\InlineObject3 $_rest_accounts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsPostRequest($_rest_accounts = null)
    {

        $resourcePath = '/rest/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_accounts)) {
            $_tempBody = $_rest_accounts;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersAddressesPost
     *
     * Create address for existing order
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AddressOrderRelation
     */
    public function restOrdersAddressesPost()
    {
        list($response) = $this->restOrdersAddressesPostWithHttpInfo();
        return $response;
    }

    /**
     * Operation restOrdersAddressesPostWithHttpInfo
     *
     * Create address for existing order
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AddressOrderRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersAddressesPostWithHttpInfo()
    {
        $request = $this->restOrdersAddressesPostRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AddressOrderRelation' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AddressOrderRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AddressOrderRelation';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AddressOrderRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersAddressesPostAsync
     *
     * Create address for existing order
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersAddressesPostAsync()
    {
        return $this->restOrdersAddressesPostAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersAddressesPostAsyncWithHttpInfo
     *
     * Create address for existing order
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersAddressesPostAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\AddressOrderRelation';
        $request = $this->restOrdersAddressesPostRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersAddressesPost'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersAddressesPostRequest()
    {

        $resourcePath = '/rest/orders/addresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restStockmanagementWarehousesAddressesPost
     *
     * Create address for existing warehouse
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AddressWarehouseRelation
     */
    public function restStockmanagementWarehousesAddressesPost()
    {
        list($response) = $this->restStockmanagementWarehousesAddressesPostWithHttpInfo();
        return $response;
    }

    /**
     * Operation restStockmanagementWarehousesAddressesPostWithHttpInfo
     *
     * Create address for existing warehouse
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AddressWarehouseRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restStockmanagementWarehousesAddressesPostWithHttpInfo()
    {
        $request = $this->restStockmanagementWarehousesAddressesPostRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AddressWarehouseRelation' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AddressWarehouseRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AddressWarehouseRelation';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AddressWarehouseRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restStockmanagementWarehousesAddressesPostAsync
     *
     * Create address for existing warehouse
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restStockmanagementWarehousesAddressesPostAsync()
    {
        return $this->restStockmanagementWarehousesAddressesPostAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restStockmanagementWarehousesAddressesPostAsyncWithHttpInfo
     *
     * Create address for existing warehouse
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restStockmanagementWarehousesAddressesPostAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\AddressWarehouseRelation';
        $request = $this->restStockmanagementWarehousesAddressesPostRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restStockmanagementWarehousesAddressesPost'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restStockmanagementWarehousesAddressesPostRequest()
    {

        $resourcePath = '/rest/stockmanagement/warehouses/addresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
