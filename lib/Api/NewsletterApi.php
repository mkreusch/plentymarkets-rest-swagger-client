<?php
/**
 * NewsletterApi
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0-beta2
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * NewsletterApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class NewsletterApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation restNewslettersDelete
     *
     * Delete entries
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Entry[]
     */
    public function restNewslettersDelete()
    {
        list($response) = $this->restNewslettersDeleteWithHttpInfo();
        return $response;
    }

    /**
     * Operation restNewslettersDeleteWithHttpInfo
     *
     * Delete entries
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Entry[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersDeleteWithHttpInfo()
    {
        $request = $this->restNewslettersDeleteRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Entry[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Entry[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Entry[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Entry[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersDeleteAsync
     *
     * Delete entries
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersDeleteAsync()
    {
        return $this->restNewslettersDeleteAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersDeleteAsyncWithHttpInfo
     *
     * Delete entries
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersDeleteAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\Entry[]';
        $request = $this->restNewslettersDeleteRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersDelete'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersDeleteRequest()
    {

        $resourcePath = '/rest/newsletters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersDoubleOptInContactIdPost
     *
     * Send doubleOptIn mail
     *
     * @param  int $contact_id The ID of the costumer contact (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restNewslettersDoubleOptInContactIdPost($contact_id)
    {
        list($response) = $this->restNewslettersDoubleOptInContactIdPostWithHttpInfo($contact_id);
        return $response;
    }

    /**
     * Operation restNewslettersDoubleOptInContactIdPostWithHttpInfo
     *
     * Send doubleOptIn mail
     *
     * @param  int $contact_id The ID of the costumer contact (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersDoubleOptInContactIdPostWithHttpInfo($contact_id)
    {
        $request = $this->restNewslettersDoubleOptInContactIdPostRequest($contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersDoubleOptInContactIdPostAsync
     *
     * Send doubleOptIn mail
     *
     * @param  int $contact_id The ID of the costumer contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersDoubleOptInContactIdPostAsync($contact_id)
    {
        return $this->restNewslettersDoubleOptInContactIdPostAsyncWithHttpInfo($contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersDoubleOptInContactIdPostAsyncWithHttpInfo
     *
     * Send doubleOptIn mail
     *
     * @param  int $contact_id The ID of the costumer contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersDoubleOptInContactIdPostAsyncWithHttpInfo($contact_id)
    {
        $returnType = 'object';
        $request = $this->restNewslettersDoubleOptInContactIdPostRequest($contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersDoubleOptInContactIdPost'
     *
     * @param  int $contact_id The ID of the costumer contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersDoubleOptInContactIdPostRequest($contact_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restNewslettersDoubleOptInContactIdPost'
            );
        }

        $resourcePath = '/rest/newsletters/double_opt_in/{contactId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersEntryIdDelete
     *
     * Delete entry
     *
     * @param  int $entry_id The ID of the newsletter entry (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Entry
     */
    public function restNewslettersEntryIdDelete($entry_id)
    {
        list($response) = $this->restNewslettersEntryIdDeleteWithHttpInfo($entry_id);
        return $response;
    }

    /**
     * Operation restNewslettersEntryIdDeleteWithHttpInfo
     *
     * Delete entry
     *
     * @param  int $entry_id The ID of the newsletter entry (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Entry, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersEntryIdDeleteWithHttpInfo($entry_id)
    {
        $request = $this->restNewslettersEntryIdDeleteRequest($entry_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Entry' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Entry', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Entry';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Entry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersEntryIdDeleteAsync
     *
     * Delete entry
     *
     * @param  int $entry_id The ID of the newsletter entry (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersEntryIdDeleteAsync($entry_id)
    {
        return $this->restNewslettersEntryIdDeleteAsyncWithHttpInfo($entry_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersEntryIdDeleteAsyncWithHttpInfo
     *
     * Delete entry
     *
     * @param  int $entry_id The ID of the newsletter entry (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersEntryIdDeleteAsyncWithHttpInfo($entry_id)
    {
        $returnType = '\OpenAPI\Client\Model\Entry';
        $request = $this->restNewslettersEntryIdDeleteRequest($entry_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersEntryIdDelete'
     *
     * @param  int $entry_id The ID of the newsletter entry (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersEntryIdDeleteRequest($entry_id)
    {
        // verify the required parameter 'entry_id' is set
        if ($entry_id === null || (is_array($entry_id) && count($entry_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entry_id when calling restNewslettersEntryIdDelete'
            );
        }

        $resourcePath = '/rest/newsletters/{entryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($entry_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entryId' . '}',
                ObjectSerializer::toPathValue($entry_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersEntryIdGet
     *
     * List details of an entry
     *
     * @param  int $entry_id The ID of the newsletter entry. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Entry
     */
    public function restNewslettersEntryIdGet($entry_id)
    {
        list($response) = $this->restNewslettersEntryIdGetWithHttpInfo($entry_id);
        return $response;
    }

    /**
     * Operation restNewslettersEntryIdGetWithHttpInfo
     *
     * List details of an entry
     *
     * @param  int $entry_id The ID of the newsletter entry. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Entry, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersEntryIdGetWithHttpInfo($entry_id)
    {
        $request = $this->restNewslettersEntryIdGetRequest($entry_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Entry' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Entry', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Entry';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Entry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersEntryIdGetAsync
     *
     * List details of an entry
     *
     * @param  int $entry_id The ID of the newsletter entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersEntryIdGetAsync($entry_id)
    {
        return $this->restNewslettersEntryIdGetAsyncWithHttpInfo($entry_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersEntryIdGetAsyncWithHttpInfo
     *
     * List details of an entry
     *
     * @param  int $entry_id The ID of the newsletter entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersEntryIdGetAsyncWithHttpInfo($entry_id)
    {
        $returnType = '\OpenAPI\Client\Model\Entry';
        $request = $this->restNewslettersEntryIdGetRequest($entry_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersEntryIdGet'
     *
     * @param  int $entry_id The ID of the newsletter entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersEntryIdGetRequest($entry_id)
    {
        // verify the required parameter 'entry_id' is set
        if ($entry_id === null || (is_array($entry_id) && count($entry_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entry_id when calling restNewslettersEntryIdGet'
            );
        }

        $resourcePath = '/rest/newsletters/{entryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($entry_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entryId' . '}',
                ObjectSerializer::toPathValue($entry_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersEntryIdPut
     *
     * Update entry
     *
     * @param  int $entry_id The ID of the entry (required)
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string $subject The subject of the entry (optional)
     * @param  string $body The body of the entry (optional)
     * @param  string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#39;plain&#39;, &#39;html&#39;]. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Entry
     */
    public function restNewslettersEntryIdPut($entry_id, $folder_id, $subject = null, $body = null, $kind = null)
    {
        list($response) = $this->restNewslettersEntryIdPutWithHttpInfo($entry_id, $folder_id, $subject, $body, $kind);
        return $response;
    }

    /**
     * Operation restNewslettersEntryIdPutWithHttpInfo
     *
     * Update entry
     *
     * @param  int $entry_id The ID of the entry (required)
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string $subject The subject of the entry (optional)
     * @param  string $body The body of the entry (optional)
     * @param  string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#39;plain&#39;, &#39;html&#39;]. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Entry, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersEntryIdPutWithHttpInfo($entry_id, $folder_id, $subject = null, $body = null, $kind = null)
    {
        $request = $this->restNewslettersEntryIdPutRequest($entry_id, $folder_id, $subject, $body, $kind);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Entry' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Entry', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Entry';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Entry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersEntryIdPutAsync
     *
     * Update entry
     *
     * @param  int $entry_id The ID of the entry (required)
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string $subject The subject of the entry (optional)
     * @param  string $body The body of the entry (optional)
     * @param  string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#39;plain&#39;, &#39;html&#39;]. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersEntryIdPutAsync($entry_id, $folder_id, $subject = null, $body = null, $kind = null)
    {
        return $this->restNewslettersEntryIdPutAsyncWithHttpInfo($entry_id, $folder_id, $subject, $body, $kind)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersEntryIdPutAsyncWithHttpInfo
     *
     * Update entry
     *
     * @param  int $entry_id The ID of the entry (required)
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string $subject The subject of the entry (optional)
     * @param  string $body The body of the entry (optional)
     * @param  string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#39;plain&#39;, &#39;html&#39;]. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersEntryIdPutAsyncWithHttpInfo($entry_id, $folder_id, $subject = null, $body = null, $kind = null)
    {
        $returnType = '\OpenAPI\Client\Model\Entry';
        $request = $this->restNewslettersEntryIdPutRequest($entry_id, $folder_id, $subject, $body, $kind);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersEntryIdPut'
     *
     * @param  int $entry_id The ID of the entry (required)
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string $subject The subject of the entry (optional)
     * @param  string $body The body of the entry (optional)
     * @param  string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#39;plain&#39;, &#39;html&#39;]. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersEntryIdPutRequest($entry_id, $folder_id, $subject = null, $body = null, $kind = null)
    {
        // verify the required parameter 'entry_id' is set
        if ($entry_id === null || (is_array($entry_id) && count($entry_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entry_id when calling restNewslettersEntryIdPut'
            );
        }
        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling restNewslettersEntryIdPut'
            );
        }

        $resourcePath = '/rest/newsletters/{entryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($subject)) {
            $subject = ObjectSerializer::serializeCollection($subject, '', true);
        }
        if ($subject !== null) {
            $queryParams['subject'] = $subject;
        }
        // query params
        if (is_array($body)) {
            $body = ObjectSerializer::serializeCollection($body, '', true);
        }
        if ($body !== null) {
            $queryParams['body'] = $body;
        }
        // query params
        if (is_array($kind)) {
            $kind = ObjectSerializer::serializeCollection($kind, '', true);
        }
        if ($kind !== null) {
            $queryParams['kind'] = $kind;
        }
        // query params
        if (is_array($folder_id)) {
            $folder_id = ObjectSerializer::serializeCollection($folder_id, '', true);
        }
        if ($folder_id !== null) {
            $queryParams['folderId'] = $folder_id;
        }


        // path params
        if ($entry_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entryId' . '}',
                ObjectSerializer::toPathValue($entry_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersDelete
     *
     * Delete folders
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Folder[]
     */
    public function restNewslettersFoldersDelete()
    {
        list($response) = $this->restNewslettersFoldersDeleteWithHttpInfo();
        return $response;
    }

    /**
     * Operation restNewslettersFoldersDeleteWithHttpInfo
     *
     * Delete folders
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Folder[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersFoldersDeleteWithHttpInfo()
    {
        $request = $this->restNewslettersFoldersDeleteRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Folder[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Folder[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Folder[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Folder[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersDeleteAsync
     *
     * Delete folders
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersDeleteAsync()
    {
        return $this->restNewslettersFoldersDeleteAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersDeleteAsyncWithHttpInfo
     *
     * Delete folders
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersDeleteAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\Folder[]';
        $request = $this->restNewslettersFoldersDeleteRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersDelete'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersFoldersDeleteRequest()
    {

        $resourcePath = '/rest/newsletters/folders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersFolderIdDelete
     *
     * Delete folder
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Folder
     */
    public function restNewslettersFoldersFolderIdDelete($folder_id)
    {
        list($response) = $this->restNewslettersFoldersFolderIdDeleteWithHttpInfo($folder_id);
        return $response;
    }

    /**
     * Operation restNewslettersFoldersFolderIdDeleteWithHttpInfo
     *
     * Delete folder
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Folder, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersFoldersFolderIdDeleteWithHttpInfo($folder_id)
    {
        $request = $this->restNewslettersFoldersFolderIdDeleteRequest($folder_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Folder' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Folder', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Folder';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Folder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersFolderIdDeleteAsync
     *
     * Delete folder
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersFolderIdDeleteAsync($folder_id)
    {
        return $this->restNewslettersFoldersFolderIdDeleteAsyncWithHttpInfo($folder_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersFolderIdDeleteAsyncWithHttpInfo
     *
     * Delete folder
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersFolderIdDeleteAsyncWithHttpInfo($folder_id)
    {
        $returnType = '\OpenAPI\Client\Model\Folder';
        $request = $this->restNewslettersFoldersFolderIdDeleteRequest($folder_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersFolderIdDelete'
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersFoldersFolderIdDeleteRequest($folder_id)
    {
        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling restNewslettersFoldersFolderIdDelete'
            );
        }

        $resourcePath = '/rest/newsletters/folders/{folderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersFolderIdGet
     *
     * List details of a folder
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Folder
     */
    public function restNewslettersFoldersFolderIdGet($folder_id)
    {
        list($response) = $this->restNewslettersFoldersFolderIdGetWithHttpInfo($folder_id);
        return $response;
    }

    /**
     * Operation restNewslettersFoldersFolderIdGetWithHttpInfo
     *
     * List details of a folder
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Folder, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersFoldersFolderIdGetWithHttpInfo($folder_id)
    {
        $request = $this->restNewslettersFoldersFolderIdGetRequest($folder_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Folder' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Folder', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Folder';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Folder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersFolderIdGetAsync
     *
     * List details of a folder
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersFolderIdGetAsync($folder_id)
    {
        return $this->restNewslettersFoldersFolderIdGetAsyncWithHttpInfo($folder_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersFolderIdGetAsyncWithHttpInfo
     *
     * List details of a folder
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersFolderIdGetAsyncWithHttpInfo($folder_id)
    {
        $returnType = '\OpenAPI\Client\Model\Folder';
        $request = $this->restNewslettersFoldersFolderIdGetRequest($folder_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersFolderIdGet'
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersFoldersFolderIdGetRequest($folder_id)
    {
        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling restNewslettersFoldersFolderIdGet'
            );
        }

        $resourcePath = '/rest/newsletters/folders/{folderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersFolderIdPut
     *
     * Update folder
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string $name The name of the newsletter folder (optional)
     * @param  int $position The position of the newsletter folder (optional)
     * @param  int $client_ids The IDs of the clients (stores). It is possible to determine which clients (stores) the newsletter folder is visible for. (optional)
     * @param  bool $is_deletable Flag that indicates if the newsletter folder can be deleted. The folders &#39;Customers&#39; and &#39;Interested parties&#39; are available by default and cannot be deleted. (optional)
     * @param  bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Folder
     */
    public function restNewslettersFoldersFolderIdPut($folder_id, $name = null, $position = null, $client_ids = null, $is_deletable = null, $is_selectable = null)
    {
        list($response) = $this->restNewslettersFoldersFolderIdPutWithHttpInfo($folder_id, $name, $position, $client_ids, $is_deletable, $is_selectable);
        return $response;
    }

    /**
     * Operation restNewslettersFoldersFolderIdPutWithHttpInfo
     *
     * Update folder
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string $name The name of the newsletter folder (optional)
     * @param  int $position The position of the newsletter folder (optional)
     * @param  int $client_ids The IDs of the clients (stores). It is possible to determine which clients (stores) the newsletter folder is visible for. (optional)
     * @param  bool $is_deletable Flag that indicates if the newsletter folder can be deleted. The folders &#39;Customers&#39; and &#39;Interested parties&#39; are available by default and cannot be deleted. (optional)
     * @param  bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Folder, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersFoldersFolderIdPutWithHttpInfo($folder_id, $name = null, $position = null, $client_ids = null, $is_deletable = null, $is_selectable = null)
    {
        $request = $this->restNewslettersFoldersFolderIdPutRequest($folder_id, $name, $position, $client_ids, $is_deletable, $is_selectable);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Folder' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Folder', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Folder';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Folder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersFolderIdPutAsync
     *
     * Update folder
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string $name The name of the newsletter folder (optional)
     * @param  int $position The position of the newsletter folder (optional)
     * @param  int $client_ids The IDs of the clients (stores). It is possible to determine which clients (stores) the newsletter folder is visible for. (optional)
     * @param  bool $is_deletable Flag that indicates if the newsletter folder can be deleted. The folders &#39;Customers&#39; and &#39;Interested parties&#39; are available by default and cannot be deleted. (optional)
     * @param  bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersFolderIdPutAsync($folder_id, $name = null, $position = null, $client_ids = null, $is_deletable = null, $is_selectable = null)
    {
        return $this->restNewslettersFoldersFolderIdPutAsyncWithHttpInfo($folder_id, $name, $position, $client_ids, $is_deletable, $is_selectable)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersFolderIdPutAsyncWithHttpInfo
     *
     * Update folder
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string $name The name of the newsletter folder (optional)
     * @param  int $position The position of the newsletter folder (optional)
     * @param  int $client_ids The IDs of the clients (stores). It is possible to determine which clients (stores) the newsletter folder is visible for. (optional)
     * @param  bool $is_deletable Flag that indicates if the newsletter folder can be deleted. The folders &#39;Customers&#39; and &#39;Interested parties&#39; are available by default and cannot be deleted. (optional)
     * @param  bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersFolderIdPutAsyncWithHttpInfo($folder_id, $name = null, $position = null, $client_ids = null, $is_deletable = null, $is_selectable = null)
    {
        $returnType = '\OpenAPI\Client\Model\Folder';
        $request = $this->restNewslettersFoldersFolderIdPutRequest($folder_id, $name, $position, $client_ids, $is_deletable, $is_selectable);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersFolderIdPut'
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string $name The name of the newsletter folder (optional)
     * @param  int $position The position of the newsletter folder (optional)
     * @param  int $client_ids The IDs of the clients (stores). It is possible to determine which clients (stores) the newsletter folder is visible for. (optional)
     * @param  bool $is_deletable Flag that indicates if the newsletter folder can be deleted. The folders &#39;Customers&#39; and &#39;Interested parties&#39; are available by default and cannot be deleted. (optional)
     * @param  bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersFoldersFolderIdPutRequest($folder_id, $name = null, $position = null, $client_ids = null, $is_deletable = null, $is_selectable = null)
    {
        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling restNewslettersFoldersFolderIdPut'
            );
        }

        $resourcePath = '/rest/newsletters/folders/{folderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($position)) {
            $position = ObjectSerializer::serializeCollection($position, '', true);
        }
        if ($position !== null) {
            $queryParams['position'] = $position;
        }
        // query params
        if (is_array($client_ids)) {
            $client_ids = ObjectSerializer::serializeCollection($client_ids, '', true);
        }
        if ($client_ids !== null) {
            $queryParams['clientIds'] = $client_ids;
        }
        // query params
        if (is_array($is_deletable)) {
            $is_deletable = ObjectSerializer::serializeCollection($is_deletable, '', true);
        }
        if ($is_deletable !== null) {
            $queryParams['isDeletable'] = $is_deletable;
        }
        // query params
        if (is_array($is_selectable)) {
            $is_selectable = ObjectSerializer::serializeCollection($is_selectable, '', true);
        }
        if ($is_selectable !== null) {
            $queryParams['isSelectable'] = $is_selectable;
        }


        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersFolderIdRecipientsGet
     *
     * List all recipients of a folder
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Recipient[]
     */
    public function restNewslettersFoldersFolderIdRecipientsGet($folder_id)
    {
        list($response) = $this->restNewslettersFoldersFolderIdRecipientsGetWithHttpInfo($folder_id);
        return $response;
    }

    /**
     * Operation restNewslettersFoldersFolderIdRecipientsGetWithHttpInfo
     *
     * List all recipients of a folder
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Recipient[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersFoldersFolderIdRecipientsGetWithHttpInfo($folder_id)
    {
        $request = $this->restNewslettersFoldersFolderIdRecipientsGetRequest($folder_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Recipient[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Recipient[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Recipient[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Recipient[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersFolderIdRecipientsGetAsync
     *
     * List all recipients of a folder
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersFolderIdRecipientsGetAsync($folder_id)
    {
        return $this->restNewslettersFoldersFolderIdRecipientsGetAsyncWithHttpInfo($folder_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersFolderIdRecipientsGetAsyncWithHttpInfo
     *
     * List all recipients of a folder
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersFolderIdRecipientsGetAsyncWithHttpInfo($folder_id)
    {
        $returnType = '\OpenAPI\Client\Model\Recipient[]';
        $request = $this->restNewslettersFoldersFolderIdRecipientsGetRequest($folder_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersFolderIdRecipientsGet'
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersFoldersFolderIdRecipientsGetRequest($folder_id)
    {
        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling restNewslettersFoldersFolderIdRecipientsGet'
            );
        }

        $resourcePath = '/rest/newsletters/folders/{folderId}/recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersGet
     *
     * List newsletter folders
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Recipient[]
     */
    public function restNewslettersFoldersGet($folder_id)
    {
        list($response) = $this->restNewslettersFoldersGetWithHttpInfo($folder_id);
        return $response;
    }

    /**
     * Operation restNewslettersFoldersGetWithHttpInfo
     *
     * List newsletter folders
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Recipient[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersFoldersGetWithHttpInfo($folder_id)
    {
        $request = $this->restNewslettersFoldersGetRequest($folder_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Recipient[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Recipient[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Recipient[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Recipient[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersGetAsync
     *
     * List newsletter folders
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersGetAsync($folder_id)
    {
        return $this->restNewslettersFoldersGetAsyncWithHttpInfo($folder_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersGetAsyncWithHttpInfo
     *
     * List newsletter folders
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersGetAsyncWithHttpInfo($folder_id)
    {
        $returnType = '\OpenAPI\Client\Model\Recipient[]';
        $request = $this->restNewslettersFoldersGetRequest($folder_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersGet'
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersFoldersGetRequest($folder_id)
    {
        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling restNewslettersFoldersGet'
            );
        }

        $resourcePath = '/rest/newsletters/folders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($folder_id)) {
            $folder_id = ObjectSerializer::serializeCollection($folder_id, '', true);
        }
        if ($folder_id !== null) {
            $queryParams['folderId'] = $folder_id;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersPost
     *
     * Create folder
     *
     * @param  int $id The ID of the newsletter folder (optional)
     * @param  string $name The name of the newsletter folder (optional)
     * @param  int $position The position of the newsletter folder (optional)
     * @param  bool $is_deletable Flag that indicates if the newsletter folder can be deleted. Default value of is deletable is 1. The folders &#39;Customers&#39; and &#39;Interested parties&#39; are available by default and cannot be deleted. (optional)
     * @param  bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject165 $_rest_newsletters_folders _rest_newsletters_folders (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Folder
     */
    public function restNewslettersFoldersPost($id = null, $name = null, $position = null, $is_deletable = null, $is_selectable = null, $_rest_newsletters_folders = null)
    {
        list($response) = $this->restNewslettersFoldersPostWithHttpInfo($id, $name, $position, $is_deletable, $is_selectable, $_rest_newsletters_folders);
        return $response;
    }

    /**
     * Operation restNewslettersFoldersPostWithHttpInfo
     *
     * Create folder
     *
     * @param  int $id The ID of the newsletter folder (optional)
     * @param  string $name The name of the newsletter folder (optional)
     * @param  int $position The position of the newsletter folder (optional)
     * @param  bool $is_deletable Flag that indicates if the newsletter folder can be deleted. Default value of is deletable is 1. The folders &#39;Customers&#39; and &#39;Interested parties&#39; are available by default and cannot be deleted. (optional)
     * @param  bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject165 $_rest_newsletters_folders (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Folder, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersFoldersPostWithHttpInfo($id = null, $name = null, $position = null, $is_deletable = null, $is_selectable = null, $_rest_newsletters_folders = null)
    {
        $request = $this->restNewslettersFoldersPostRequest($id, $name, $position, $is_deletable, $is_selectable, $_rest_newsletters_folders);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Folder' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Folder', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Folder';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Folder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersPostAsync
     *
     * Create folder
     *
     * @param  int $id The ID of the newsletter folder (optional)
     * @param  string $name The name of the newsletter folder (optional)
     * @param  int $position The position of the newsletter folder (optional)
     * @param  bool $is_deletable Flag that indicates if the newsletter folder can be deleted. Default value of is deletable is 1. The folders &#39;Customers&#39; and &#39;Interested parties&#39; are available by default and cannot be deleted. (optional)
     * @param  bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject165 $_rest_newsletters_folders (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersPostAsync($id = null, $name = null, $position = null, $is_deletable = null, $is_selectable = null, $_rest_newsletters_folders = null)
    {
        return $this->restNewslettersFoldersPostAsyncWithHttpInfo($id, $name, $position, $is_deletable, $is_selectable, $_rest_newsletters_folders)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersPostAsyncWithHttpInfo
     *
     * Create folder
     *
     * @param  int $id The ID of the newsletter folder (optional)
     * @param  string $name The name of the newsletter folder (optional)
     * @param  int $position The position of the newsletter folder (optional)
     * @param  bool $is_deletable Flag that indicates if the newsletter folder can be deleted. Default value of is deletable is 1. The folders &#39;Customers&#39; and &#39;Interested parties&#39; are available by default and cannot be deleted. (optional)
     * @param  bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject165 $_rest_newsletters_folders (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersPostAsyncWithHttpInfo($id = null, $name = null, $position = null, $is_deletable = null, $is_selectable = null, $_rest_newsletters_folders = null)
    {
        $returnType = '\OpenAPI\Client\Model\Folder';
        $request = $this->restNewslettersFoldersPostRequest($id, $name, $position, $is_deletable, $is_selectable, $_rest_newsletters_folders);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersPost'
     *
     * @param  int $id The ID of the newsletter folder (optional)
     * @param  string $name The name of the newsletter folder (optional)
     * @param  int $position The position of the newsletter folder (optional)
     * @param  bool $is_deletable Flag that indicates if the newsletter folder can be deleted. Default value of is deletable is 1. The folders &#39;Customers&#39; and &#39;Interested parties&#39; are available by default and cannot be deleted. (optional)
     * @param  bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject165 $_rest_newsletters_folders (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersFoldersPostRequest($id = null, $name = null, $position = null, $is_deletable = null, $is_selectable = null, $_rest_newsletters_folders = null)
    {

        $resourcePath = '/rest/newsletters/folders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($id)) {
            $id = ObjectSerializer::serializeCollection($id, '', true);
        }
        if ($id !== null) {
            $queryParams['id'] = $id;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($position)) {
            $position = ObjectSerializer::serializeCollection($position, '', true);
        }
        if ($position !== null) {
            $queryParams['position'] = $position;
        }
        // query params
        if (is_array($is_deletable)) {
            $is_deletable = ObjectSerializer::serializeCollection($is_deletable, '', true);
        }
        if ($is_deletable !== null) {
            $queryParams['isDeletable'] = $is_deletable;
        }
        // query params
        if (is_array($is_selectable)) {
            $is_selectable = ObjectSerializer::serializeCollection($is_selectable, '', true);
        }
        if ($is_selectable !== null) {
            $queryParams['isSelectable'] = $is_selectable;
        }



        // body params
        $_tempBody = null;
        if (isset($_rest_newsletters_folders)) {
            $_tempBody = $_rest_newsletters_folders;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersGet
     *
     * List newsletter entries
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Entry[]
     */
    public function restNewslettersGet()
    {
        list($response) = $this->restNewslettersGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restNewslettersGetWithHttpInfo
     *
     * List newsletter entries
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Entry[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersGetWithHttpInfo()
    {
        $request = $this->restNewslettersGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Entry[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Entry[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Entry[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Entry[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersGetAsync
     *
     * List newsletter entries
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersGetAsync()
    {
        return $this->restNewslettersGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersGetAsyncWithHttpInfo
     *
     * List newsletter entries
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersGetAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\Entry[]';
        $request = $this->restNewslettersGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersGetRequest()
    {

        $resourcePath = '/rest/newsletters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersListRecipientsGet
     *
     * List recipients
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  int $columns Filter that restricts the search result to specific columns (optional)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int $folder_id Filter that restricts the search result to a specific folderId. (optional)
     * @param  bool $is_confirmed Filter that restricts the search result to confirmed recipients. (optional)
     * @param  int $with Load additional relations for a Recipient. CURRENTLY NOT AVAILABLE (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse2005
     */
    public function restNewslettersListRecipientsGet($recipient_id, $columns = null, $page = null, $items_per_page = null, $folder_id = null, $is_confirmed = null, $with = null)
    {
        list($response) = $this->restNewslettersListRecipientsGetWithHttpInfo($recipient_id, $columns, $page, $items_per_page, $folder_id, $is_confirmed, $with);
        return $response;
    }

    /**
     * Operation restNewslettersListRecipientsGetWithHttpInfo
     *
     * List recipients
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  int $columns Filter that restricts the search result to specific columns (optional)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int $folder_id Filter that restricts the search result to a specific folderId. (optional)
     * @param  bool $is_confirmed Filter that restricts the search result to confirmed recipients. (optional)
     * @param  int $with Load additional relations for a Recipient. CURRENTLY NOT AVAILABLE (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse2005, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersListRecipientsGetWithHttpInfo($recipient_id, $columns = null, $page = null, $items_per_page = null, $folder_id = null, $is_confirmed = null, $with = null)
    {
        $request = $this->restNewslettersListRecipientsGetRequest($recipient_id, $columns, $page, $items_per_page, $folder_id, $is_confirmed, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse2005' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse2005', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse2005';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse2005',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersListRecipientsGetAsync
     *
     * List recipients
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  int $columns Filter that restricts the search result to specific columns (optional)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int $folder_id Filter that restricts the search result to a specific folderId. (optional)
     * @param  bool $is_confirmed Filter that restricts the search result to confirmed recipients. (optional)
     * @param  int $with Load additional relations for a Recipient. CURRENTLY NOT AVAILABLE (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersListRecipientsGetAsync($recipient_id, $columns = null, $page = null, $items_per_page = null, $folder_id = null, $is_confirmed = null, $with = null)
    {
        return $this->restNewslettersListRecipientsGetAsyncWithHttpInfo($recipient_id, $columns, $page, $items_per_page, $folder_id, $is_confirmed, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersListRecipientsGetAsyncWithHttpInfo
     *
     * List recipients
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  int $columns Filter that restricts the search result to specific columns (optional)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int $folder_id Filter that restricts the search result to a specific folderId. (optional)
     * @param  bool $is_confirmed Filter that restricts the search result to confirmed recipients. (optional)
     * @param  int $with Load additional relations for a Recipient. CURRENTLY NOT AVAILABLE (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersListRecipientsGetAsyncWithHttpInfo($recipient_id, $columns = null, $page = null, $items_per_page = null, $folder_id = null, $is_confirmed = null, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse2005';
        $request = $this->restNewslettersListRecipientsGetRequest($recipient_id, $columns, $page, $items_per_page, $folder_id, $is_confirmed, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersListRecipientsGet'
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  int $columns Filter that restricts the search result to specific columns (optional)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int $folder_id Filter that restricts the search result to a specific folderId. (optional)
     * @param  bool $is_confirmed Filter that restricts the search result to confirmed recipients. (optional)
     * @param  int $with Load additional relations for a Recipient. CURRENTLY NOT AVAILABLE (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersListRecipientsGetRequest($recipient_id, $columns = null, $page = null, $items_per_page = null, $folder_id = null, $is_confirmed = null, $with = null)
    {
        // verify the required parameter 'recipient_id' is set
        if ($recipient_id === null || (is_array($recipient_id) && count($recipient_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recipient_id when calling restNewslettersListRecipientsGet'
            );
        }

        $resourcePath = '/rest/newsletters/list_recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($columns)) {
            $columns = ObjectSerializer::serializeCollection($columns, '', true);
        }
        if ($columns !== null) {
            $queryParams['columns'] = $columns;
        }
        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }
        // query params
        if (is_array($folder_id)) {
            $folder_id = ObjectSerializer::serializeCollection($folder_id, '', true);
        }
        if ($folder_id !== null) {
            $queryParams['folderId'] = $folder_id;
        }
        // query params
        if (is_array($is_confirmed)) {
            $is_confirmed = ObjectSerializer::serializeCollection($is_confirmed, '', true);
        }
        if ($is_confirmed !== null) {
            $queryParams['isConfirmed'] = $is_confirmed;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }
        // query params
        if (is_array($recipient_id)) {
            $recipient_id = ObjectSerializer::serializeCollection($recipient_id, '', true);
        }
        if ($recipient_id !== null) {
            $queryParams['recipientId'] = $recipient_id;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersPost
     *
     * Create entry
     *
     * @param  string $subject The subject of the newsletter entry (optional)
     * @param  string $body The body of the newsletter entry (optional)
     * @param  string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#39;plain&#39;, &#39;html&#39;]. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject164 $_rest_newsletters _rest_newsletters (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Entry
     */
    public function restNewslettersPost($subject = null, $body = null, $kind = null, $_rest_newsletters = null)
    {
        list($response) = $this->restNewslettersPostWithHttpInfo($subject, $body, $kind, $_rest_newsletters);
        return $response;
    }

    /**
     * Operation restNewslettersPostWithHttpInfo
     *
     * Create entry
     *
     * @param  string $subject The subject of the newsletter entry (optional)
     * @param  string $body The body of the newsletter entry (optional)
     * @param  string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#39;plain&#39;, &#39;html&#39;]. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject164 $_rest_newsletters (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Entry, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersPostWithHttpInfo($subject = null, $body = null, $kind = null, $_rest_newsletters = null)
    {
        $request = $this->restNewslettersPostRequest($subject, $body, $kind, $_rest_newsletters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Entry' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Entry', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Entry';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Entry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersPostAsync
     *
     * Create entry
     *
     * @param  string $subject The subject of the newsletter entry (optional)
     * @param  string $body The body of the newsletter entry (optional)
     * @param  string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#39;plain&#39;, &#39;html&#39;]. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject164 $_rest_newsletters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersPostAsync($subject = null, $body = null, $kind = null, $_rest_newsletters = null)
    {
        return $this->restNewslettersPostAsyncWithHttpInfo($subject, $body, $kind, $_rest_newsletters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersPostAsyncWithHttpInfo
     *
     * Create entry
     *
     * @param  string $subject The subject of the newsletter entry (optional)
     * @param  string $body The body of the newsletter entry (optional)
     * @param  string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#39;plain&#39;, &#39;html&#39;]. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject164 $_rest_newsletters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersPostAsyncWithHttpInfo($subject = null, $body = null, $kind = null, $_rest_newsletters = null)
    {
        $returnType = '\OpenAPI\Client\Model\Entry';
        $request = $this->restNewslettersPostRequest($subject, $body, $kind, $_rest_newsletters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersPost'
     *
     * @param  string $subject The subject of the newsletter entry (optional)
     * @param  string $body The body of the newsletter entry (optional)
     * @param  string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#39;plain&#39;, &#39;html&#39;]. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject164 $_rest_newsletters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersPostRequest($subject = null, $body = null, $kind = null, $_rest_newsletters = null)
    {

        $resourcePath = '/rest/newsletters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($subject)) {
            $subject = ObjectSerializer::serializeCollection($subject, '', true);
        }
        if ($subject !== null) {
            $queryParams['subject'] = $subject;
        }
        // query params
        if (is_array($body)) {
            $body = ObjectSerializer::serializeCollection($body, '', true);
        }
        if ($body !== null) {
            $queryParams['body'] = $body;
        }
        // query params
        if (is_array($kind)) {
            $kind = ObjectSerializer::serializeCollection($kind, '', true);
        }
        if ($kind !== null) {
            $queryParams['kind'] = $kind;
        }



        // body params
        $_tempBody = null;
        if (isset($_rest_newsletters)) {
            $_tempBody = $_rest_newsletters;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersRecipientsDelete
     *
     * Delete recipients
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Recipient[]
     */
    public function restNewslettersRecipientsDelete()
    {
        list($response) = $this->restNewslettersRecipientsDeleteWithHttpInfo();
        return $response;
    }

    /**
     * Operation restNewslettersRecipientsDeleteWithHttpInfo
     *
     * Delete recipients
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Recipient[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersRecipientsDeleteWithHttpInfo()
    {
        $request = $this->restNewslettersRecipientsDeleteRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Recipient[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Recipient[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Recipient[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Recipient[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersRecipientsDeleteAsync
     *
     * Delete recipients
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersRecipientsDeleteAsync()
    {
        return $this->restNewslettersRecipientsDeleteAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersRecipientsDeleteAsyncWithHttpInfo
     *
     * Delete recipients
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersRecipientsDeleteAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\Recipient[]';
        $request = $this->restNewslettersRecipientsDeleteRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersRecipientsDelete'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersRecipientsDeleteRequest()
    {

        $resourcePath = '/rest/newsletters/recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersRecipientsGet
     *
     * List recipients of folder
     *
     * @param  string $email Filter that restricts the search result to the email address of the recipient (optional)
     * @param  int $folder_id Filter that restricts the search result to the folder ID (optional)
     * @param  int $recipient_id Filter that restricts the search result to the recipient ID (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Recipient[]
     */
    public function restNewslettersRecipientsGet($email = null, $folder_id = null, $recipient_id = null)
    {
        list($response) = $this->restNewslettersRecipientsGetWithHttpInfo($email, $folder_id, $recipient_id);
        return $response;
    }

    /**
     * Operation restNewslettersRecipientsGetWithHttpInfo
     *
     * List recipients of folder
     *
     * @param  string $email Filter that restricts the search result to the email address of the recipient (optional)
     * @param  int $folder_id Filter that restricts the search result to the folder ID (optional)
     * @param  int $recipient_id Filter that restricts the search result to the recipient ID (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Recipient[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersRecipientsGetWithHttpInfo($email = null, $folder_id = null, $recipient_id = null)
    {
        $request = $this->restNewslettersRecipientsGetRequest($email, $folder_id, $recipient_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Recipient[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Recipient[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Recipient[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Recipient[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersRecipientsGetAsync
     *
     * List recipients of folder
     *
     * @param  string $email Filter that restricts the search result to the email address of the recipient (optional)
     * @param  int $folder_id Filter that restricts the search result to the folder ID (optional)
     * @param  int $recipient_id Filter that restricts the search result to the recipient ID (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersRecipientsGetAsync($email = null, $folder_id = null, $recipient_id = null)
    {
        return $this->restNewslettersRecipientsGetAsyncWithHttpInfo($email, $folder_id, $recipient_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersRecipientsGetAsyncWithHttpInfo
     *
     * List recipients of folder
     *
     * @param  string $email Filter that restricts the search result to the email address of the recipient (optional)
     * @param  int $folder_id Filter that restricts the search result to the folder ID (optional)
     * @param  int $recipient_id Filter that restricts the search result to the recipient ID (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersRecipientsGetAsyncWithHttpInfo($email = null, $folder_id = null, $recipient_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\Recipient[]';
        $request = $this->restNewslettersRecipientsGetRequest($email, $folder_id, $recipient_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersRecipientsGet'
     *
     * @param  string $email Filter that restricts the search result to the email address of the recipient (optional)
     * @param  int $folder_id Filter that restricts the search result to the folder ID (optional)
     * @param  int $recipient_id Filter that restricts the search result to the recipient ID (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersRecipientsGetRequest($email = null, $folder_id = null, $recipient_id = null)
    {

        $resourcePath = '/rest/newsletters/recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($email)) {
            $email = ObjectSerializer::serializeCollection($email, '', true);
        }
        if ($email !== null) {
            $queryParams['email'] = $email;
        }
        // query params
        if (is_array($folder_id)) {
            $folder_id = ObjectSerializer::serializeCollection($folder_id, '', true);
        }
        if ($folder_id !== null) {
            $queryParams['folderId'] = $folder_id;
        }
        // query params
        if (is_array($recipient_id)) {
            $recipient_id = ObjectSerializer::serializeCollection($recipient_id, '', true);
        }
        if ($recipient_id !== null) {
            $queryParams['recipientId'] = $recipient_id;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersRecipientsPost
     *
     * Create recipient
     *
     * @param  string $email The email address of the recipient (optional)
     * @param  string $first_name The first name of the recipient (optional)
     * @param  string $last_name The last name of the recipient (optional)
     * @param  int $folder_ids The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  bool $is_frontend Value that indicates if the REST call was retrieved from the front end. Possible values are: &#39;true&#39; or &#39;false&#39;. True &#x3D; The REST call was retrieved from the front end. False &#x3D; The REST call was not retrieved from the front end. (optional)
     * @param  bool $ignore_visibility Value that indicates if the REST call considers folders without visibility. Possible value: &#39;true&#39;. If the value &#39;true&#39; is set, the folder visibility will be ignored. This means that both visible and invisible folders will be listed depending on the folder IDs entered in the REST call. (optional)
     * @param  string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  \OpenAPI\Client\Model\InlineObject166 $_rest_newsletters_recipients _rest_newsletters_recipients (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Recipient[]
     */
    public function restNewslettersRecipientsPost($email = null, $first_name = null, $last_name = null, $folder_ids = null, $is_frontend = null, $ignore_visibility = null, $ip_address = null, $_rest_newsletters_recipients = null)
    {
        list($response) = $this->restNewslettersRecipientsPostWithHttpInfo($email, $first_name, $last_name, $folder_ids, $is_frontend, $ignore_visibility, $ip_address, $_rest_newsletters_recipients);
        return $response;
    }

    /**
     * Operation restNewslettersRecipientsPostWithHttpInfo
     *
     * Create recipient
     *
     * @param  string $email The email address of the recipient (optional)
     * @param  string $first_name The first name of the recipient (optional)
     * @param  string $last_name The last name of the recipient (optional)
     * @param  int $folder_ids The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  bool $is_frontend Value that indicates if the REST call was retrieved from the front end. Possible values are: &#39;true&#39; or &#39;false&#39;. True &#x3D; The REST call was retrieved from the front end. False &#x3D; The REST call was not retrieved from the front end. (optional)
     * @param  bool $ignore_visibility Value that indicates if the REST call considers folders without visibility. Possible value: &#39;true&#39;. If the value &#39;true&#39; is set, the folder visibility will be ignored. This means that both visible and invisible folders will be listed depending on the folder IDs entered in the REST call. (optional)
     * @param  string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  \OpenAPI\Client\Model\InlineObject166 $_rest_newsletters_recipients (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Recipient[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersRecipientsPostWithHttpInfo($email = null, $first_name = null, $last_name = null, $folder_ids = null, $is_frontend = null, $ignore_visibility = null, $ip_address = null, $_rest_newsletters_recipients = null)
    {
        $request = $this->restNewslettersRecipientsPostRequest($email, $first_name, $last_name, $folder_ids, $is_frontend, $ignore_visibility, $ip_address, $_rest_newsletters_recipients);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Recipient[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Recipient[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Recipient[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Recipient[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersRecipientsPostAsync
     *
     * Create recipient
     *
     * @param  string $email The email address of the recipient (optional)
     * @param  string $first_name The first name of the recipient (optional)
     * @param  string $last_name The last name of the recipient (optional)
     * @param  int $folder_ids The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  bool $is_frontend Value that indicates if the REST call was retrieved from the front end. Possible values are: &#39;true&#39; or &#39;false&#39;. True &#x3D; The REST call was retrieved from the front end. False &#x3D; The REST call was not retrieved from the front end. (optional)
     * @param  bool $ignore_visibility Value that indicates if the REST call considers folders without visibility. Possible value: &#39;true&#39;. If the value &#39;true&#39; is set, the folder visibility will be ignored. This means that both visible and invisible folders will be listed depending on the folder IDs entered in the REST call. (optional)
     * @param  string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  \OpenAPI\Client\Model\InlineObject166 $_rest_newsletters_recipients (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersRecipientsPostAsync($email = null, $first_name = null, $last_name = null, $folder_ids = null, $is_frontend = null, $ignore_visibility = null, $ip_address = null, $_rest_newsletters_recipients = null)
    {
        return $this->restNewslettersRecipientsPostAsyncWithHttpInfo($email, $first_name, $last_name, $folder_ids, $is_frontend, $ignore_visibility, $ip_address, $_rest_newsletters_recipients)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersRecipientsPostAsyncWithHttpInfo
     *
     * Create recipient
     *
     * @param  string $email The email address of the recipient (optional)
     * @param  string $first_name The first name of the recipient (optional)
     * @param  string $last_name The last name of the recipient (optional)
     * @param  int $folder_ids The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  bool $is_frontend Value that indicates if the REST call was retrieved from the front end. Possible values are: &#39;true&#39; or &#39;false&#39;. True &#x3D; The REST call was retrieved from the front end. False &#x3D; The REST call was not retrieved from the front end. (optional)
     * @param  bool $ignore_visibility Value that indicates if the REST call considers folders without visibility. Possible value: &#39;true&#39;. If the value &#39;true&#39; is set, the folder visibility will be ignored. This means that both visible and invisible folders will be listed depending on the folder IDs entered in the REST call. (optional)
     * @param  string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  \OpenAPI\Client\Model\InlineObject166 $_rest_newsletters_recipients (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersRecipientsPostAsyncWithHttpInfo($email = null, $first_name = null, $last_name = null, $folder_ids = null, $is_frontend = null, $ignore_visibility = null, $ip_address = null, $_rest_newsletters_recipients = null)
    {
        $returnType = '\OpenAPI\Client\Model\Recipient[]';
        $request = $this->restNewslettersRecipientsPostRequest($email, $first_name, $last_name, $folder_ids, $is_frontend, $ignore_visibility, $ip_address, $_rest_newsletters_recipients);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersRecipientsPost'
     *
     * @param  string $email The email address of the recipient (optional)
     * @param  string $first_name The first name of the recipient (optional)
     * @param  string $last_name The last name of the recipient (optional)
     * @param  int $folder_ids The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  bool $is_frontend Value that indicates if the REST call was retrieved from the front end. Possible values are: &#39;true&#39; or &#39;false&#39;. True &#x3D; The REST call was retrieved from the front end. False &#x3D; The REST call was not retrieved from the front end. (optional)
     * @param  bool $ignore_visibility Value that indicates if the REST call considers folders without visibility. Possible value: &#39;true&#39;. If the value &#39;true&#39; is set, the folder visibility will be ignored. This means that both visible and invisible folders will be listed depending on the folder IDs entered in the REST call. (optional)
     * @param  string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  \OpenAPI\Client\Model\InlineObject166 $_rest_newsletters_recipients (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersRecipientsPostRequest($email = null, $first_name = null, $last_name = null, $folder_ids = null, $is_frontend = null, $ignore_visibility = null, $ip_address = null, $_rest_newsletters_recipients = null)
    {

        $resourcePath = '/rest/newsletters/recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($email)) {
            $email = ObjectSerializer::serializeCollection($email, '', true);
        }
        if ($email !== null) {
            $queryParams['email'] = $email;
        }
        // query params
        if (is_array($first_name)) {
            $first_name = ObjectSerializer::serializeCollection($first_name, '', true);
        }
        if ($first_name !== null) {
            $queryParams['firstName'] = $first_name;
        }
        // query params
        if (is_array($last_name)) {
            $last_name = ObjectSerializer::serializeCollection($last_name, '', true);
        }
        if ($last_name !== null) {
            $queryParams['lastName'] = $last_name;
        }
        // query params
        if (is_array($folder_ids)) {
            $folder_ids = ObjectSerializer::serializeCollection($folder_ids, '', true);
        }
        if ($folder_ids !== null) {
            $queryParams['folderIds'] = $folder_ids;
        }
        // query params
        if (is_array($is_frontend)) {
            $is_frontend = ObjectSerializer::serializeCollection($is_frontend, '', true);
        }
        if ($is_frontend !== null) {
            $queryParams['isFrontend'] = $is_frontend;
        }
        // query params
        if (is_array($ignore_visibility)) {
            $ignore_visibility = ObjectSerializer::serializeCollection($ignore_visibility, '', true);
        }
        if ($ignore_visibility !== null) {
            $queryParams['ignoreVisibility'] = $ignore_visibility;
        }
        // query params
        if (is_array($ip_address)) {
            $ip_address = ObjectSerializer::serializeCollection($ip_address, '', true);
        }
        if ($ip_address !== null) {
            $queryParams['ipAddress'] = $ip_address;
        }



        // body params
        $_tempBody = null;
        if (isset($_rest_newsletters_recipients)) {
            $_tempBody = $_rest_newsletters_recipients;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdDelete
     *
     * Delete recipient
     *
     * @param  int $recipient_id The ID of the recipient (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Recipient
     */
    public function restNewslettersRecipientsRecipientIdDelete($recipient_id)
    {
        list($response) = $this->restNewslettersRecipientsRecipientIdDeleteWithHttpInfo($recipient_id);
        return $response;
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdDeleteWithHttpInfo
     *
     * Delete recipient
     *
     * @param  int $recipient_id The ID of the recipient (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Recipient, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersRecipientsRecipientIdDeleteWithHttpInfo($recipient_id)
    {
        $request = $this->restNewslettersRecipientsRecipientIdDeleteRequest($recipient_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Recipient' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Recipient', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Recipient';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Recipient',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdDeleteAsync
     *
     * Delete recipient
     *
     * @param  int $recipient_id The ID of the recipient (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersRecipientsRecipientIdDeleteAsync($recipient_id)
    {
        return $this->restNewslettersRecipientsRecipientIdDeleteAsyncWithHttpInfo($recipient_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdDeleteAsyncWithHttpInfo
     *
     * Delete recipient
     *
     * @param  int $recipient_id The ID of the recipient (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersRecipientsRecipientIdDeleteAsyncWithHttpInfo($recipient_id)
    {
        $returnType = '\OpenAPI\Client\Model\Recipient';
        $request = $this->restNewslettersRecipientsRecipientIdDeleteRequest($recipient_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersRecipientsRecipientIdDelete'
     *
     * @param  int $recipient_id The ID of the recipient (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersRecipientsRecipientIdDeleteRequest($recipient_id)
    {
        // verify the required parameter 'recipient_id' is set
        if ($recipient_id === null || (is_array($recipient_id) && count($recipient_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recipient_id when calling restNewslettersRecipientsRecipientIdDelete'
            );
        }

        $resourcePath = '/rest/newsletters/recipients/{recipientId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($recipient_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recipientId' . '}',
                ObjectSerializer::toPathValue($recipient_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdGet
     *
     * List recipient
     *
     * @param  int $recipient_id The ID of the newsletter folder. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Recipient
     */
    public function restNewslettersRecipientsRecipientIdGet($recipient_id)
    {
        list($response) = $this->restNewslettersRecipientsRecipientIdGetWithHttpInfo($recipient_id);
        return $response;
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdGetWithHttpInfo
     *
     * List recipient
     *
     * @param  int $recipient_id The ID of the newsletter folder. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Recipient, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersRecipientsRecipientIdGetWithHttpInfo($recipient_id)
    {
        $request = $this->restNewslettersRecipientsRecipientIdGetRequest($recipient_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Recipient' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Recipient', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Recipient';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Recipient',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdGetAsync
     *
     * List recipient
     *
     * @param  int $recipient_id The ID of the newsletter folder. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersRecipientsRecipientIdGetAsync($recipient_id)
    {
        return $this->restNewslettersRecipientsRecipientIdGetAsyncWithHttpInfo($recipient_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdGetAsyncWithHttpInfo
     *
     * List recipient
     *
     * @param  int $recipient_id The ID of the newsletter folder. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersRecipientsRecipientIdGetAsyncWithHttpInfo($recipient_id)
    {
        $returnType = '\OpenAPI\Client\Model\Recipient';
        $request = $this->restNewslettersRecipientsRecipientIdGetRequest($recipient_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersRecipientsRecipientIdGet'
     *
     * @param  int $recipient_id The ID of the newsletter folder. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersRecipientsRecipientIdGetRequest($recipient_id)
    {
        // verify the required parameter 'recipient_id' is set
        if ($recipient_id === null || (is_array($recipient_id) && count($recipient_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recipient_id when calling restNewslettersRecipientsRecipientIdGet'
            );
        }

        $resourcePath = '/rest/newsletters/recipients/{recipientId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($recipient_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recipientId' . '}',
                ObjectSerializer::toPathValue($recipient_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdPut
     *
     * Update recipient
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  string $email The email address of the newsletter recipient (optional)
     * @param  string $first_name The first name of the newsletter recipient (optional)
     * @param  string $last_name The last name of the newsletter recipient (optional)
     * @param  int $folder_ids DEPRECATED: The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  int $folder_id The ID of the newsletter folder. (optional)
     * @param  string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  string $birthday The customer birthday as Date string (e.g. &#39;1982-11-24&#39;, &#39;1982/11/24&#39; or &#39;24.11.1982&#39;) (optional)
     * @param  string $gender The gender of the customer, one of the following values: &#39;m&#39;,&#39;f&#39;,&#39;d&#39;. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject167 $_rest_newsletters_recipients_recipient_id _rest_newsletters_recipients_recipient_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Recipient
     */
    public function restNewslettersRecipientsRecipientIdPut($recipient_id, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $folder_id = null, $ip_address = null, $birthday = null, $gender = null, $_rest_newsletters_recipients_recipient_id = null)
    {
        list($response) = $this->restNewslettersRecipientsRecipientIdPutWithHttpInfo($recipient_id, $email, $first_name, $last_name, $folder_ids, $folder_id, $ip_address, $birthday, $gender, $_rest_newsletters_recipients_recipient_id);
        return $response;
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdPutWithHttpInfo
     *
     * Update recipient
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  string $email The email address of the newsletter recipient (optional)
     * @param  string $first_name The first name of the newsletter recipient (optional)
     * @param  string $last_name The last name of the newsletter recipient (optional)
     * @param  int $folder_ids DEPRECATED: The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  int $folder_id The ID of the newsletter folder. (optional)
     * @param  string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  string $birthday The customer birthday as Date string (e.g. &#39;1982-11-24&#39;, &#39;1982/11/24&#39; or &#39;24.11.1982&#39;) (optional)
     * @param  string $gender The gender of the customer, one of the following values: &#39;m&#39;,&#39;f&#39;,&#39;d&#39;. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject167 $_rest_newsletters_recipients_recipient_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Recipient, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersRecipientsRecipientIdPutWithHttpInfo($recipient_id, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $folder_id = null, $ip_address = null, $birthday = null, $gender = null, $_rest_newsletters_recipients_recipient_id = null)
    {
        $request = $this->restNewslettersRecipientsRecipientIdPutRequest($recipient_id, $email, $first_name, $last_name, $folder_ids, $folder_id, $ip_address, $birthday, $gender, $_rest_newsletters_recipients_recipient_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Recipient' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Recipient', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Recipient';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Recipient',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdPutAsync
     *
     * Update recipient
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  string $email The email address of the newsletter recipient (optional)
     * @param  string $first_name The first name of the newsletter recipient (optional)
     * @param  string $last_name The last name of the newsletter recipient (optional)
     * @param  int $folder_ids DEPRECATED: The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  int $folder_id The ID of the newsletter folder. (optional)
     * @param  string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  string $birthday The customer birthday as Date string (e.g. &#39;1982-11-24&#39;, &#39;1982/11/24&#39; or &#39;24.11.1982&#39;) (optional)
     * @param  string $gender The gender of the customer, one of the following values: &#39;m&#39;,&#39;f&#39;,&#39;d&#39;. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject167 $_rest_newsletters_recipients_recipient_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersRecipientsRecipientIdPutAsync($recipient_id, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $folder_id = null, $ip_address = null, $birthday = null, $gender = null, $_rest_newsletters_recipients_recipient_id = null)
    {
        return $this->restNewslettersRecipientsRecipientIdPutAsyncWithHttpInfo($recipient_id, $email, $first_name, $last_name, $folder_ids, $folder_id, $ip_address, $birthday, $gender, $_rest_newsletters_recipients_recipient_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdPutAsyncWithHttpInfo
     *
     * Update recipient
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  string $email The email address of the newsletter recipient (optional)
     * @param  string $first_name The first name of the newsletter recipient (optional)
     * @param  string $last_name The last name of the newsletter recipient (optional)
     * @param  int $folder_ids DEPRECATED: The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  int $folder_id The ID of the newsletter folder. (optional)
     * @param  string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  string $birthday The customer birthday as Date string (e.g. &#39;1982-11-24&#39;, &#39;1982/11/24&#39; or &#39;24.11.1982&#39;) (optional)
     * @param  string $gender The gender of the customer, one of the following values: &#39;m&#39;,&#39;f&#39;,&#39;d&#39;. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject167 $_rest_newsletters_recipients_recipient_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersRecipientsRecipientIdPutAsyncWithHttpInfo($recipient_id, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $folder_id = null, $ip_address = null, $birthday = null, $gender = null, $_rest_newsletters_recipients_recipient_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\Recipient';
        $request = $this->restNewslettersRecipientsRecipientIdPutRequest($recipient_id, $email, $first_name, $last_name, $folder_ids, $folder_id, $ip_address, $birthday, $gender, $_rest_newsletters_recipients_recipient_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersRecipientsRecipientIdPut'
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  string $email The email address of the newsletter recipient (optional)
     * @param  string $first_name The first name of the newsletter recipient (optional)
     * @param  string $last_name The last name of the newsletter recipient (optional)
     * @param  int $folder_ids DEPRECATED: The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  int $folder_id The ID of the newsletter folder. (optional)
     * @param  string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  string $birthday The customer birthday as Date string (e.g. &#39;1982-11-24&#39;, &#39;1982/11/24&#39; or &#39;24.11.1982&#39;) (optional)
     * @param  string $gender The gender of the customer, one of the following values: &#39;m&#39;,&#39;f&#39;,&#39;d&#39;. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject167 $_rest_newsletters_recipients_recipient_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersRecipientsRecipientIdPutRequest($recipient_id, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $folder_id = null, $ip_address = null, $birthday = null, $gender = null, $_rest_newsletters_recipients_recipient_id = null)
    {
        // verify the required parameter 'recipient_id' is set
        if ($recipient_id === null || (is_array($recipient_id) && count($recipient_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recipient_id when calling restNewslettersRecipientsRecipientIdPut'
            );
        }

        $resourcePath = '/rest/newsletters/recipients/{recipientId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($email)) {
            $email = ObjectSerializer::serializeCollection($email, '', true);
        }
        if ($email !== null) {
            $queryParams['email'] = $email;
        }
        // query params
        if (is_array($first_name)) {
            $first_name = ObjectSerializer::serializeCollection($first_name, '', true);
        }
        if ($first_name !== null) {
            $queryParams['firstName'] = $first_name;
        }
        // query params
        if (is_array($last_name)) {
            $last_name = ObjectSerializer::serializeCollection($last_name, '', true);
        }
        if ($last_name !== null) {
            $queryParams['lastName'] = $last_name;
        }
        // query params
        if (is_array($folder_ids)) {
            $folder_ids = ObjectSerializer::serializeCollection($folder_ids, '', true);
        }
        if ($folder_ids !== null) {
            $queryParams['folderIds'] = $folder_ids;
        }
        // query params
        if (is_array($folder_id)) {
            $folder_id = ObjectSerializer::serializeCollection($folder_id, '', true);
        }
        if ($folder_id !== null) {
            $queryParams['folderId'] = $folder_id;
        }
        // query params
        if (is_array($ip_address)) {
            $ip_address = ObjectSerializer::serializeCollection($ip_address, '', true);
        }
        if ($ip_address !== null) {
            $queryParams['ipAddress'] = $ip_address;
        }
        // query params
        if (is_array($birthday)) {
            $birthday = ObjectSerializer::serializeCollection($birthday, '', true);
        }
        if ($birthday !== null) {
            $queryParams['birthday'] = $birthday;
        }
        // query params
        if (is_array($gender)) {
            $gender = ObjectSerializer::serializeCollection($gender, '', true);
        }
        if ($gender !== null) {
            $queryParams['gender'] = $gender;
        }


        // path params
        if ($recipient_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recipientId' . '}',
                ObjectSerializer::toPathValue($recipient_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_newsletters_recipients_recipient_id)) {
            $_tempBody = $_rest_newsletters_recipients_recipient_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
