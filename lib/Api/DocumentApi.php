<?php
/**
 * DocumentApi
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0-beta2
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * DocumentApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DocumentApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsDocumentIdDelete
     *
     * Deletes a category document. The ID of the document must be specified.
     *
     * @param  int $category_id category_id (required)
     * @param  int $document_id document_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restCategoriesCategoryIdDocumentsDocumentIdDelete($category_id, $document_id)
    {
        list($response) = $this->restCategoriesCategoryIdDocumentsDocumentIdDeleteWithHttpInfo($category_id, $document_id);
        return $response;
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsDocumentIdDeleteWithHttpInfo
     *
     * Deletes a category document. The ID of the document must be specified.
     *
     * @param  int $category_id (required)
     * @param  int $document_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoriesCategoryIdDocumentsDocumentIdDeleteWithHttpInfo($category_id, $document_id)
    {
        $request = $this->restCategoriesCategoryIdDocumentsDocumentIdDeleteRequest($category_id, $document_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsDocumentIdDeleteAsync
     *
     * Deletes a category document. The ID of the document must be specified.
     *
     * @param  int $category_id (required)
     * @param  int $document_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restCategoriesCategoryIdDocumentsDocumentIdDeleteAsync($category_id, $document_id)
    {
        return $this->restCategoriesCategoryIdDocumentsDocumentIdDeleteAsyncWithHttpInfo($category_id, $document_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsDocumentIdDeleteAsyncWithHttpInfo
     *
     * Deletes a category document. The ID of the document must be specified.
     *
     * @param  int $category_id (required)
     * @param  int $document_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restCategoriesCategoryIdDocumentsDocumentIdDeleteAsyncWithHttpInfo($category_id, $document_id)
    {
        $returnType = 'object';
        $request = $this->restCategoriesCategoryIdDocumentsDocumentIdDeleteRequest($category_id, $document_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoriesCategoryIdDocumentsDocumentIdDelete'
     *
     * @param  int $category_id (required)
     * @param  int $document_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restCategoriesCategoryIdDocumentsDocumentIdDeleteRequest($category_id, $document_id)
    {
        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_id when calling restCategoriesCategoryIdDocumentsDocumentIdDelete'
            );
        }
        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling restCategoriesCategoryIdDocumentsDocumentIdDelete'
            );
        }

        $resourcePath = '/rest/categories/{categoryId}/documents/{documentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($category_id !== null) {
            $resourcePath = str_replace(
                '{' . 'categoryId' . '}',
                ObjectSerializer::toPathValue($category_id),
                $resourcePath
            );
        }
        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'documentId' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsDownloadsGet
     *
     * Download category documents
     *
     * @param  int $category_id The ID of the category (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restCategoriesCategoryIdDocumentsDownloadsGet($category_id)
    {
        list($response) = $this->restCategoriesCategoryIdDocumentsDownloadsGetWithHttpInfo($category_id);
        return $response;
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsDownloadsGetWithHttpInfo
     *
     * Download category documents
     *
     * @param  int $category_id The ID of the category (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoriesCategoryIdDocumentsDownloadsGetWithHttpInfo($category_id)
    {
        $request = $this->restCategoriesCategoryIdDocumentsDownloadsGetRequest($category_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsDownloadsGetAsync
     *
     * Download category documents
     *
     * @param  int $category_id The ID of the category (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restCategoriesCategoryIdDocumentsDownloadsGetAsync($category_id)
    {
        return $this->restCategoriesCategoryIdDocumentsDownloadsGetAsyncWithHttpInfo($category_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsDownloadsGetAsyncWithHttpInfo
     *
     * Download category documents
     *
     * @param  int $category_id The ID of the category (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restCategoriesCategoryIdDocumentsDownloadsGetAsyncWithHttpInfo($category_id)
    {
        $returnType = 'object';
        $request = $this->restCategoriesCategoryIdDocumentsDownloadsGetRequest($category_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoriesCategoryIdDocumentsDownloadsGet'
     *
     * @param  int $category_id The ID of the category (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restCategoriesCategoryIdDocumentsDownloadsGetRequest($category_id)
    {
        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_id when calling restCategoriesCategoryIdDocumentsDownloadsGet'
            );
        }

        $resourcePath = '/rest/categories/{categoryId}/documents/downloads';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($category_id !== null) {
            $resourcePath = str_replace(
                '{' . 'categoryId' . '}',
                ObjectSerializer::toPathValue($category_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsGet
     *
     * List documents of a category
     *
     * @param  int $category_id The ID of the category (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse2007
     */
    public function restCategoriesCategoryIdDocumentsGet($category_id)
    {
        list($response) = $this->restCategoriesCategoryIdDocumentsGetWithHttpInfo($category_id);
        return $response;
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsGetWithHttpInfo
     *
     * List documents of a category
     *
     * @param  int $category_id The ID of the category (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse2007, HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoriesCategoryIdDocumentsGetWithHttpInfo($category_id)
    {
        $request = $this->restCategoriesCategoryIdDocumentsGetRequest($category_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse2007' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse2007', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse2007';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse2007',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsGetAsync
     *
     * List documents of a category
     *
     * @param  int $category_id The ID of the category (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restCategoriesCategoryIdDocumentsGetAsync($category_id)
    {
        return $this->restCategoriesCategoryIdDocumentsGetAsyncWithHttpInfo($category_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsGetAsyncWithHttpInfo
     *
     * List documents of a category
     *
     * @param  int $category_id The ID of the category (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restCategoriesCategoryIdDocumentsGetAsyncWithHttpInfo($category_id)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse2007';
        $request = $this->restCategoriesCategoryIdDocumentsGetRequest($category_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoriesCategoryIdDocumentsGet'
     *
     * @param  int $category_id The ID of the category (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restCategoriesCategoryIdDocumentsGetRequest($category_id)
    {
        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_id when calling restCategoriesCategoryIdDocumentsGet'
            );
        }

        $resourcePath = '/rest/categories/{categoryId}/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($category_id !== null) {
            $resourcePath = str_replace(
                '{' . 'categoryId' . '}',
                ObjectSerializer::toPathValue($category_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsPost
     *
     * Upload category documents
     *
     * @param  int $documents The array with the category documents (required)
     * @param  int $category_id The ID of the category (required)
     * @param  int $number The document number (optional)
     * @param  string $number_with_prefix Number with prefix (optional)
     * @param  int $directory_id The directory ID (optional)
     * @param  string $display_date The date displayed on the document (optional)
     * @param  \OpenAPI\Client\Model\InlineObject41 $_rest_categories_category_id_documents _rest_categories_category_id_documents (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Document[]
     */
    public function restCategoriesCategoryIdDocumentsPost($documents, $category_id, $number = null, $number_with_prefix = null, $directory_id = null, $display_date = null, $_rest_categories_category_id_documents = null)
    {
        list($response) = $this->restCategoriesCategoryIdDocumentsPostWithHttpInfo($documents, $category_id, $number, $number_with_prefix, $directory_id, $display_date, $_rest_categories_category_id_documents);
        return $response;
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsPostWithHttpInfo
     *
     * Upload category documents
     *
     * @param  int $documents The array with the category documents (required)
     * @param  int $category_id The ID of the category (required)
     * @param  int $number The document number (optional)
     * @param  string $number_with_prefix Number with prefix (optional)
     * @param  int $directory_id The directory ID (optional)
     * @param  string $display_date The date displayed on the document (optional)
     * @param  \OpenAPI\Client\Model\InlineObject41 $_rest_categories_category_id_documents (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Document[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoriesCategoryIdDocumentsPostWithHttpInfo($documents, $category_id, $number = null, $number_with_prefix = null, $directory_id = null, $display_date = null, $_rest_categories_category_id_documents = null)
    {
        $request = $this->restCategoriesCategoryIdDocumentsPostRequest($documents, $category_id, $number, $number_with_prefix, $directory_id, $display_date, $_rest_categories_category_id_documents);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Document[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Document[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Document[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Document[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsPostAsync
     *
     * Upload category documents
     *
     * @param  int $documents The array with the category documents (required)
     * @param  int $category_id The ID of the category (required)
     * @param  int $number The document number (optional)
     * @param  string $number_with_prefix Number with prefix (optional)
     * @param  int $directory_id The directory ID (optional)
     * @param  string $display_date The date displayed on the document (optional)
     * @param  \OpenAPI\Client\Model\InlineObject41 $_rest_categories_category_id_documents (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restCategoriesCategoryIdDocumentsPostAsync($documents, $category_id, $number = null, $number_with_prefix = null, $directory_id = null, $display_date = null, $_rest_categories_category_id_documents = null)
    {
        return $this->restCategoriesCategoryIdDocumentsPostAsyncWithHttpInfo($documents, $category_id, $number, $number_with_prefix, $directory_id, $display_date, $_rest_categories_category_id_documents)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsPostAsyncWithHttpInfo
     *
     * Upload category documents
     *
     * @param  int $documents The array with the category documents (required)
     * @param  int $category_id The ID of the category (required)
     * @param  int $number The document number (optional)
     * @param  string $number_with_prefix Number with prefix (optional)
     * @param  int $directory_id The directory ID (optional)
     * @param  string $display_date The date displayed on the document (optional)
     * @param  \OpenAPI\Client\Model\InlineObject41 $_rest_categories_category_id_documents (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restCategoriesCategoryIdDocumentsPostAsyncWithHttpInfo($documents, $category_id, $number = null, $number_with_prefix = null, $directory_id = null, $display_date = null, $_rest_categories_category_id_documents = null)
    {
        $returnType = '\OpenAPI\Client\Model\Document[]';
        $request = $this->restCategoriesCategoryIdDocumentsPostRequest($documents, $category_id, $number, $number_with_prefix, $directory_id, $display_date, $_rest_categories_category_id_documents);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoriesCategoryIdDocumentsPost'
     *
     * @param  int $documents The array with the category documents (required)
     * @param  int $category_id The ID of the category (required)
     * @param  int $number The document number (optional)
     * @param  string $number_with_prefix Number with prefix (optional)
     * @param  int $directory_id The directory ID (optional)
     * @param  string $display_date The date displayed on the document (optional)
     * @param  \OpenAPI\Client\Model\InlineObject41 $_rest_categories_category_id_documents (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restCategoriesCategoryIdDocumentsPostRequest($documents, $category_id, $number = null, $number_with_prefix = null, $directory_id = null, $display_date = null, $_rest_categories_category_id_documents = null)
    {
        // verify the required parameter 'documents' is set
        if ($documents === null || (is_array($documents) && count($documents) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $documents when calling restCategoriesCategoryIdDocumentsPost'
            );
        }
        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_id when calling restCategoriesCategoryIdDocumentsPost'
            );
        }

        $resourcePath = '/rest/categories/{categoryId}/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($documents)) {
            $documents = ObjectSerializer::serializeCollection($documents, '', true);
        }
        if ($documents !== null) {
            $queryParams['documents'] = $documents;
        }
        // query params
        if (is_array($number)) {
            $number = ObjectSerializer::serializeCollection($number, '', true);
        }
        if ($number !== null) {
            $queryParams['number'] = $number;
        }
        // query params
        if (is_array($number_with_prefix)) {
            $number_with_prefix = ObjectSerializer::serializeCollection($number_with_prefix, '', true);
        }
        if ($number_with_prefix !== null) {
            $queryParams['numberWithPrefix'] = $number_with_prefix;
        }
        // query params
        if (is_array($directory_id)) {
            $directory_id = ObjectSerializer::serializeCollection($directory_id, '', true);
        }
        if ($directory_id !== null) {
            $queryParams['directoryId'] = $directory_id;
        }
        // query params
        if (is_array($display_date)) {
            $display_date = ObjectSerializer::serializeCollection($display_date, '', true);
        }
        if ($display_date !== null) {
            $queryParams['displayDate'] = $display_date;
        }


        // path params
        if ($category_id !== null) {
            $resourcePath = str_replace(
                '{' . 'categoryId' . '}',
                ObjectSerializer::toPathValue($category_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_categories_category_id_documents)) {
            $_tempBody = $_rest_categories_category_id_documents;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restDocumentsDocumentIdGet
     *
     * Download the content of a document
     *
     * @param  int $document_id The ID of the document (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restDocumentsDocumentIdGet($document_id)
    {
        list($response) = $this->restDocumentsDocumentIdGetWithHttpInfo($document_id);
        return $response;
    }

    /**
     * Operation restDocumentsDocumentIdGetWithHttpInfo
     *
     * Download the content of a document
     *
     * @param  int $document_id The ID of the document (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restDocumentsDocumentIdGetWithHttpInfo($document_id)
    {
        $request = $this->restDocumentsDocumentIdGetRequest($document_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restDocumentsDocumentIdGetAsync
     *
     * Download the content of a document
     *
     * @param  int $document_id The ID of the document (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restDocumentsDocumentIdGetAsync($document_id)
    {
        return $this->restDocumentsDocumentIdGetAsyncWithHttpInfo($document_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restDocumentsDocumentIdGetAsyncWithHttpInfo
     *
     * Download the content of a document
     *
     * @param  int $document_id The ID of the document (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restDocumentsDocumentIdGetAsyncWithHttpInfo($document_id)
    {
        $returnType = 'object';
        $request = $this->restDocumentsDocumentIdGetRequest($document_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restDocumentsDocumentIdGet'
     *
     * @param  int $document_id The ID of the document (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restDocumentsDocumentIdGetRequest($document_id)
    {
        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling restDocumentsDocumentIdGet'
            );
        }

        $resourcePath = '/rest/documents/{documentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'documentId' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersDocumentsDownloadsTypeGet
     *
     * Download documents of a document type
     *
     * @param  string $type The type of the order document. The available types are receipt, zReport, tillCount, posCouponReceipt, posInvoice, posInvoiceCancellation, cancellation, invoiceExternal, invoice, deliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reorder, uploaded. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The number of documents to display per page. The default number displayed is 50. The maximum number is 6000. (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_from Filter that restricts the search result to documents that were updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to documents that were updated within a certain period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersDocumentsDownloadsTypeGet($type, $page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $updated_at_from = null, $updated_at_to = null, $display_date_from = null, $display_date_to = null)
    {
        list($response) = $this->restOrdersDocumentsDownloadsTypeGetWithHttpInfo($type, $page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $updated_at_from, $updated_at_to, $display_date_from, $display_date_to);
        return $response;
    }

    /**
     * Operation restOrdersDocumentsDownloadsTypeGetWithHttpInfo
     *
     * Download documents of a document type
     *
     * @param  string $type The type of the order document. The available types are receipt, zReport, tillCount, posCouponReceipt, posInvoice, posInvoiceCancellation, cancellation, invoiceExternal, invoice, deliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reorder, uploaded. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The number of documents to display per page. The default number displayed is 50. The maximum number is 6000. (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_from Filter that restricts the search result to documents that were updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to documents that were updated within a certain period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersDocumentsDownloadsTypeGetWithHttpInfo($type, $page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $updated_at_from = null, $updated_at_to = null, $display_date_from = null, $display_date_to = null)
    {
        $request = $this->restOrdersDocumentsDownloadsTypeGetRequest($type, $page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $updated_at_from, $updated_at_to, $display_date_from, $display_date_to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersDocumentsDownloadsTypeGetAsync
     *
     * Download documents of a document type
     *
     * @param  string $type The type of the order document. The available types are receipt, zReport, tillCount, posCouponReceipt, posInvoice, posInvoiceCancellation, cancellation, invoiceExternal, invoice, deliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reorder, uploaded. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The number of documents to display per page. The default number displayed is 50. The maximum number is 6000. (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_from Filter that restricts the search result to documents that were updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to documents that were updated within a certain period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersDocumentsDownloadsTypeGetAsync($type, $page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $updated_at_from = null, $updated_at_to = null, $display_date_from = null, $display_date_to = null)
    {
        return $this->restOrdersDocumentsDownloadsTypeGetAsyncWithHttpInfo($type, $page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $updated_at_from, $updated_at_to, $display_date_from, $display_date_to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersDocumentsDownloadsTypeGetAsyncWithHttpInfo
     *
     * Download documents of a document type
     *
     * @param  string $type The type of the order document. The available types are receipt, zReport, tillCount, posCouponReceipt, posInvoice, posInvoiceCancellation, cancellation, invoiceExternal, invoice, deliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reorder, uploaded. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The number of documents to display per page. The default number displayed is 50. The maximum number is 6000. (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_from Filter that restricts the search result to documents that were updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to documents that were updated within a certain period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersDocumentsDownloadsTypeGetAsyncWithHttpInfo($type, $page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $updated_at_from = null, $updated_at_to = null, $display_date_from = null, $display_date_to = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersDocumentsDownloadsTypeGetRequest($type, $page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $updated_at_from, $updated_at_to, $display_date_from, $display_date_to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersDocumentsDownloadsTypeGet'
     *
     * @param  string $type The type of the order document. The available types are receipt, zReport, tillCount, posCouponReceipt, posInvoice, posInvoiceCancellation, cancellation, invoiceExternal, invoice, deliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reorder, uploaded. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The number of documents to display per page. The default number displayed is 50. The maximum number is 6000. (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_from Filter that restricts the search result to documents that were updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to documents that were updated within a certain period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersDocumentsDownloadsTypeGetRequest($type, $page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $updated_at_from = null, $updated_at_to = null, $display_date_from = null, $display_date_to = null)
    {
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling restOrdersDocumentsDownloadsTypeGet'
            );
        }
        // verify the required parameter 'page' is set
        if ($page === null || (is_array($page) && count($page) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page when calling restOrdersDocumentsDownloadsTypeGet'
            );
        }
        // verify the required parameter 'items_per_page' is set
        if ($items_per_page === null || (is_array($items_per_page) && count($items_per_page) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $items_per_page when calling restOrdersDocumentsDownloadsTypeGet'
            );
        }

        $resourcePath = '/rest/orders/documents/downloads/{type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($contact_id)) {
            $contact_id = ObjectSerializer::serializeCollection($contact_id, '', true);
        }
        if ($contact_id !== null) {
            $queryParams['contactId'] = $contact_id;
        }
        // query params
        if (is_array($plenty_id)) {
            $plenty_id = ObjectSerializer::serializeCollection($plenty_id, '', true);
        }
        if ($plenty_id !== null) {
            $queryParams['plentyId'] = $plenty_id;
        }
        // query params
        if (is_array($created_at_from)) {
            $created_at_from = ObjectSerializer::serializeCollection($created_at_from, '', true);
        }
        if ($created_at_from !== null) {
            $queryParams['createdAtFrom'] = $created_at_from;
        }
        // query params
        if (is_array($created_at_to)) {
            $created_at_to = ObjectSerializer::serializeCollection($created_at_to, '', true);
        }
        if ($created_at_to !== null) {
            $queryParams['createdAtTo'] = $created_at_to;
        }
        // query params
        if (is_array($updated_at_from)) {
            $updated_at_from = ObjectSerializer::serializeCollection($updated_at_from, '', true);
        }
        if ($updated_at_from !== null) {
            $queryParams['updatedAtFrom'] = $updated_at_from;
        }
        // query params
        if (is_array($updated_at_to)) {
            $updated_at_to = ObjectSerializer::serializeCollection($updated_at_to, '', true);
        }
        if ($updated_at_to !== null) {
            $queryParams['updatedAtTo'] = $updated_at_to;
        }
        // query params
        if (is_array($display_date_from)) {
            $display_date_from = ObjectSerializer::serializeCollection($display_date_from, '', true);
        }
        if ($display_date_from !== null) {
            $queryParams['displayDateFrom'] = $display_date_from;
        }
        // query params
        if (is_array($display_date_to)) {
            $display_date_to = ObjectSerializer::serializeCollection($display_date_to, '', true);
        }
        if ($display_date_to !== null) {
            $queryParams['displayDateTo'] = $display_date_to;
        }
        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }


        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersDocumentsGet
     *
     * List order documents
     *
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;references&#39; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse2007
     */
    public function restOrdersDocumentsGet($page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $display_date_from = null, $display_date_to = null, $with = null, $with_content = null)
    {
        list($response) = $this->restOrdersDocumentsGetWithHttpInfo($page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $display_date_from, $display_date_to, $with, $with_content);
        return $response;
    }

    /**
     * Operation restOrdersDocumentsGetWithHttpInfo
     *
     * List order documents
     *
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;references&#39; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse2007, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersDocumentsGetWithHttpInfo($page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $display_date_from = null, $display_date_to = null, $with = null, $with_content = null)
    {
        $request = $this->restOrdersDocumentsGetRequest($page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $display_date_from, $display_date_to, $with, $with_content);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse2007' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse2007', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse2007';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse2007',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersDocumentsGetAsync
     *
     * List order documents
     *
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;references&#39; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersDocumentsGetAsync($page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $display_date_from = null, $display_date_to = null, $with = null, $with_content = null)
    {
        return $this->restOrdersDocumentsGetAsyncWithHttpInfo($page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $display_date_from, $display_date_to, $with, $with_content)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersDocumentsGetAsyncWithHttpInfo
     *
     * List order documents
     *
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;references&#39; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersDocumentsGetAsyncWithHttpInfo($page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $display_date_from = null, $display_date_to = null, $with = null, $with_content = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse2007';
        $request = $this->restOrdersDocumentsGetRequest($page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $display_date_from, $display_date_to, $with, $with_content);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersDocumentsGet'
     *
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;references&#39; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersDocumentsGetRequest($page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $display_date_from = null, $display_date_to = null, $with = null, $with_content = null)
    {
        // verify the required parameter 'page' is set
        if ($page === null || (is_array($page) && count($page) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page when calling restOrdersDocumentsGet'
            );
        }
        // verify the required parameter 'items_per_page' is set
        if ($items_per_page === null || (is_array($items_per_page) && count($items_per_page) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $items_per_page when calling restOrdersDocumentsGet'
            );
        }

        $resourcePath = '/rest/orders/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($contact_id)) {
            $contact_id = ObjectSerializer::serializeCollection($contact_id, '', true);
        }
        if ($contact_id !== null) {
            $queryParams['contactId'] = $contact_id;
        }
        // query params
        if (is_array($plenty_id)) {
            $plenty_id = ObjectSerializer::serializeCollection($plenty_id, '', true);
        }
        if ($plenty_id !== null) {
            $queryParams['plentyId'] = $plenty_id;
        }
        // query params
        if (is_array($created_at_from)) {
            $created_at_from = ObjectSerializer::serializeCollection($created_at_from, '', true);
        }
        if ($created_at_from !== null) {
            $queryParams['createdAtFrom'] = $created_at_from;
        }
        // query params
        if (is_array($created_at_to)) {
            $created_at_to = ObjectSerializer::serializeCollection($created_at_to, '', true);
        }
        if ($created_at_to !== null) {
            $queryParams['createdAtTo'] = $created_at_to;
        }
        // query params
        if (is_array($display_date_from)) {
            $display_date_from = ObjectSerializer::serializeCollection($display_date_from, '', true);
        }
        if ($display_date_from !== null) {
            $queryParams['displayDateFrom'] = $display_date_from;
        }
        // query params
        if (is_array($display_date_to)) {
            $display_date_to = ObjectSerializer::serializeCollection($display_date_to, '', true);
        }
        if ($display_date_to !== null) {
            $queryParams['displayDateTo'] = $display_date_to;
        }
        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }
        // query params
        if (is_array($with_content)) {
            $with_content = ObjectSerializer::serializeCollection($with_content, '', true);
        }
        if ($with_content !== null) {
            $queryParams['withContent'] = $with_content;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersDocumentsTypeGet
     *
     * List documents of a type
     *
     * @param  string $type The type of the order document. The available types are receipt, tillCount, posCouponReceipt, posInvoice, posInvoiceCancellation, cancellation, zReport, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, proFormaInvoice, reorder, uploaded. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_from Filter that restricts the search result to documents that were updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to documents that were updated within a certain period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;references&#39; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse2007
     */
    public function restOrdersDocumentsTypeGet($type, $page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $updated_at_from = null, $updated_at_to = null, $display_date_from = null, $display_date_to = null, $with = null, $with_content = null)
    {
        list($response) = $this->restOrdersDocumentsTypeGetWithHttpInfo($type, $page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $updated_at_from, $updated_at_to, $display_date_from, $display_date_to, $with, $with_content);
        return $response;
    }

    /**
     * Operation restOrdersDocumentsTypeGetWithHttpInfo
     *
     * List documents of a type
     *
     * @param  string $type The type of the order document. The available types are receipt, tillCount, posCouponReceipt, posInvoice, posInvoiceCancellation, cancellation, zReport, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, proFormaInvoice, reorder, uploaded. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_from Filter that restricts the search result to documents that were updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to documents that were updated within a certain period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;references&#39; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse2007, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersDocumentsTypeGetWithHttpInfo($type, $page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $updated_at_from = null, $updated_at_to = null, $display_date_from = null, $display_date_to = null, $with = null, $with_content = null)
    {
        $request = $this->restOrdersDocumentsTypeGetRequest($type, $page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $updated_at_from, $updated_at_to, $display_date_from, $display_date_to, $with, $with_content);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse2007' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse2007', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse2007';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse2007',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersDocumentsTypeGetAsync
     *
     * List documents of a type
     *
     * @param  string $type The type of the order document. The available types are receipt, tillCount, posCouponReceipt, posInvoice, posInvoiceCancellation, cancellation, zReport, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, proFormaInvoice, reorder, uploaded. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_from Filter that restricts the search result to documents that were updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to documents that were updated within a certain period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;references&#39; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersDocumentsTypeGetAsync($type, $page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $updated_at_from = null, $updated_at_to = null, $display_date_from = null, $display_date_to = null, $with = null, $with_content = null)
    {
        return $this->restOrdersDocumentsTypeGetAsyncWithHttpInfo($type, $page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $updated_at_from, $updated_at_to, $display_date_from, $display_date_to, $with, $with_content)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersDocumentsTypeGetAsyncWithHttpInfo
     *
     * List documents of a type
     *
     * @param  string $type The type of the order document. The available types are receipt, tillCount, posCouponReceipt, posInvoice, posInvoiceCancellation, cancellation, zReport, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, proFormaInvoice, reorder, uploaded. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_from Filter that restricts the search result to documents that were updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to documents that were updated within a certain period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;references&#39; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersDocumentsTypeGetAsyncWithHttpInfo($type, $page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $updated_at_from = null, $updated_at_to = null, $display_date_from = null, $display_date_to = null, $with = null, $with_content = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse2007';
        $request = $this->restOrdersDocumentsTypeGetRequest($type, $page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $updated_at_from, $updated_at_to, $display_date_from, $display_date_to, $with, $with_content);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersDocumentsTypeGet'
     *
     * @param  string $type The type of the order document. The available types are receipt, tillCount, posCouponReceipt, posInvoice, posInvoiceCancellation, cancellation, zReport, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, proFormaInvoice, reorder, uploaded. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_from Filter that restricts the search result to documents that were updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to documents that were updated within a certain period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;references&#39; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersDocumentsTypeGetRequest($type, $page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $updated_at_from = null, $updated_at_to = null, $display_date_from = null, $display_date_to = null, $with = null, $with_content = null)
    {
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling restOrdersDocumentsTypeGet'
            );
        }
        // verify the required parameter 'page' is set
        if ($page === null || (is_array($page) && count($page) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page when calling restOrdersDocumentsTypeGet'
            );
        }
        // verify the required parameter 'items_per_page' is set
        if ($items_per_page === null || (is_array($items_per_page) && count($items_per_page) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $items_per_page when calling restOrdersDocumentsTypeGet'
            );
        }

        $resourcePath = '/rest/orders/documents/{type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($contact_id)) {
            $contact_id = ObjectSerializer::serializeCollection($contact_id, '', true);
        }
        if ($contact_id !== null) {
            $queryParams['contactId'] = $contact_id;
        }
        // query params
        if (is_array($plenty_id)) {
            $plenty_id = ObjectSerializer::serializeCollection($plenty_id, '', true);
        }
        if ($plenty_id !== null) {
            $queryParams['plentyId'] = $plenty_id;
        }
        // query params
        if (is_array($created_at_from)) {
            $created_at_from = ObjectSerializer::serializeCollection($created_at_from, '', true);
        }
        if ($created_at_from !== null) {
            $queryParams['createdAtFrom'] = $created_at_from;
        }
        // query params
        if (is_array($created_at_to)) {
            $created_at_to = ObjectSerializer::serializeCollection($created_at_to, '', true);
        }
        if ($created_at_to !== null) {
            $queryParams['createdAtTo'] = $created_at_to;
        }
        // query params
        if (is_array($updated_at_from)) {
            $updated_at_from = ObjectSerializer::serializeCollection($updated_at_from, '', true);
        }
        if ($updated_at_from !== null) {
            $queryParams['updatedAtFrom'] = $updated_at_from;
        }
        // query params
        if (is_array($updated_at_to)) {
            $updated_at_to = ObjectSerializer::serializeCollection($updated_at_to, '', true);
        }
        if ($updated_at_to !== null) {
            $queryParams['updatedAtTo'] = $updated_at_to;
        }
        // query params
        if (is_array($display_date_from)) {
            $display_date_from = ObjectSerializer::serializeCollection($display_date_from, '', true);
        }
        if ($display_date_from !== null) {
            $queryParams['displayDateFrom'] = $display_date_from;
        }
        // query params
        if (is_array($display_date_to)) {
            $display_date_to = ObjectSerializer::serializeCollection($display_date_to, '', true);
        }
        if ($display_date_to !== null) {
            $queryParams['displayDateTo'] = $display_date_to;
        }
        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }
        // query params
        if (is_array($with_content)) {
            $with_content = ObjectSerializer::serializeCollection($with_content, '', true);
        }
        if ($with_content !== null) {
            $queryParams['withContent'] = $with_content;
        }


        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsCorrectionDocumentGeneratePost
     *
     * Generate adjustment form of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsCorrectionDocumentGeneratePost($order_id, $document_date = null, $comment = null)
    {
        list($response) = $this->restOrdersOrderIdDocumentsCorrectionDocumentGeneratePostWithHttpInfo($order_id, $document_date, $comment);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsCorrectionDocumentGeneratePostWithHttpInfo
     *
     * Generate adjustment form of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsCorrectionDocumentGeneratePostWithHttpInfo($order_id, $document_date = null, $comment = null)
    {
        $request = $this->restOrdersOrderIdDocumentsCorrectionDocumentGeneratePostRequest($order_id, $document_date, $comment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsCorrectionDocumentGeneratePostAsync
     *
     * Generate adjustment form of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsCorrectionDocumentGeneratePostAsync($order_id, $document_date = null, $comment = null)
    {
        return $this->restOrdersOrderIdDocumentsCorrectionDocumentGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsCorrectionDocumentGeneratePostAsyncWithHttpInfo
     *
     * Generate adjustment form of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsCorrectionDocumentGeneratePostAsyncWithHttpInfo($order_id, $document_date = null, $comment = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsCorrectionDocumentGeneratePostRequest($order_id, $document_date, $comment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsCorrectionDocumentGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsCorrectionDocumentGeneratePostRequest($order_id, $document_date = null, $comment = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsCorrectionDocumentGeneratePost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/correction_document/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($document_date)) {
            $document_date = ObjectSerializer::serializeCollection($document_date, '', true);
        }
        if ($document_date !== null) {
            $queryParams['documentDate'] = $document_date;
        }
        // query params
        if (is_array($comment)) {
            $comment = ObjectSerializer::serializeCollection($comment, '', true);
        }
        if ($comment !== null) {
            $queryParams['comment'] = $comment;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsCreditNoteGeneratePost
     *
     * Generate credit note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39; (optional)
     * @param  bool $allow_regenerate If true, existing credit not document without reversal is generated once again. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsCreditNoteGeneratePost($order_id, $document_date = null, $allow_regenerate = null, $comment = null)
    {
        list($response) = $this->restOrdersOrderIdDocumentsCreditNoteGeneratePostWithHttpInfo($order_id, $document_date, $allow_regenerate, $comment);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsCreditNoteGeneratePostWithHttpInfo
     *
     * Generate credit note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39; (optional)
     * @param  bool $allow_regenerate If true, existing credit not document without reversal is generated once again. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsCreditNoteGeneratePostWithHttpInfo($order_id, $document_date = null, $allow_regenerate = null, $comment = null)
    {
        $request = $this->restOrdersOrderIdDocumentsCreditNoteGeneratePostRequest($order_id, $document_date, $allow_regenerate, $comment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsCreditNoteGeneratePostAsync
     *
     * Generate credit note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39; (optional)
     * @param  bool $allow_regenerate If true, existing credit not document without reversal is generated once again. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsCreditNoteGeneratePostAsync($order_id, $document_date = null, $allow_regenerate = null, $comment = null)
    {
        return $this->restOrdersOrderIdDocumentsCreditNoteGeneratePostAsyncWithHttpInfo($order_id, $document_date, $allow_regenerate, $comment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsCreditNoteGeneratePostAsyncWithHttpInfo
     *
     * Generate credit note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39; (optional)
     * @param  bool $allow_regenerate If true, existing credit not document without reversal is generated once again. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsCreditNoteGeneratePostAsyncWithHttpInfo($order_id, $document_date = null, $allow_regenerate = null, $comment = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsCreditNoteGeneratePostRequest($order_id, $document_date, $allow_regenerate, $comment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsCreditNoteGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39; (optional)
     * @param  bool $allow_regenerate If true, existing credit not document without reversal is generated once again. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsCreditNoteGeneratePostRequest($order_id, $document_date = null, $allow_regenerate = null, $comment = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsCreditNoteGeneratePost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/credit_note/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($document_date)) {
            $document_date = ObjectSerializer::serializeCollection($document_date, '', true);
        }
        if ($document_date !== null) {
            $queryParams['documentDate'] = $document_date;
        }
        // query params
        if (is_array($allow_regenerate)) {
            $allow_regenerate = ObjectSerializer::serializeCollection($allow_regenerate, '', true);
        }
        if ($allow_regenerate !== null) {
            $queryParams['allowRegenerate'] = $allow_regenerate;
        }
        // query params
        if (is_array($comment)) {
            $comment = ObjectSerializer::serializeCollection($comment, '', true);
        }
        if ($comment !== null) {
            $queryParams['comment'] = $comment;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsDeliveryNoteGeneratePost
     *
     * Generate delivery note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  int $storehouse_id If set, only items with the given warehouse ID are included on the document. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsDeliveryNoteGeneratePost($order_id, $document_date = null, $comment = null, $storehouse_id = null)
    {
        list($response) = $this->restOrdersOrderIdDocumentsDeliveryNoteGeneratePostWithHttpInfo($order_id, $document_date, $comment, $storehouse_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsDeliveryNoteGeneratePostWithHttpInfo
     *
     * Generate delivery note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  int $storehouse_id If set, only items with the given warehouse ID are included on the document. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsDeliveryNoteGeneratePostWithHttpInfo($order_id, $document_date = null, $comment = null, $storehouse_id = null)
    {
        $request = $this->restOrdersOrderIdDocumentsDeliveryNoteGeneratePostRequest($order_id, $document_date, $comment, $storehouse_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsDeliveryNoteGeneratePostAsync
     *
     * Generate delivery note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  int $storehouse_id If set, only items with the given warehouse ID are included on the document. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsDeliveryNoteGeneratePostAsync($order_id, $document_date = null, $comment = null, $storehouse_id = null)
    {
        return $this->restOrdersOrderIdDocumentsDeliveryNoteGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment, $storehouse_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsDeliveryNoteGeneratePostAsyncWithHttpInfo
     *
     * Generate delivery note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  int $storehouse_id If set, only items with the given warehouse ID are included on the document. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsDeliveryNoteGeneratePostAsyncWithHttpInfo($order_id, $document_date = null, $comment = null, $storehouse_id = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsDeliveryNoteGeneratePostRequest($order_id, $document_date, $comment, $storehouse_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsDeliveryNoteGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  int $storehouse_id If set, only items with the given warehouse ID are included on the document. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsDeliveryNoteGeneratePostRequest($order_id, $document_date = null, $comment = null, $storehouse_id = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsDeliveryNoteGeneratePost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/delivery_note/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($document_date)) {
            $document_date = ObjectSerializer::serializeCollection($document_date, '', true);
        }
        if ($document_date !== null) {
            $queryParams['documentDate'] = $document_date;
        }
        // query params
        if (is_array($comment)) {
            $comment = ObjectSerializer::serializeCollection($comment, '', true);
        }
        if ($comment !== null) {
            $queryParams['comment'] = $comment;
        }
        // query params
        if (is_array($storehouse_id)) {
            $storehouse_id = ObjectSerializer::serializeCollection($storehouse_id, '', true);
        }
        if ($storehouse_id !== null) {
            $queryParams['storehouseId'] = $storehouse_id;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsDocumentIdDelete
     *
     * Delete document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $document_id The ID of the document (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsDocumentIdDelete($order_id, $document_id)
    {
        list($response) = $this->restOrdersOrderIdDocumentsDocumentIdDeleteWithHttpInfo($order_id, $document_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsDocumentIdDeleteWithHttpInfo
     *
     * Delete document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $document_id The ID of the document (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsDocumentIdDeleteWithHttpInfo($order_id, $document_id)
    {
        $request = $this->restOrdersOrderIdDocumentsDocumentIdDeleteRequest($order_id, $document_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsDocumentIdDeleteAsync
     *
     * Delete document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $document_id The ID of the document (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsDocumentIdDeleteAsync($order_id, $document_id)
    {
        return $this->restOrdersOrderIdDocumentsDocumentIdDeleteAsyncWithHttpInfo($order_id, $document_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsDocumentIdDeleteAsyncWithHttpInfo
     *
     * Delete document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $document_id The ID of the document (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsDocumentIdDeleteAsyncWithHttpInfo($order_id, $document_id)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsDocumentIdDeleteRequest($order_id, $document_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsDocumentIdDelete'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $document_id The ID of the document (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsDocumentIdDeleteRequest($order_id, $document_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsDocumentIdDelete'
            );
        }
        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling restOrdersOrderIdDocumentsDocumentIdDelete'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/{documentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'documentId' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsDunningLetterGeneratePost
     *
     * Generate dunning letter of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  int $article_id Add an item to the order. (optional)
     * @param  int $variation_id Add a variation to the order. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsDunningLetterGeneratePost($order_id, $document_date = null, $comment = null, $article_id = null, $variation_id = null)
    {
        list($response) = $this->restOrdersOrderIdDocumentsDunningLetterGeneratePostWithHttpInfo($order_id, $document_date, $comment, $article_id, $variation_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsDunningLetterGeneratePostWithHttpInfo
     *
     * Generate dunning letter of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  int $article_id Add an item to the order. (optional)
     * @param  int $variation_id Add a variation to the order. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsDunningLetterGeneratePostWithHttpInfo($order_id, $document_date = null, $comment = null, $article_id = null, $variation_id = null)
    {
        $request = $this->restOrdersOrderIdDocumentsDunningLetterGeneratePostRequest($order_id, $document_date, $comment, $article_id, $variation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsDunningLetterGeneratePostAsync
     *
     * Generate dunning letter of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  int $article_id Add an item to the order. (optional)
     * @param  int $variation_id Add a variation to the order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsDunningLetterGeneratePostAsync($order_id, $document_date = null, $comment = null, $article_id = null, $variation_id = null)
    {
        return $this->restOrdersOrderIdDocumentsDunningLetterGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment, $article_id, $variation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsDunningLetterGeneratePostAsyncWithHttpInfo
     *
     * Generate dunning letter of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  int $article_id Add an item to the order. (optional)
     * @param  int $variation_id Add a variation to the order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsDunningLetterGeneratePostAsyncWithHttpInfo($order_id, $document_date = null, $comment = null, $article_id = null, $variation_id = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsDunningLetterGeneratePostRequest($order_id, $document_date, $comment, $article_id, $variation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsDunningLetterGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  int $article_id Add an item to the order. (optional)
     * @param  int $variation_id Add a variation to the order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsDunningLetterGeneratePostRequest($order_id, $document_date = null, $comment = null, $article_id = null, $variation_id = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsDunningLetterGeneratePost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/dunning_letter/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($document_date)) {
            $document_date = ObjectSerializer::serializeCollection($document_date, '', true);
        }
        if ($document_date !== null) {
            $queryParams['documentDate'] = $document_date;
        }
        // query params
        if (is_array($comment)) {
            $comment = ObjectSerializer::serializeCollection($comment, '', true);
        }
        if ($comment !== null) {
            $queryParams['comment'] = $comment;
        }
        // query params
        if (is_array($article_id)) {
            $article_id = ObjectSerializer::serializeCollection($article_id, '', true);
        }
        if ($article_id !== null) {
            $queryParams['articleId'] = $article_id;
        }
        // query params
        if (is_array($variation_id)) {
            $variation_id = ObjectSerializer::serializeCollection($variation_id, '', true);
        }
        if ($variation_id !== null) {
            $queryParams['variationId'] = $variation_id;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsInvoiceGeneratePost
     *
     * Generate invoice of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  bool $allow_regenerate If true, existing invoice document without reversal is generated once again. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  bool $valuta If true, valuta is enabled. (optional)
     * @param  bool $discount If true, discount is enabled for the document. (optional)
     * @param  int $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool $payment_due If true, payment due is enabled. (optional)
     * @param  int $payment_due_days Overwrite payment due in days. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsInvoiceGeneratePost($order_id, $document_date = null, $allow_regenerate = null, $comment = null, $valuta = null, $discount = null, $discount_percentage = null, $discount_days = null, $payment_due = null, $payment_due_days = null)
    {
        list($response) = $this->restOrdersOrderIdDocumentsInvoiceGeneratePostWithHttpInfo($order_id, $document_date, $allow_regenerate, $comment, $valuta, $discount, $discount_percentage, $discount_days, $payment_due, $payment_due_days);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsInvoiceGeneratePostWithHttpInfo
     *
     * Generate invoice of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  bool $allow_regenerate If true, existing invoice document without reversal is generated once again. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  bool $valuta If true, valuta is enabled. (optional)
     * @param  bool $discount If true, discount is enabled for the document. (optional)
     * @param  int $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool $payment_due If true, payment due is enabled. (optional)
     * @param  int $payment_due_days Overwrite payment due in days. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsInvoiceGeneratePostWithHttpInfo($order_id, $document_date = null, $allow_regenerate = null, $comment = null, $valuta = null, $discount = null, $discount_percentage = null, $discount_days = null, $payment_due = null, $payment_due_days = null)
    {
        $request = $this->restOrdersOrderIdDocumentsInvoiceGeneratePostRequest($order_id, $document_date, $allow_regenerate, $comment, $valuta, $discount, $discount_percentage, $discount_days, $payment_due, $payment_due_days);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsInvoiceGeneratePostAsync
     *
     * Generate invoice of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  bool $allow_regenerate If true, existing invoice document without reversal is generated once again. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  bool $valuta If true, valuta is enabled. (optional)
     * @param  bool $discount If true, discount is enabled for the document. (optional)
     * @param  int $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool $payment_due If true, payment due is enabled. (optional)
     * @param  int $payment_due_days Overwrite payment due in days. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsInvoiceGeneratePostAsync($order_id, $document_date = null, $allow_regenerate = null, $comment = null, $valuta = null, $discount = null, $discount_percentage = null, $discount_days = null, $payment_due = null, $payment_due_days = null)
    {
        return $this->restOrdersOrderIdDocumentsInvoiceGeneratePostAsyncWithHttpInfo($order_id, $document_date, $allow_regenerate, $comment, $valuta, $discount, $discount_percentage, $discount_days, $payment_due, $payment_due_days)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsInvoiceGeneratePostAsyncWithHttpInfo
     *
     * Generate invoice of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  bool $allow_regenerate If true, existing invoice document without reversal is generated once again. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  bool $valuta If true, valuta is enabled. (optional)
     * @param  bool $discount If true, discount is enabled for the document. (optional)
     * @param  int $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool $payment_due If true, payment due is enabled. (optional)
     * @param  int $payment_due_days Overwrite payment due in days. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsInvoiceGeneratePostAsyncWithHttpInfo($order_id, $document_date = null, $allow_regenerate = null, $comment = null, $valuta = null, $discount = null, $discount_percentage = null, $discount_days = null, $payment_due = null, $payment_due_days = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsInvoiceGeneratePostRequest($order_id, $document_date, $allow_regenerate, $comment, $valuta, $discount, $discount_percentage, $discount_days, $payment_due, $payment_due_days);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsInvoiceGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  bool $allow_regenerate If true, existing invoice document without reversal is generated once again. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  bool $valuta If true, valuta is enabled. (optional)
     * @param  bool $discount If true, discount is enabled for the document. (optional)
     * @param  int $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool $payment_due If true, payment due is enabled. (optional)
     * @param  int $payment_due_days Overwrite payment due in days. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsInvoiceGeneratePostRequest($order_id, $document_date = null, $allow_regenerate = null, $comment = null, $valuta = null, $discount = null, $discount_percentage = null, $discount_days = null, $payment_due = null, $payment_due_days = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsInvoiceGeneratePost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/invoice/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($document_date)) {
            $document_date = ObjectSerializer::serializeCollection($document_date, '', true);
        }
        if ($document_date !== null) {
            $queryParams['documentDate'] = $document_date;
        }
        // query params
        if (is_array($allow_regenerate)) {
            $allow_regenerate = ObjectSerializer::serializeCollection($allow_regenerate, '', true);
        }
        if ($allow_regenerate !== null) {
            $queryParams['allowRegenerate'] = $allow_regenerate;
        }
        // query params
        if (is_array($comment)) {
            $comment = ObjectSerializer::serializeCollection($comment, '', true);
        }
        if ($comment !== null) {
            $queryParams['comment'] = $comment;
        }
        // query params
        if (is_array($valuta)) {
            $valuta = ObjectSerializer::serializeCollection($valuta, '', true);
        }
        if ($valuta !== null) {
            $queryParams['valuta'] = $valuta;
        }
        // query params
        if (is_array($discount)) {
            $discount = ObjectSerializer::serializeCollection($discount, '', true);
        }
        if ($discount !== null) {
            $queryParams['discount'] = $discount;
        }
        // query params
        if (is_array($discount_percentage)) {
            $discount_percentage = ObjectSerializer::serializeCollection($discount_percentage, '', true);
        }
        if ($discount_percentage !== null) {
            $queryParams['discountPercentage'] = $discount_percentage;
        }
        // query params
        if (is_array($discount_days)) {
            $discount_days = ObjectSerializer::serializeCollection($discount_days, '', true);
        }
        if ($discount_days !== null) {
            $queryParams['discountDays'] = $discount_days;
        }
        // query params
        if (is_array($payment_due)) {
            $payment_due = ObjectSerializer::serializeCollection($payment_due, '', true);
        }
        if ($payment_due !== null) {
            $queryParams['paymentDue'] = $payment_due;
        }
        // query params
        if (is_array($payment_due_days)) {
            $payment_due_days = ObjectSerializer::serializeCollection($payment_due_days, '', true);
        }
        if ($payment_due_days !== null) {
            $queryParams['paymentDueDays'] = $payment_due_days;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsOfferGeneratePost
     *
     * Generate offer document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsOfferGeneratePost($order_id, $document_date = null, $comment = null)
    {
        list($response) = $this->restOrdersOrderIdDocumentsOfferGeneratePostWithHttpInfo($order_id, $document_date, $comment);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsOfferGeneratePostWithHttpInfo
     *
     * Generate offer document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsOfferGeneratePostWithHttpInfo($order_id, $document_date = null, $comment = null)
    {
        $request = $this->restOrdersOrderIdDocumentsOfferGeneratePostRequest($order_id, $document_date, $comment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsOfferGeneratePostAsync
     *
     * Generate offer document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsOfferGeneratePostAsync($order_id, $document_date = null, $comment = null)
    {
        return $this->restOrdersOrderIdDocumentsOfferGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsOfferGeneratePostAsyncWithHttpInfo
     *
     * Generate offer document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsOfferGeneratePostAsyncWithHttpInfo($order_id, $document_date = null, $comment = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsOfferGeneratePostRequest($order_id, $document_date, $comment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsOfferGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsOfferGeneratePostRequest($order_id, $document_date = null, $comment = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsOfferGeneratePost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/offer/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($document_date)) {
            $document_date = ObjectSerializer::serializeCollection($document_date, '', true);
        }
        if ($document_date !== null) {
            $queryParams['documentDate'] = $document_date;
        }
        // query params
        if (is_array($comment)) {
            $comment = ObjectSerializer::serializeCollection($comment, '', true);
        }
        if ($comment !== null) {
            $queryParams['comment'] = $comment;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsOrderConfirmationGeneratePost
     *
     * Generate order confirmation of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  bool $valuta If true, valuta is enabled. (optional)
     * @param  bool $discount If true, discount is enabled for the document. (optional)
     * @param  int $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool $payment_due If true, payment due is enabled. (optional)
     * @param  int $payment_due_days Overwrite payment due in days. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsOrderConfirmationGeneratePost($order_id, $document_date = null, $comment = null, $valuta = null, $discount = null, $discount_percentage = null, $discount_days = null, $payment_due = null, $payment_due_days = null)
    {
        list($response) = $this->restOrdersOrderIdDocumentsOrderConfirmationGeneratePostWithHttpInfo($order_id, $document_date, $comment, $valuta, $discount, $discount_percentage, $discount_days, $payment_due, $payment_due_days);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsOrderConfirmationGeneratePostWithHttpInfo
     *
     * Generate order confirmation of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  bool $valuta If true, valuta is enabled. (optional)
     * @param  bool $discount If true, discount is enabled for the document. (optional)
     * @param  int $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool $payment_due If true, payment due is enabled. (optional)
     * @param  int $payment_due_days Overwrite payment due in days. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsOrderConfirmationGeneratePostWithHttpInfo($order_id, $document_date = null, $comment = null, $valuta = null, $discount = null, $discount_percentage = null, $discount_days = null, $payment_due = null, $payment_due_days = null)
    {
        $request = $this->restOrdersOrderIdDocumentsOrderConfirmationGeneratePostRequest($order_id, $document_date, $comment, $valuta, $discount, $discount_percentage, $discount_days, $payment_due, $payment_due_days);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsOrderConfirmationGeneratePostAsync
     *
     * Generate order confirmation of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  bool $valuta If true, valuta is enabled. (optional)
     * @param  bool $discount If true, discount is enabled for the document. (optional)
     * @param  int $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool $payment_due If true, payment due is enabled. (optional)
     * @param  int $payment_due_days Overwrite payment due in days. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsOrderConfirmationGeneratePostAsync($order_id, $document_date = null, $comment = null, $valuta = null, $discount = null, $discount_percentage = null, $discount_days = null, $payment_due = null, $payment_due_days = null)
    {
        return $this->restOrdersOrderIdDocumentsOrderConfirmationGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment, $valuta, $discount, $discount_percentage, $discount_days, $payment_due, $payment_due_days)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsOrderConfirmationGeneratePostAsyncWithHttpInfo
     *
     * Generate order confirmation of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  bool $valuta If true, valuta is enabled. (optional)
     * @param  bool $discount If true, discount is enabled for the document. (optional)
     * @param  int $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool $payment_due If true, payment due is enabled. (optional)
     * @param  int $payment_due_days Overwrite payment due in days. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsOrderConfirmationGeneratePostAsyncWithHttpInfo($order_id, $document_date = null, $comment = null, $valuta = null, $discount = null, $discount_percentage = null, $discount_days = null, $payment_due = null, $payment_due_days = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsOrderConfirmationGeneratePostRequest($order_id, $document_date, $comment, $valuta, $discount, $discount_percentage, $discount_days, $payment_due, $payment_due_days);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsOrderConfirmationGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  bool $valuta If true, valuta is enabled. (optional)
     * @param  bool $discount If true, discount is enabled for the document. (optional)
     * @param  int $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool $payment_due If true, payment due is enabled. (optional)
     * @param  int $payment_due_days Overwrite payment due in days. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsOrderConfirmationGeneratePostRequest($order_id, $document_date = null, $comment = null, $valuta = null, $discount = null, $discount_percentage = null, $discount_days = null, $payment_due = null, $payment_due_days = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsOrderConfirmationGeneratePost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/order_confirmation/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($document_date)) {
            $document_date = ObjectSerializer::serializeCollection($document_date, '', true);
        }
        if ($document_date !== null) {
            $queryParams['documentDate'] = $document_date;
        }
        // query params
        if (is_array($comment)) {
            $comment = ObjectSerializer::serializeCollection($comment, '', true);
        }
        if ($comment !== null) {
            $queryParams['comment'] = $comment;
        }
        // query params
        if (is_array($valuta)) {
            $valuta = ObjectSerializer::serializeCollection($valuta, '', true);
        }
        if ($valuta !== null) {
            $queryParams['valuta'] = $valuta;
        }
        // query params
        if (is_array($discount)) {
            $discount = ObjectSerializer::serializeCollection($discount, '', true);
        }
        if ($discount !== null) {
            $queryParams['discount'] = $discount;
        }
        // query params
        if (is_array($discount_percentage)) {
            $discount_percentage = ObjectSerializer::serializeCollection($discount_percentage, '', true);
        }
        if ($discount_percentage !== null) {
            $queryParams['discountPercentage'] = $discount_percentage;
        }
        // query params
        if (is_array($discount_days)) {
            $discount_days = ObjectSerializer::serializeCollection($discount_days, '', true);
        }
        if ($discount_days !== null) {
            $queryParams['discountDays'] = $discount_days;
        }
        // query params
        if (is_array($payment_due)) {
            $payment_due = ObjectSerializer::serializeCollection($payment_due, '', true);
        }
        if ($payment_due !== null) {
            $queryParams['paymentDue'] = $payment_due;
        }
        // query params
        if (is_array($payment_due_days)) {
            $payment_due_days = ObjectSerializer::serializeCollection($payment_due_days, '', true);
        }
        if ($payment_due_days !== null) {
            $queryParams['paymentDueDays'] = $payment_due_days;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsPickupDeliveryGeneratePost
     *
     * Generate pick-up delivery note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsPickupDeliveryGeneratePost($order_id, $document_date = null, $comment = null)
    {
        list($response) = $this->restOrdersOrderIdDocumentsPickupDeliveryGeneratePostWithHttpInfo($order_id, $document_date, $comment);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsPickupDeliveryGeneratePostWithHttpInfo
     *
     * Generate pick-up delivery note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsPickupDeliveryGeneratePostWithHttpInfo($order_id, $document_date = null, $comment = null)
    {
        $request = $this->restOrdersOrderIdDocumentsPickupDeliveryGeneratePostRequest($order_id, $document_date, $comment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsPickupDeliveryGeneratePostAsync
     *
     * Generate pick-up delivery note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsPickupDeliveryGeneratePostAsync($order_id, $document_date = null, $comment = null)
    {
        return $this->restOrdersOrderIdDocumentsPickupDeliveryGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsPickupDeliveryGeneratePostAsyncWithHttpInfo
     *
     * Generate pick-up delivery note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsPickupDeliveryGeneratePostAsyncWithHttpInfo($order_id, $document_date = null, $comment = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsPickupDeliveryGeneratePostRequest($order_id, $document_date, $comment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsPickupDeliveryGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsPickupDeliveryGeneratePostRequest($order_id, $document_date = null, $comment = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsPickupDeliveryGeneratePost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/pickup_delivery/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($document_date)) {
            $document_date = ObjectSerializer::serializeCollection($document_date, '', true);
        }
        if ($document_date !== null) {
            $queryParams['documentDate'] = $document_date;
        }
        // query params
        if (is_array($comment)) {
            $comment = ObjectSerializer::serializeCollection($comment, '', true);
        }
        if ($comment !== null) {
            $queryParams['comment'] = $comment;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePost
     *
     * Generate purchase order (PO) delivery note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePost($order_id, $document_date = null)
    {
        list($response) = $this->restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePostWithHttpInfo($order_id, $document_date);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePostWithHttpInfo
     *
     * Generate purchase order (PO) delivery note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePostWithHttpInfo($order_id, $document_date = null)
    {
        $request = $this->restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePostRequest($order_id, $document_date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePostAsync
     *
     * Generate purchase order (PO) delivery note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePostAsync($order_id, $document_date = null)
    {
        return $this->restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePostAsyncWithHttpInfo($order_id, $document_date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePostAsyncWithHttpInfo
     *
     * Generate purchase order (PO) delivery note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePostAsyncWithHttpInfo($order_id, $document_date = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePostRequest($order_id, $document_date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePostRequest($order_id, $document_date = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/po_delivery_note/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($document_date)) {
            $document_date = ObjectSerializer::serializeCollection($document_date, '', true);
        }
        if ($document_date !== null) {
            $queryParams['documentDate'] = $document_date;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsProFormaInvoiceGeneratePost
     *
     * Generate pro forma invoice of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  bool $valuta If true, valuta is enabled. (optional)
     * @param  bool $discount If true, discount is enabled for the document. (optional)
     * @param  int $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool $payment_due If true, payment due is enabled. (optional)
     * @param  int $payment_due_days Overwrite payment due in days. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsProFormaInvoiceGeneratePost($order_id, $document_date = null, $comment = null, $valuta = null, $discount = null, $discount_percentage = null, $discount_days = null, $payment_due = null, $payment_due_days = null)
    {
        list($response) = $this->restOrdersOrderIdDocumentsProFormaInvoiceGeneratePostWithHttpInfo($order_id, $document_date, $comment, $valuta, $discount, $discount_percentage, $discount_days, $payment_due, $payment_due_days);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsProFormaInvoiceGeneratePostWithHttpInfo
     *
     * Generate pro forma invoice of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  bool $valuta If true, valuta is enabled. (optional)
     * @param  bool $discount If true, discount is enabled for the document. (optional)
     * @param  int $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool $payment_due If true, payment due is enabled. (optional)
     * @param  int $payment_due_days Overwrite payment due in days. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsProFormaInvoiceGeneratePostWithHttpInfo($order_id, $document_date = null, $comment = null, $valuta = null, $discount = null, $discount_percentage = null, $discount_days = null, $payment_due = null, $payment_due_days = null)
    {
        $request = $this->restOrdersOrderIdDocumentsProFormaInvoiceGeneratePostRequest($order_id, $document_date, $comment, $valuta, $discount, $discount_percentage, $discount_days, $payment_due, $payment_due_days);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsProFormaInvoiceGeneratePostAsync
     *
     * Generate pro forma invoice of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  bool $valuta If true, valuta is enabled. (optional)
     * @param  bool $discount If true, discount is enabled for the document. (optional)
     * @param  int $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool $payment_due If true, payment due is enabled. (optional)
     * @param  int $payment_due_days Overwrite payment due in days. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsProFormaInvoiceGeneratePostAsync($order_id, $document_date = null, $comment = null, $valuta = null, $discount = null, $discount_percentage = null, $discount_days = null, $payment_due = null, $payment_due_days = null)
    {
        return $this->restOrdersOrderIdDocumentsProFormaInvoiceGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment, $valuta, $discount, $discount_percentage, $discount_days, $payment_due, $payment_due_days)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsProFormaInvoiceGeneratePostAsyncWithHttpInfo
     *
     * Generate pro forma invoice of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  bool $valuta If true, valuta is enabled. (optional)
     * @param  bool $discount If true, discount is enabled for the document. (optional)
     * @param  int $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool $payment_due If true, payment due is enabled. (optional)
     * @param  int $payment_due_days Overwrite payment due in days. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsProFormaInvoiceGeneratePostAsyncWithHttpInfo($order_id, $document_date = null, $comment = null, $valuta = null, $discount = null, $discount_percentage = null, $discount_days = null, $payment_due = null, $payment_due_days = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsProFormaInvoiceGeneratePostRequest($order_id, $document_date, $comment, $valuta, $discount, $discount_percentage, $discount_days, $payment_due, $payment_due_days);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsProFormaInvoiceGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     * @param  bool $valuta If true, valuta is enabled. (optional)
     * @param  bool $discount If true, discount is enabled for the document. (optional)
     * @param  int $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool $payment_due If true, payment due is enabled. (optional)
     * @param  int $payment_due_days Overwrite payment due in days. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsProFormaInvoiceGeneratePostRequest($order_id, $document_date = null, $comment = null, $valuta = null, $discount = null, $discount_percentage = null, $discount_days = null, $payment_due = null, $payment_due_days = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsProFormaInvoiceGeneratePost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/pro_forma_invoice/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($document_date)) {
            $document_date = ObjectSerializer::serializeCollection($document_date, '', true);
        }
        if ($document_date !== null) {
            $queryParams['documentDate'] = $document_date;
        }
        // query params
        if (is_array($comment)) {
            $comment = ObjectSerializer::serializeCollection($comment, '', true);
        }
        if ($comment !== null) {
            $queryParams['comment'] = $comment;
        }
        // query params
        if (is_array($valuta)) {
            $valuta = ObjectSerializer::serializeCollection($valuta, '', true);
        }
        if ($valuta !== null) {
            $queryParams['valuta'] = $valuta;
        }
        // query params
        if (is_array($discount)) {
            $discount = ObjectSerializer::serializeCollection($discount, '', true);
        }
        if ($discount !== null) {
            $queryParams['discount'] = $discount;
        }
        // query params
        if (is_array($discount_percentage)) {
            $discount_percentage = ObjectSerializer::serializeCollection($discount_percentage, '', true);
        }
        if ($discount_percentage !== null) {
            $queryParams['discountPercentage'] = $discount_percentage;
        }
        // query params
        if (is_array($discount_days)) {
            $discount_days = ObjectSerializer::serializeCollection($discount_days, '', true);
        }
        if ($discount_days !== null) {
            $queryParams['discountDays'] = $discount_days;
        }
        // query params
        if (is_array($payment_due)) {
            $payment_due = ObjectSerializer::serializeCollection($payment_due, '', true);
        }
        if ($payment_due !== null) {
            $queryParams['paymentDue'] = $payment_due;
        }
        // query params
        if (is_array($payment_due_days)) {
            $payment_due_days = ObjectSerializer::serializeCollection($payment_due_days, '', true);
        }
        if ($payment_due_days !== null) {
            $queryParams['paymentDueDays'] = $payment_due_days;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsReorderGeneratePost
     *
     * Generate reorder document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  bool $allow_regenerate If true, existing reorder document is generated once again. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsReorderGeneratePost($order_id, $allow_regenerate = null, $comment = null)
    {
        list($response) = $this->restOrdersOrderIdDocumentsReorderGeneratePostWithHttpInfo($order_id, $allow_regenerate, $comment);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsReorderGeneratePostWithHttpInfo
     *
     * Generate reorder document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  bool $allow_regenerate If true, existing reorder document is generated once again. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsReorderGeneratePostWithHttpInfo($order_id, $allow_regenerate = null, $comment = null)
    {
        $request = $this->restOrdersOrderIdDocumentsReorderGeneratePostRequest($order_id, $allow_regenerate, $comment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsReorderGeneratePostAsync
     *
     * Generate reorder document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  bool $allow_regenerate If true, existing reorder document is generated once again. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsReorderGeneratePostAsync($order_id, $allow_regenerate = null, $comment = null)
    {
        return $this->restOrdersOrderIdDocumentsReorderGeneratePostAsyncWithHttpInfo($order_id, $allow_regenerate, $comment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsReorderGeneratePostAsyncWithHttpInfo
     *
     * Generate reorder document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  bool $allow_regenerate If true, existing reorder document is generated once again. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsReorderGeneratePostAsyncWithHttpInfo($order_id, $allow_regenerate = null, $comment = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsReorderGeneratePostRequest($order_id, $allow_regenerate, $comment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsReorderGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  bool $allow_regenerate If true, existing reorder document is generated once again. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsReorderGeneratePostRequest($order_id, $allow_regenerate = null, $comment = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsReorderGeneratePost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/reorder/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($allow_regenerate)) {
            $allow_regenerate = ObjectSerializer::serializeCollection($allow_regenerate, '', true);
        }
        if ($allow_regenerate !== null) {
            $queryParams['allowRegenerate'] = $allow_regenerate;
        }
        // query params
        if (is_array($comment)) {
            $comment = ObjectSerializer::serializeCollection($comment, '', true);
        }
        if ($comment !== null) {
            $queryParams['comment'] = $comment;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsRepairBillGeneratePost
     *
     * Generate repair slip of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsRepairBillGeneratePost($order_id, $document_date = null, $comment = null)
    {
        list($response) = $this->restOrdersOrderIdDocumentsRepairBillGeneratePostWithHttpInfo($order_id, $document_date, $comment);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsRepairBillGeneratePostWithHttpInfo
     *
     * Generate repair slip of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsRepairBillGeneratePostWithHttpInfo($order_id, $document_date = null, $comment = null)
    {
        $request = $this->restOrdersOrderIdDocumentsRepairBillGeneratePostRequest($order_id, $document_date, $comment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsRepairBillGeneratePostAsync
     *
     * Generate repair slip of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsRepairBillGeneratePostAsync($order_id, $document_date = null, $comment = null)
    {
        return $this->restOrdersOrderIdDocumentsRepairBillGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsRepairBillGeneratePostAsyncWithHttpInfo
     *
     * Generate repair slip of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsRepairBillGeneratePostAsyncWithHttpInfo($order_id, $document_date = null, $comment = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsRepairBillGeneratePostRequest($order_id, $document_date, $comment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsRepairBillGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsRepairBillGeneratePostRequest($order_id, $document_date = null, $comment = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsRepairBillGeneratePost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/repair_bill/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($document_date)) {
            $document_date = ObjectSerializer::serializeCollection($document_date, '', true);
        }
        if ($document_date !== null) {
            $queryParams['documentDate'] = $document_date;
        }
        // query params
        if (is_array($comment)) {
            $comment = ObjectSerializer::serializeCollection($comment, '', true);
        }
        if ($comment !== null) {
            $queryParams['comment'] = $comment;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsReturnNoteGeneratePost
     *
     * Generate return slip of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsReturnNoteGeneratePost($order_id, $document_date = null, $comment = null)
    {
        list($response) = $this->restOrdersOrderIdDocumentsReturnNoteGeneratePostWithHttpInfo($order_id, $document_date, $comment);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsReturnNoteGeneratePostWithHttpInfo
     *
     * Generate return slip of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsReturnNoteGeneratePostWithHttpInfo($order_id, $document_date = null, $comment = null)
    {
        $request = $this->restOrdersOrderIdDocumentsReturnNoteGeneratePostRequest($order_id, $document_date, $comment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsReturnNoteGeneratePostAsync
     *
     * Generate return slip of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsReturnNoteGeneratePostAsync($order_id, $document_date = null, $comment = null)
    {
        return $this->restOrdersOrderIdDocumentsReturnNoteGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsReturnNoteGeneratePostAsyncWithHttpInfo
     *
     * Generate return slip of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsReturnNoteGeneratePostAsyncWithHttpInfo($order_id, $document_date = null, $comment = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsReturnNoteGeneratePostRequest($order_id, $document_date, $comment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsReturnNoteGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsReturnNoteGeneratePostRequest($order_id, $document_date = null, $comment = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsReturnNoteGeneratePost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/return_note/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($document_date)) {
            $document_date = ObjectSerializer::serializeCollection($document_date, '', true);
        }
        if ($document_date !== null) {
            $queryParams['documentDate'] = $document_date;
        }
        // query params
        if (is_array($comment)) {
            $comment = ObjectSerializer::serializeCollection($comment, '', true);
        }
        if ($comment !== null) {
            $queryParams['comment'] = $comment;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsReversalDocumentGeneratePost
     *
     * Generate reversal document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsReversalDocumentGeneratePost($order_id, $document_date = null, $comment = null)
    {
        list($response) = $this->restOrdersOrderIdDocumentsReversalDocumentGeneratePostWithHttpInfo($order_id, $document_date, $comment);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsReversalDocumentGeneratePostWithHttpInfo
     *
     * Generate reversal document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsReversalDocumentGeneratePostWithHttpInfo($order_id, $document_date = null, $comment = null)
    {
        $request = $this->restOrdersOrderIdDocumentsReversalDocumentGeneratePostRequest($order_id, $document_date, $comment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsReversalDocumentGeneratePostAsync
     *
     * Generate reversal document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsReversalDocumentGeneratePostAsync($order_id, $document_date = null, $comment = null)
    {
        return $this->restOrdersOrderIdDocumentsReversalDocumentGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsReversalDocumentGeneratePostAsyncWithHttpInfo
     *
     * Generate reversal document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsReversalDocumentGeneratePostAsyncWithHttpInfo($order_id, $document_date = null, $comment = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsReversalDocumentGeneratePostRequest($order_id, $document_date, $comment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsReversalDocumentGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsReversalDocumentGeneratePostRequest($order_id, $document_date = null, $comment = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsReversalDocumentGeneratePost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/reversal_document/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($document_date)) {
            $document_date = ObjectSerializer::serializeCollection($document_date, '', true);
        }
        if ($document_date !== null) {
            $queryParams['documentDate'] = $document_date;
        }
        // query params
        if (is_array($comment)) {
            $comment = ObjectSerializer::serializeCollection($comment, '', true);
        }
        if ($comment !== null) {
            $queryParams['comment'] = $comment;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsReversalDunningLetterGeneratePost
     *
     * Generate dunning letter reversal document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsReversalDunningLetterGeneratePost($order_id, $document_date = null, $comment = null)
    {
        list($response) = $this->restOrdersOrderIdDocumentsReversalDunningLetterGeneratePostWithHttpInfo($order_id, $document_date, $comment);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsReversalDunningLetterGeneratePostWithHttpInfo
     *
     * Generate dunning letter reversal document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsReversalDunningLetterGeneratePostWithHttpInfo($order_id, $document_date = null, $comment = null)
    {
        $request = $this->restOrdersOrderIdDocumentsReversalDunningLetterGeneratePostRequest($order_id, $document_date, $comment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsReversalDunningLetterGeneratePostAsync
     *
     * Generate dunning letter reversal document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsReversalDunningLetterGeneratePostAsync($order_id, $document_date = null, $comment = null)
    {
        return $this->restOrdersOrderIdDocumentsReversalDunningLetterGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsReversalDunningLetterGeneratePostAsyncWithHttpInfo
     *
     * Generate dunning letter reversal document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsReversalDunningLetterGeneratePostAsyncWithHttpInfo($order_id, $document_date = null, $comment = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsReversalDunningLetterGeneratePostRequest($order_id, $document_date, $comment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsReversalDunningLetterGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsReversalDunningLetterGeneratePostRequest($order_id, $document_date = null, $comment = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsReversalDunningLetterGeneratePost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/reversal_dunning_letter/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($document_date)) {
            $document_date = ObjectSerializer::serializeCollection($document_date, '', true);
        }
        if ($document_date !== null) {
            $queryParams['documentDate'] = $document_date;
        }
        // query params
        if (is_array($comment)) {
            $comment = ObjectSerializer::serializeCollection($comment, '', true);
        }
        if ($comment !== null) {
            $queryParams['comment'] = $comment;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsReversalRefundGeneratePost
     *
     * Generate refund reversal document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsReversalRefundGeneratePost($order_id, $document_date = null, $comment = null)
    {
        list($response) = $this->restOrdersOrderIdDocumentsReversalRefundGeneratePostWithHttpInfo($order_id, $document_date, $comment);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsReversalRefundGeneratePostWithHttpInfo
     *
     * Generate refund reversal document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsReversalRefundGeneratePostWithHttpInfo($order_id, $document_date = null, $comment = null)
    {
        $request = $this->restOrdersOrderIdDocumentsReversalRefundGeneratePostRequest($order_id, $document_date, $comment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsReversalRefundGeneratePostAsync
     *
     * Generate refund reversal document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsReversalRefundGeneratePostAsync($order_id, $document_date = null, $comment = null)
    {
        return $this->restOrdersOrderIdDocumentsReversalRefundGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsReversalRefundGeneratePostAsyncWithHttpInfo
     *
     * Generate refund reversal document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsReversalRefundGeneratePostAsyncWithHttpInfo($order_id, $document_date = null, $comment = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsReversalRefundGeneratePostRequest($order_id, $document_date, $comment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsReversalRefundGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsReversalRefundGeneratePostRequest($order_id, $document_date = null, $comment = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsReversalRefundGeneratePost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/reversal_refund/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($document_date)) {
            $document_date = ObjectSerializer::serializeCollection($document_date, '', true);
        }
        if ($document_date !== null) {
            $queryParams['documentDate'] = $document_date;
        }
        // query params
        if (is_array($comment)) {
            $comment = ObjectSerializer::serializeCollection($comment, '', true);
        }
        if ($comment !== null) {
            $queryParams['comment'] = $comment;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsSuccessConfirmationGeneratePost
     *
     * Generate success confirmation of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsSuccessConfirmationGeneratePost($order_id, $document_date = null, $comment = null)
    {
        list($response) = $this->restOrdersOrderIdDocumentsSuccessConfirmationGeneratePostWithHttpInfo($order_id, $document_date, $comment);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsSuccessConfirmationGeneratePostWithHttpInfo
     *
     * Generate success confirmation of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsSuccessConfirmationGeneratePostWithHttpInfo($order_id, $document_date = null, $comment = null)
    {
        $request = $this->restOrdersOrderIdDocumentsSuccessConfirmationGeneratePostRequest($order_id, $document_date, $comment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsSuccessConfirmationGeneratePostAsync
     *
     * Generate success confirmation of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsSuccessConfirmationGeneratePostAsync($order_id, $document_date = null, $comment = null)
    {
        return $this->restOrdersOrderIdDocumentsSuccessConfirmationGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsSuccessConfirmationGeneratePostAsyncWithHttpInfo
     *
     * Generate success confirmation of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsSuccessConfirmationGeneratePostAsyncWithHttpInfo($order_id, $document_date = null, $comment = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsSuccessConfirmationGeneratePostRequest($order_id, $document_date, $comment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsSuccessConfirmationGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $comment Comment that appears below the stock units. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsSuccessConfirmationGeneratePostRequest($order_id, $document_date = null, $comment = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsSuccessConfirmationGeneratePost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/success_confirmation/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($document_date)) {
            $document_date = ObjectSerializer::serializeCollection($document_date, '', true);
        }
        if ($document_date !== null) {
            $queryParams['documentDate'] = $document_date;
        }
        // query params
        if (is_array($comment)) {
            $comment = ObjectSerializer::serializeCollection($comment, '', true);
        }
        if ($comment !== null) {
            $queryParams['comment'] = $comment;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeCurrentGet
     *
     * Get current invoice or credit note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order document. The available types are invoice, creditNote, dunningLetter (required)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Document
     */
    public function restOrdersOrderIdDocumentsTypeCurrentGet($order_id, $type, $with_content = null)
    {
        list($response) = $this->restOrdersOrderIdDocumentsTypeCurrentGetWithHttpInfo($order_id, $type, $with_content);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeCurrentGetWithHttpInfo
     *
     * Get current invoice or credit note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order document. The available types are invoice, creditNote, dunningLetter (required)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Document, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsTypeCurrentGetWithHttpInfo($order_id, $type, $with_content = null)
    {
        $request = $this->restOrdersOrderIdDocumentsTypeCurrentGetRequest($order_id, $type, $with_content);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Document' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Document', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Document';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeCurrentGetAsync
     *
     * Get current invoice or credit note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order document. The available types are invoice, creditNote, dunningLetter (required)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsTypeCurrentGetAsync($order_id, $type, $with_content = null)
    {
        return $this->restOrdersOrderIdDocumentsTypeCurrentGetAsyncWithHttpInfo($order_id, $type, $with_content)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeCurrentGetAsyncWithHttpInfo
     *
     * Get current invoice or credit note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order document. The available types are invoice, creditNote, dunningLetter (required)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsTypeCurrentGetAsyncWithHttpInfo($order_id, $type, $with_content = null)
    {
        $returnType = '\OpenAPI\Client\Model\Document';
        $request = $this->restOrdersOrderIdDocumentsTypeCurrentGetRequest($order_id, $type, $with_content);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsTypeCurrentGet'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order document. The available types are invoice, creditNote, dunningLetter (required)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsTypeCurrentGetRequest($order_id, $type, $with_content = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsTypeCurrentGet'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling restOrdersOrderIdDocumentsTypeCurrentGet'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/{type}/current';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($with_content)) {
            $with_content = ObjectSerializer::serializeCollection($with_content, '', true);
        }
        if ($with_content !== null) {
            $queryParams['withContent'] = $with_content;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeGeneratePost
     *
     * Generate document of an order
     *
     * @param  int $order_id order_id (required)
     * @param  int $type type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsTypeGeneratePost($order_id, $type)
    {
        list($response) = $this->restOrdersOrderIdDocumentsTypeGeneratePostWithHttpInfo($order_id, $type);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeGeneratePostWithHttpInfo
     *
     * Generate document of an order
     *
     * @param  int $order_id (required)
     * @param  int $type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsTypeGeneratePostWithHttpInfo($order_id, $type)
    {
        $request = $this->restOrdersOrderIdDocumentsTypeGeneratePostRequest($order_id, $type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeGeneratePostAsync
     *
     * Generate document of an order
     *
     * @param  int $order_id (required)
     * @param  int $type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsTypeGeneratePostAsync($order_id, $type)
    {
        return $this->restOrdersOrderIdDocumentsTypeGeneratePostAsyncWithHttpInfo($order_id, $type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeGeneratePostAsyncWithHttpInfo
     *
     * Generate document of an order
     *
     * @param  int $order_id (required)
     * @param  int $type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsTypeGeneratePostAsyncWithHttpInfo($order_id, $type)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsTypeGeneratePostRequest($order_id, $type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsTypeGeneratePost'
     *
     * @param  int $order_id (required)
     * @param  int $type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsTypeGeneratePostRequest($order_id, $type)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsTypeGeneratePost'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling restOrdersOrderIdDocumentsTypeGeneratePost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/{type}/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypePost
     *
     * Upload order documents
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The document type. Supported types are &#39;invoiceExternal&#39;, &#39;deliveryNote&#39;, &#39;poDeliveryNote&#39;, &#39;orderConfirmation&#39;, &#39;offer&#39;, &#39;dunningLetter&#39;, &#39;reversalDunningLetter&#39;, &#39;returnNote&#39;, &#39;successConfirmation&#39;, &#39;correction&#39;, &#39;creditNoteExternal&#39;, &#39;reorder&#39;, &#39;uploaded&#39;. (required)
     * @param  \OpenAPI\Client\Model\InlineObject193 $_rest_orders_order_id_documents_type _rest_orders_order_id_documents_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Document[]
     */
    public function restOrdersOrderIdDocumentsTypePost($order_id, $type, $_rest_orders_order_id_documents_type = null)
    {
        list($response) = $this->restOrdersOrderIdDocumentsTypePostWithHttpInfo($order_id, $type, $_rest_orders_order_id_documents_type);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypePostWithHttpInfo
     *
     * Upload order documents
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The document type. Supported types are &#39;invoiceExternal&#39;, &#39;deliveryNote&#39;, &#39;poDeliveryNote&#39;, &#39;orderConfirmation&#39;, &#39;offer&#39;, &#39;dunningLetter&#39;, &#39;reversalDunningLetter&#39;, &#39;returnNote&#39;, &#39;successConfirmation&#39;, &#39;correction&#39;, &#39;creditNoteExternal&#39;, &#39;reorder&#39;, &#39;uploaded&#39;. (required)
     * @param  \OpenAPI\Client\Model\InlineObject193 $_rest_orders_order_id_documents_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Document[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsTypePostWithHttpInfo($order_id, $type, $_rest_orders_order_id_documents_type = null)
    {
        $request = $this->restOrdersOrderIdDocumentsTypePostRequest($order_id, $type, $_rest_orders_order_id_documents_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Document[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Document[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Document[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Document[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypePostAsync
     *
     * Upload order documents
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The document type. Supported types are &#39;invoiceExternal&#39;, &#39;deliveryNote&#39;, &#39;poDeliveryNote&#39;, &#39;orderConfirmation&#39;, &#39;offer&#39;, &#39;dunningLetter&#39;, &#39;reversalDunningLetter&#39;, &#39;returnNote&#39;, &#39;successConfirmation&#39;, &#39;correction&#39;, &#39;creditNoteExternal&#39;, &#39;reorder&#39;, &#39;uploaded&#39;. (required)
     * @param  \OpenAPI\Client\Model\InlineObject193 $_rest_orders_order_id_documents_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsTypePostAsync($order_id, $type, $_rest_orders_order_id_documents_type = null)
    {
        return $this->restOrdersOrderIdDocumentsTypePostAsyncWithHttpInfo($order_id, $type, $_rest_orders_order_id_documents_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypePostAsyncWithHttpInfo
     *
     * Upload order documents
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The document type. Supported types are &#39;invoiceExternal&#39;, &#39;deliveryNote&#39;, &#39;poDeliveryNote&#39;, &#39;orderConfirmation&#39;, &#39;offer&#39;, &#39;dunningLetter&#39;, &#39;reversalDunningLetter&#39;, &#39;returnNote&#39;, &#39;successConfirmation&#39;, &#39;correction&#39;, &#39;creditNoteExternal&#39;, &#39;reorder&#39;, &#39;uploaded&#39;. (required)
     * @param  \OpenAPI\Client\Model\InlineObject193 $_rest_orders_order_id_documents_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsTypePostAsyncWithHttpInfo($order_id, $type, $_rest_orders_order_id_documents_type = null)
    {
        $returnType = '\OpenAPI\Client\Model\Document[]';
        $request = $this->restOrdersOrderIdDocumentsTypePostRequest($order_id, $type, $_rest_orders_order_id_documents_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsTypePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The document type. Supported types are &#39;invoiceExternal&#39;, &#39;deliveryNote&#39;, &#39;poDeliveryNote&#39;, &#39;orderConfirmation&#39;, &#39;offer&#39;, &#39;dunningLetter&#39;, &#39;reversalDunningLetter&#39;, &#39;returnNote&#39;, &#39;successConfirmation&#39;, &#39;correction&#39;, &#39;creditNoteExternal&#39;, &#39;reorder&#39;, &#39;uploaded&#39;. (required)
     * @param  \OpenAPI\Client\Model\InlineObject193 $_rest_orders_order_id_documents_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsTypePostRequest($order_id, $type, $_rest_orders_order_id_documents_type = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsTypePost'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling restOrdersOrderIdDocumentsTypePost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/{type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_orders_order_id_documents_type)) {
            $_tempBody = $_rest_orders_order_id_documents_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeRecentGet
     *
     * Get most recent document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order document. The available types are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, . (required)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Document
     */
    public function restOrdersOrderIdDocumentsTypeRecentGet($order_id, $type, $with_content = null)
    {
        list($response) = $this->restOrdersOrderIdDocumentsTypeRecentGetWithHttpInfo($order_id, $type, $with_content);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeRecentGetWithHttpInfo
     *
     * Get most recent document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order document. The available types are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, . (required)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Document, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsTypeRecentGetWithHttpInfo($order_id, $type, $with_content = null)
    {
        $request = $this->restOrdersOrderIdDocumentsTypeRecentGetRequest($order_id, $type, $with_content);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Document' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Document', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Document';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeRecentGetAsync
     *
     * Get most recent document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order document. The available types are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, . (required)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsTypeRecentGetAsync($order_id, $type, $with_content = null)
    {
        return $this->restOrdersOrderIdDocumentsTypeRecentGetAsyncWithHttpInfo($order_id, $type, $with_content)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeRecentGetAsyncWithHttpInfo
     *
     * Get most recent document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order document. The available types are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, . (required)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsTypeRecentGetAsyncWithHttpInfo($order_id, $type, $with_content = null)
    {
        $returnType = '\OpenAPI\Client\Model\Document';
        $request = $this->restOrdersOrderIdDocumentsTypeRecentGetRequest($order_id, $type, $with_content);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsTypeRecentGet'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order document. The available types are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, . (required)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsTypeRecentGetRequest($order_id, $type, $with_content = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsTypeRecentGet'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling restOrdersOrderIdDocumentsTypeRecentGet'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/{type}/recent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($with_content)) {
            $with_content = ObjectSerializer::serializeCollection($with_content, '', true);
        }
        if ($with_content !== null) {
            $queryParams['withContent'] = $with_content;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
