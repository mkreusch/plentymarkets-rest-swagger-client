<?php
/**
 * OrderApi
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0-beta2
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * OrderApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class OrderApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation restDeliveryOrdersOrderIdDelete
     *
     * Delete a delivery order
     *
     * @param  int $order_id order_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restDeliveryOrdersOrderIdDelete($order_id)
    {
        list($response) = $this->restDeliveryOrdersOrderIdDeleteWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restDeliveryOrdersOrderIdDeleteWithHttpInfo
     *
     * Delete a delivery order
     *
     * @param  int $order_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restDeliveryOrdersOrderIdDeleteWithHttpInfo($order_id)
    {
        $request = $this->restDeliveryOrdersOrderIdDeleteRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restDeliveryOrdersOrderIdDeleteAsync
     *
     * Delete a delivery order
     *
     * @param  int $order_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restDeliveryOrdersOrderIdDeleteAsync($order_id)
    {
        return $this->restDeliveryOrdersOrderIdDeleteAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restDeliveryOrdersOrderIdDeleteAsyncWithHttpInfo
     *
     * Delete a delivery order
     *
     * @param  int $order_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restDeliveryOrdersOrderIdDeleteAsyncWithHttpInfo($order_id)
    {
        $returnType = 'object';
        $request = $this->restDeliveryOrdersOrderIdDeleteRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restDeliveryOrdersOrderIdDelete'
     *
     * @param  int $order_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restDeliveryOrdersOrderIdDeleteRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restDeliveryOrdersOrderIdDelete'
            );
        }

        $resourcePath = '/rest/delivery_orders/{orderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restDeliveryOrdersOrderIdPut
     *
     * Update a delivery order
     *
     * @param  int $order_id order_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Order
     */
    public function restDeliveryOrdersOrderIdPut($order_id)
    {
        list($response) = $this->restDeliveryOrdersOrderIdPutWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restDeliveryOrdersOrderIdPutWithHttpInfo
     *
     * Update a delivery order
     *
     * @param  int $order_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restDeliveryOrdersOrderIdPutWithHttpInfo($order_id)
    {
        $request = $this->restDeliveryOrdersOrderIdPutRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Order' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Order';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restDeliveryOrdersOrderIdPutAsync
     *
     * Update a delivery order
     *
     * @param  int $order_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restDeliveryOrdersOrderIdPutAsync($order_id)
    {
        return $this->restDeliveryOrdersOrderIdPutAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restDeliveryOrdersOrderIdPutAsyncWithHttpInfo
     *
     * Update a delivery order
     *
     * @param  int $order_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restDeliveryOrdersOrderIdPutAsyncWithHttpInfo($order_id)
    {
        $returnType = '\OpenAPI\Client\Model\Order';
        $request = $this->restDeliveryOrdersOrderIdPutRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restDeliveryOrdersOrderIdPut'
     *
     * @param  int $order_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restDeliveryOrdersOrderIdPutRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restDeliveryOrdersOrderIdPut'
            );
        }

        $resourcePath = '/rest/delivery_orders/{orderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restDeliveryOrdersPost
     *
     * Create a delivery order
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Order
     */
    public function restDeliveryOrdersPost()
    {
        list($response) = $this->restDeliveryOrdersPostWithHttpInfo();
        return $response;
    }

    /**
     * Operation restDeliveryOrdersPostWithHttpInfo
     *
     * Create a delivery order
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restDeliveryOrdersPostWithHttpInfo()
    {
        $request = $this->restDeliveryOrdersPostRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Order' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Order';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restDeliveryOrdersPostAsync
     *
     * Create a delivery order
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restDeliveryOrdersPostAsync()
    {
        return $this->restDeliveryOrdersPostAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restDeliveryOrdersPostAsyncWithHttpInfo
     *
     * Create a delivery order
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restDeliveryOrdersPostAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\Order';
        $request = $this->restDeliveryOrdersPostRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restDeliveryOrdersPost'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restDeliveryOrdersPostRequest()
    {

        $resourcePath = '/rest/delivery_orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersContactsContactIdGet
     *
     * List orders of a contact
     *
     * @param  int $contact_id The ID of the contact. (required)
     * @param  int $page The page to get. The default page that will be returned is page 1. (required)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (required)
     * @param  int $with Load additional relations for an order. The following relations are available:      * &lt;ul&gt;        &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the reference type. The available reference types are parent and reorder. The ID of the reference and the relation itself are also available.&lt;/li&gt;        &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;        &lt;li&gt;&#39;location&#39; &#x3D; The accounting location linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;payments&#39; &#x3D; The payments linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;documents&#39; &#x3D; The documents linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;contactSender&#39; &#x3D; The contact belonging the contact-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The contact belonging to the contact-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The warehouse belonging to the warehouse-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The warehouse belonging to the warehouse-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation data belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;        &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations linked to the order item.&lt;/li&gt;      &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20036
     */
    public function restOrdersContactsContactIdGet($contact_id, $page, $items_per_page, $with = null)
    {
        list($response) = $this->restOrdersContactsContactIdGetWithHttpInfo($contact_id, $page, $items_per_page, $with);
        return $response;
    }

    /**
     * Operation restOrdersContactsContactIdGetWithHttpInfo
     *
     * List orders of a contact
     *
     * @param  int $contact_id The ID of the contact. (required)
     * @param  int $page The page to get. The default page that will be returned is page 1. (required)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (required)
     * @param  int $with Load additional relations for an order. The following relations are available:      * &lt;ul&gt;        &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the reference type. The available reference types are parent and reorder. The ID of the reference and the relation itself are also available.&lt;/li&gt;        &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;        &lt;li&gt;&#39;location&#39; &#x3D; The accounting location linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;payments&#39; &#x3D; The payments linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;documents&#39; &#x3D; The documents linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;contactSender&#39; &#x3D; The contact belonging the contact-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The contact belonging to the contact-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The warehouse belonging to the warehouse-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The warehouse belonging to the warehouse-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation data belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;        &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations linked to the order item.&lt;/li&gt;      &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20036, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersContactsContactIdGetWithHttpInfo($contact_id, $page, $items_per_page, $with = null)
    {
        $request = $this->restOrdersContactsContactIdGetRequest($contact_id, $page, $items_per_page, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20036' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20036', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20036';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20036',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersContactsContactIdGetAsync
     *
     * List orders of a contact
     *
     * @param  int $contact_id The ID of the contact. (required)
     * @param  int $page The page to get. The default page that will be returned is page 1. (required)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (required)
     * @param  int $with Load additional relations for an order. The following relations are available:      * &lt;ul&gt;        &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the reference type. The available reference types are parent and reorder. The ID of the reference and the relation itself are also available.&lt;/li&gt;        &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;        &lt;li&gt;&#39;location&#39; &#x3D; The accounting location linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;payments&#39; &#x3D; The payments linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;documents&#39; &#x3D; The documents linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;contactSender&#39; &#x3D; The contact belonging the contact-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The contact belonging to the contact-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The warehouse belonging to the warehouse-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The warehouse belonging to the warehouse-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation data belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;        &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations linked to the order item.&lt;/li&gt;      &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersContactsContactIdGetAsync($contact_id, $page, $items_per_page, $with = null)
    {
        return $this->restOrdersContactsContactIdGetAsyncWithHttpInfo($contact_id, $page, $items_per_page, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersContactsContactIdGetAsyncWithHttpInfo
     *
     * List orders of a contact
     *
     * @param  int $contact_id The ID of the contact. (required)
     * @param  int $page The page to get. The default page that will be returned is page 1. (required)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (required)
     * @param  int $with Load additional relations for an order. The following relations are available:      * &lt;ul&gt;        &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the reference type. The available reference types are parent and reorder. The ID of the reference and the relation itself are also available.&lt;/li&gt;        &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;        &lt;li&gt;&#39;location&#39; &#x3D; The accounting location linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;payments&#39; &#x3D; The payments linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;documents&#39; &#x3D; The documents linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;contactSender&#39; &#x3D; The contact belonging the contact-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The contact belonging to the contact-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The warehouse belonging to the warehouse-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The warehouse belonging to the warehouse-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation data belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;        &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations linked to the order item.&lt;/li&gt;      &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersContactsContactIdGetAsyncWithHttpInfo($contact_id, $page, $items_per_page, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20036';
        $request = $this->restOrdersContactsContactIdGetRequest($contact_id, $page, $items_per_page, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersContactsContactIdGet'
     *
     * @param  int $contact_id The ID of the contact. (required)
     * @param  int $page The page to get. The default page that will be returned is page 1. (required)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (required)
     * @param  int $with Load additional relations for an order. The following relations are available:      * &lt;ul&gt;        &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the reference type. The available reference types are parent and reorder. The ID of the reference and the relation itself are also available.&lt;/li&gt;        &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;        &lt;li&gt;&#39;location&#39; &#x3D; The accounting location linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;payments&#39; &#x3D; The payments linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;documents&#39; &#x3D; The documents linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;contactSender&#39; &#x3D; The contact belonging the contact-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The contact belonging to the contact-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The warehouse belonging to the warehouse-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The warehouse belonging to the warehouse-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation data belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;        &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations linked to the order item.&lt;/li&gt;      &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersContactsContactIdGetRequest($contact_id, $page, $items_per_page, $with = null)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restOrdersContactsContactIdGet'
            );
        }
        // verify the required parameter 'page' is set
        if ($page === null || (is_array($page) && count($page) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page when calling restOrdersContactsContactIdGet'
            );
        }
        // verify the required parameter 'items_per_page' is set
        if ($items_per_page === null || (is_array($items_per_page) && count($items_per_page) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $items_per_page when calling restOrdersContactsContactIdGet'
            );
        }

        $resourcePath = '/rest/orders/contacts/{contactId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersContactsContactIdMultiOrderPost
     *
     * Create a multi-order
     *
     * @param  int $contact_id contact_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Order
     */
    public function restOrdersContactsContactIdMultiOrderPost($contact_id)
    {
        list($response) = $this->restOrdersContactsContactIdMultiOrderPostWithHttpInfo($contact_id);
        return $response;
    }

    /**
     * Operation restOrdersContactsContactIdMultiOrderPostWithHttpInfo
     *
     * Create a multi-order
     *
     * @param  int $contact_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersContactsContactIdMultiOrderPostWithHttpInfo($contact_id)
    {
        $request = $this->restOrdersContactsContactIdMultiOrderPostRequest($contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Order' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Order';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersContactsContactIdMultiOrderPostAsync
     *
     * Create a multi-order
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersContactsContactIdMultiOrderPostAsync($contact_id)
    {
        return $this->restOrdersContactsContactIdMultiOrderPostAsyncWithHttpInfo($contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersContactsContactIdMultiOrderPostAsyncWithHttpInfo
     *
     * Create a multi-order
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersContactsContactIdMultiOrderPostAsyncWithHttpInfo($contact_id)
    {
        $returnType = '\OpenAPI\Client\Model\Order';
        $request = $this->restOrdersContactsContactIdMultiOrderPostRequest($contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersContactsContactIdMultiOrderPost'
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersContactsContactIdMultiOrderPostRequest($contact_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restOrdersContactsContactIdMultiOrderPost'
            );
        }

        $resourcePath = '/rest/orders/contacts/{contactId}/multi_order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCouponsCampaignsCampaignIdCodesPost
     *
     * Create a coupon code
     *
     * @param  int $campaign_id campaign_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject169 $_rest_orders_coupons_campaigns_campaign_id_codes _rest_orders_coupons_campaigns_campaign_id_codes (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CouponCampaignCode
     */
    public function restOrdersCouponsCampaignsCampaignIdCodesPost($campaign_id, $_rest_orders_coupons_campaigns_campaign_id_codes = null)
    {
        list($response) = $this->restOrdersCouponsCampaignsCampaignIdCodesPostWithHttpInfo($campaign_id, $_rest_orders_coupons_campaigns_campaign_id_codes);
        return $response;
    }

    /**
     * Operation restOrdersCouponsCampaignsCampaignIdCodesPostWithHttpInfo
     *
     * Create a coupon code
     *
     * @param  int $campaign_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject169 $_rest_orders_coupons_campaigns_campaign_id_codes (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CouponCampaignCode, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCouponsCampaignsCampaignIdCodesPostWithHttpInfo($campaign_id, $_rest_orders_coupons_campaigns_campaign_id_codes = null)
    {
        $request = $this->restOrdersCouponsCampaignsCampaignIdCodesPostRequest($campaign_id, $_rest_orders_coupons_campaigns_campaign_id_codes);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CouponCampaignCode' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CouponCampaignCode', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CouponCampaignCode';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CouponCampaignCode',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCouponsCampaignsCampaignIdCodesPostAsync
     *
     * Create a coupon code
     *
     * @param  int $campaign_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject169 $_rest_orders_coupons_campaigns_campaign_id_codes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCouponsCampaignsCampaignIdCodesPostAsync($campaign_id, $_rest_orders_coupons_campaigns_campaign_id_codes = null)
    {
        return $this->restOrdersCouponsCampaignsCampaignIdCodesPostAsyncWithHttpInfo($campaign_id, $_rest_orders_coupons_campaigns_campaign_id_codes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCouponsCampaignsCampaignIdCodesPostAsyncWithHttpInfo
     *
     * Create a coupon code
     *
     * @param  int $campaign_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject169 $_rest_orders_coupons_campaigns_campaign_id_codes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCouponsCampaignsCampaignIdCodesPostAsyncWithHttpInfo($campaign_id, $_rest_orders_coupons_campaigns_campaign_id_codes = null)
    {
        $returnType = '\OpenAPI\Client\Model\CouponCampaignCode';
        $request = $this->restOrdersCouponsCampaignsCampaignIdCodesPostRequest($campaign_id, $_rest_orders_coupons_campaigns_campaign_id_codes);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCouponsCampaignsCampaignIdCodesPost'
     *
     * @param  int $campaign_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject169 $_rest_orders_coupons_campaigns_campaign_id_codes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersCouponsCampaignsCampaignIdCodesPostRequest($campaign_id, $_rest_orders_coupons_campaigns_campaign_id_codes = null)
    {
        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling restOrdersCouponsCampaignsCampaignIdCodesPost'
            );
        }

        $resourcePath = '/rest/orders/coupons/campaigns/{campaignId}/codes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_orders_coupons_campaigns_campaign_id_codes)) {
            $_tempBody = $_rest_orders_coupons_campaigns_campaign_id_codes;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCouponsCampaignsCodesCodeDelete
     *
     * Delete a coupon
     *
     * @param  int $code code (required)
     * @param  int $without_used Do not delete used coupons (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersCouponsCampaignsCodesCodeDelete($code, $without_used = null)
    {
        list($response) = $this->restOrdersCouponsCampaignsCodesCodeDeleteWithHttpInfo($code, $without_used);
        return $response;
    }

    /**
     * Operation restOrdersCouponsCampaignsCodesCodeDeleteWithHttpInfo
     *
     * Delete a coupon
     *
     * @param  int $code (required)
     * @param  int $without_used Do not delete used coupons (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCouponsCampaignsCodesCodeDeleteWithHttpInfo($code, $without_used = null)
    {
        $request = $this->restOrdersCouponsCampaignsCodesCodeDeleteRequest($code, $without_used);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCouponsCampaignsCodesCodeDeleteAsync
     *
     * Delete a coupon
     *
     * @param  int $code (required)
     * @param  int $without_used Do not delete used coupons (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCouponsCampaignsCodesCodeDeleteAsync($code, $without_used = null)
    {
        return $this->restOrdersCouponsCampaignsCodesCodeDeleteAsyncWithHttpInfo($code, $without_used)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCouponsCampaignsCodesCodeDeleteAsyncWithHttpInfo
     *
     * Delete a coupon
     *
     * @param  int $code (required)
     * @param  int $without_used Do not delete used coupons (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCouponsCampaignsCodesCodeDeleteAsyncWithHttpInfo($code, $without_used = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersCouponsCampaignsCodesCodeDeleteRequest($code, $without_used);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCouponsCampaignsCodesCodeDelete'
     *
     * @param  int $code (required)
     * @param  int $without_used Do not delete used coupons (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersCouponsCampaignsCodesCodeDeleteRequest($code, $without_used = null)
    {
        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $code when calling restOrdersCouponsCampaignsCodesCodeDelete'
            );
        }

        $resourcePath = '/rest/orders/coupons/campaigns/codes/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($without_used)) {
            $without_used = ObjectSerializer::serializeCollection($without_used, '', true);
        }
        if ($without_used !== null) {
            $queryParams['withoutUsed'] = $without_used;
        }


        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPut
     *
     * Disable or enable coupon
     *
     * @param  int $code code (required)
     * @param  int $is_disabled is_disabled (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPut($code, $is_disabled)
    {
        list($response) = $this->restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPutWithHttpInfo($code, $is_disabled);
        return $response;
    }

    /**
     * Operation restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPutWithHttpInfo
     *
     * Disable or enable coupon
     *
     * @param  int $code (required)
     * @param  int $is_disabled (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPutWithHttpInfo($code, $is_disabled)
    {
        $request = $this->restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPutRequest($code, $is_disabled);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPutAsync
     *
     * Disable or enable coupon
     *
     * @param  int $code (required)
     * @param  int $is_disabled (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPutAsync($code, $is_disabled)
    {
        return $this->restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPutAsyncWithHttpInfo($code, $is_disabled)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPutAsyncWithHttpInfo
     *
     * Disable or enable coupon
     *
     * @param  int $code (required)
     * @param  int $is_disabled (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPutAsyncWithHttpInfo($code, $is_disabled)
    {
        $returnType = 'object';
        $request = $this->restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPutRequest($code, $is_disabled);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPut'
     *
     * @param  int $code (required)
     * @param  int $is_disabled (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPutRequest($code, $is_disabled)
    {
        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $code when calling restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPut'
            );
        }
        // verify the required parameter 'is_disabled' is set
        if ($is_disabled === null || (is_array($is_disabled) && count($is_disabled) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $is_disabled when calling restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPut'
            );
        }

        $resourcePath = '/rest/orders/coupons/campaigns/codes/{code}/disabled/{isDisabled}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }
        // path params
        if ($is_disabled !== null) {
            $resourcePath = str_replace(
                '{' . 'isDisabled' . '}',
                ObjectSerializer::toPathValue($is_disabled),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCouponsCampaignsCodesCodeGet
     *
     * Get coupon code information
     *
     * @param  string $code The coupon code (required)
     * @param  string $with Load additional relations for a coupon code. Currently possible are:      * &lt;ul&gt;      *   &lt;li&gt;&#39;campaign&#39; &#x3D; The coupon campaign to which this code belongs to.&lt;/li&gt;      * &lt;/ul&gt;      * Example: &lt;code&gt;?with&#x3D;campaign&lt;/code&gt; (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CouponCampaignCode
     */
    public function restOrdersCouponsCampaignsCodesCodeGet($code, $with = null)
    {
        list($response) = $this->restOrdersCouponsCampaignsCodesCodeGetWithHttpInfo($code, $with);
        return $response;
    }

    /**
     * Operation restOrdersCouponsCampaignsCodesCodeGetWithHttpInfo
     *
     * Get coupon code information
     *
     * @param  string $code The coupon code (required)
     * @param  string $with Load additional relations for a coupon code. Currently possible are:      * &lt;ul&gt;      *   &lt;li&gt;&#39;campaign&#39; &#x3D; The coupon campaign to which this code belongs to.&lt;/li&gt;      * &lt;/ul&gt;      * Example: &lt;code&gt;?with&#x3D;campaign&lt;/code&gt; (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CouponCampaignCode, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCouponsCampaignsCodesCodeGetWithHttpInfo($code, $with = null)
    {
        $request = $this->restOrdersCouponsCampaignsCodesCodeGetRequest($code, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CouponCampaignCode' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CouponCampaignCode', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CouponCampaignCode';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CouponCampaignCode',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCouponsCampaignsCodesCodeGetAsync
     *
     * Get coupon code information
     *
     * @param  string $code The coupon code (required)
     * @param  string $with Load additional relations for a coupon code. Currently possible are:      * &lt;ul&gt;      *   &lt;li&gt;&#39;campaign&#39; &#x3D; The coupon campaign to which this code belongs to.&lt;/li&gt;      * &lt;/ul&gt;      * Example: &lt;code&gt;?with&#x3D;campaign&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCouponsCampaignsCodesCodeGetAsync($code, $with = null)
    {
        return $this->restOrdersCouponsCampaignsCodesCodeGetAsyncWithHttpInfo($code, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCouponsCampaignsCodesCodeGetAsyncWithHttpInfo
     *
     * Get coupon code information
     *
     * @param  string $code The coupon code (required)
     * @param  string $with Load additional relations for a coupon code. Currently possible are:      * &lt;ul&gt;      *   &lt;li&gt;&#39;campaign&#39; &#x3D; The coupon campaign to which this code belongs to.&lt;/li&gt;      * &lt;/ul&gt;      * Example: &lt;code&gt;?with&#x3D;campaign&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCouponsCampaignsCodesCodeGetAsyncWithHttpInfo($code, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\CouponCampaignCode';
        $request = $this->restOrdersCouponsCampaignsCodesCodeGetRequest($code, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCouponsCampaignsCodesCodeGet'
     *
     * @param  string $code The coupon code (required)
     * @param  string $with Load additional relations for a coupon code. Currently possible are:      * &lt;ul&gt;      *   &lt;li&gt;&#39;campaign&#39; &#x3D; The coupon campaign to which this code belongs to.&lt;/li&gt;      * &lt;/ul&gt;      * Example: &lt;code&gt;?with&#x3D;campaign&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersCouponsCampaignsCodesCodeGetRequest($code, $with = null)
    {
        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $code when calling restOrdersCouponsCampaignsCodesCodeGet'
            );
        }

        $resourcePath = '/rest/orders/coupons/campaigns/codes/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }


        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCouponsCodesContactsContactIdGet
     *
     * List redeemed coupon codes of a contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of coupons to be displayed per page. The default number of coupons per page is 50. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20037
     */
    public function restOrdersCouponsCodesContactsContactIdGet($contact_id, $page = null, $items_per_page = null)
    {
        list($response) = $this->restOrdersCouponsCodesContactsContactIdGetWithHttpInfo($contact_id, $page, $items_per_page);
        return $response;
    }

    /**
     * Operation restOrdersCouponsCodesContactsContactIdGetWithHttpInfo
     *
     * List redeemed coupon codes of a contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of coupons to be displayed per page. The default number of coupons per page is 50. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20037, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCouponsCodesContactsContactIdGetWithHttpInfo($contact_id, $page = null, $items_per_page = null)
    {
        $request = $this->restOrdersCouponsCodesContactsContactIdGetRequest($contact_id, $page, $items_per_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20037' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20037', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20037';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20037',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCouponsCodesContactsContactIdGetAsync
     *
     * List redeemed coupon codes of a contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of coupons to be displayed per page. The default number of coupons per page is 50. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCouponsCodesContactsContactIdGetAsync($contact_id, $page = null, $items_per_page = null)
    {
        return $this->restOrdersCouponsCodesContactsContactIdGetAsyncWithHttpInfo($contact_id, $page, $items_per_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCouponsCodesContactsContactIdGetAsyncWithHttpInfo
     *
     * List redeemed coupon codes of a contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of coupons to be displayed per page. The default number of coupons per page is 50. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCouponsCodesContactsContactIdGetAsyncWithHttpInfo($contact_id, $page = null, $items_per_page = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20037';
        $request = $this->restOrdersCouponsCodesContactsContactIdGetRequest($contact_id, $page, $items_per_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCouponsCodesContactsContactIdGet'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of coupons to be displayed per page. The default number of coupons per page is 50. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersCouponsCodesContactsContactIdGetRequest($contact_id, $page = null, $items_per_page = null)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restOrdersCouponsCodesContactsContactIdGet'
            );
        }

        $resourcePath = '/rest/orders/coupons/codes/contacts/{contactId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCouponsCodesCouponPost
     *
     * Validate a coupon
     *
     * @param  string $coupon The coupon to validate. (required)
     * @param  int $plenty_id The plenty id. (required)
     * @param  int $ship_to_country The country of delivery. (required)
     * @param  bool $call_from_scheduler Flag that indicates whether the validation is requested by a subscription order or not. TRUE &#x3D; The validation is requested by a subscription order. FALSE &#x3D; The validation is not requested by a subscription order. (optional)
     * @param  string $tax_id_number The tax id number. (optional)
     * @param  int $contact_class The contact class. (optional)
     * @param  int $contact_type The contact type. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject171 $_rest_orders_coupons_codes_coupon _rest_orders_coupons_codes_coupon (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CouponCodeValidation
     */
    public function restOrdersCouponsCodesCouponPost($coupon, $plenty_id, $ship_to_country, $call_from_scheduler = null, $tax_id_number = null, $contact_class = null, $contact_type = null, $_rest_orders_coupons_codes_coupon = null)
    {
        list($response) = $this->restOrdersCouponsCodesCouponPostWithHttpInfo($coupon, $plenty_id, $ship_to_country, $call_from_scheduler, $tax_id_number, $contact_class, $contact_type, $_rest_orders_coupons_codes_coupon);
        return $response;
    }

    /**
     * Operation restOrdersCouponsCodesCouponPostWithHttpInfo
     *
     * Validate a coupon
     *
     * @param  string $coupon The coupon to validate. (required)
     * @param  int $plenty_id The plenty id. (required)
     * @param  int $ship_to_country The country of delivery. (required)
     * @param  bool $call_from_scheduler Flag that indicates whether the validation is requested by a subscription order or not. TRUE &#x3D; The validation is requested by a subscription order. FALSE &#x3D; The validation is not requested by a subscription order. (optional)
     * @param  string $tax_id_number The tax id number. (optional)
     * @param  int $contact_class The contact class. (optional)
     * @param  int $contact_type The contact type. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject171 $_rest_orders_coupons_codes_coupon (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CouponCodeValidation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCouponsCodesCouponPostWithHttpInfo($coupon, $plenty_id, $ship_to_country, $call_from_scheduler = null, $tax_id_number = null, $contact_class = null, $contact_type = null, $_rest_orders_coupons_codes_coupon = null)
    {
        $request = $this->restOrdersCouponsCodesCouponPostRequest($coupon, $plenty_id, $ship_to_country, $call_from_scheduler, $tax_id_number, $contact_class, $contact_type, $_rest_orders_coupons_codes_coupon);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CouponCodeValidation' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CouponCodeValidation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CouponCodeValidation';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CouponCodeValidation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCouponsCodesCouponPostAsync
     *
     * Validate a coupon
     *
     * @param  string $coupon The coupon to validate. (required)
     * @param  int $plenty_id The plenty id. (required)
     * @param  int $ship_to_country The country of delivery. (required)
     * @param  bool $call_from_scheduler Flag that indicates whether the validation is requested by a subscription order or not. TRUE &#x3D; The validation is requested by a subscription order. FALSE &#x3D; The validation is not requested by a subscription order. (optional)
     * @param  string $tax_id_number The tax id number. (optional)
     * @param  int $contact_class The contact class. (optional)
     * @param  int $contact_type The contact type. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject171 $_rest_orders_coupons_codes_coupon (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCouponsCodesCouponPostAsync($coupon, $plenty_id, $ship_to_country, $call_from_scheduler = null, $tax_id_number = null, $contact_class = null, $contact_type = null, $_rest_orders_coupons_codes_coupon = null)
    {
        return $this->restOrdersCouponsCodesCouponPostAsyncWithHttpInfo($coupon, $plenty_id, $ship_to_country, $call_from_scheduler, $tax_id_number, $contact_class, $contact_type, $_rest_orders_coupons_codes_coupon)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCouponsCodesCouponPostAsyncWithHttpInfo
     *
     * Validate a coupon
     *
     * @param  string $coupon The coupon to validate. (required)
     * @param  int $plenty_id The plenty id. (required)
     * @param  int $ship_to_country The country of delivery. (required)
     * @param  bool $call_from_scheduler Flag that indicates whether the validation is requested by a subscription order or not. TRUE &#x3D; The validation is requested by a subscription order. FALSE &#x3D; The validation is not requested by a subscription order. (optional)
     * @param  string $tax_id_number The tax id number. (optional)
     * @param  int $contact_class The contact class. (optional)
     * @param  int $contact_type The contact type. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject171 $_rest_orders_coupons_codes_coupon (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCouponsCodesCouponPostAsyncWithHttpInfo($coupon, $plenty_id, $ship_to_country, $call_from_scheduler = null, $tax_id_number = null, $contact_class = null, $contact_type = null, $_rest_orders_coupons_codes_coupon = null)
    {
        $returnType = '\OpenAPI\Client\Model\CouponCodeValidation';
        $request = $this->restOrdersCouponsCodesCouponPostRequest($coupon, $plenty_id, $ship_to_country, $call_from_scheduler, $tax_id_number, $contact_class, $contact_type, $_rest_orders_coupons_codes_coupon);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCouponsCodesCouponPost'
     *
     * @param  string $coupon The coupon to validate. (required)
     * @param  int $plenty_id The plenty id. (required)
     * @param  int $ship_to_country The country of delivery. (required)
     * @param  bool $call_from_scheduler Flag that indicates whether the validation is requested by a subscription order or not. TRUE &#x3D; The validation is requested by a subscription order. FALSE &#x3D; The validation is not requested by a subscription order. (optional)
     * @param  string $tax_id_number The tax id number. (optional)
     * @param  int $contact_class The contact class. (optional)
     * @param  int $contact_type The contact type. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject171 $_rest_orders_coupons_codes_coupon (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersCouponsCodesCouponPostRequest($coupon, $plenty_id, $ship_to_country, $call_from_scheduler = null, $tax_id_number = null, $contact_class = null, $contact_type = null, $_rest_orders_coupons_codes_coupon = null)
    {
        // verify the required parameter 'coupon' is set
        if ($coupon === null || (is_array($coupon) && count($coupon) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $coupon when calling restOrdersCouponsCodesCouponPost'
            );
        }
        // verify the required parameter 'plenty_id' is set
        if ($plenty_id === null || (is_array($plenty_id) && count($plenty_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $plenty_id when calling restOrdersCouponsCodesCouponPost'
            );
        }
        // verify the required parameter 'ship_to_country' is set
        if ($ship_to_country === null || (is_array($ship_to_country) && count($ship_to_country) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ship_to_country when calling restOrdersCouponsCodesCouponPost'
            );
        }

        $resourcePath = '/rest/orders/coupons/codes/{coupon}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($call_from_scheduler)) {
            $call_from_scheduler = ObjectSerializer::serializeCollection($call_from_scheduler, '', true);
        }
        if ($call_from_scheduler !== null) {
            $queryParams['callFromScheduler'] = $call_from_scheduler;
        }
        // query params
        if (is_array($plenty_id)) {
            $plenty_id = ObjectSerializer::serializeCollection($plenty_id, '', true);
        }
        if ($plenty_id !== null) {
            $queryParams['plentyId'] = $plenty_id;
        }
        // query params
        if (is_array($ship_to_country)) {
            $ship_to_country = ObjectSerializer::serializeCollection($ship_to_country, '', true);
        }
        if ($ship_to_country !== null) {
            $queryParams['shipToCountry'] = $ship_to_country;
        }
        // query params
        if (is_array($tax_id_number)) {
            $tax_id_number = ObjectSerializer::serializeCollection($tax_id_number, '', true);
        }
        if ($tax_id_number !== null) {
            $queryParams['taxIdNumber'] = $tax_id_number;
        }
        // query params
        if (is_array($contact_class)) {
            $contact_class = ObjectSerializer::serializeCollection($contact_class, '', true);
        }
        if ($contact_class !== null) {
            $queryParams['contactClass'] = $contact_class;
        }
        // query params
        if (is_array($contact_type)) {
            $contact_type = ObjectSerializer::serializeCollection($contact_type, '', true);
        }
        if ($contact_type !== null) {
            $queryParams['contactType'] = $contact_type;
        }


        // path params
        if ($coupon !== null) {
            $resourcePath = str_replace(
                '{' . 'coupon' . '}',
                ObjectSerializer::toPathValue($coupon),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_orders_coupons_codes_coupon)) {
            $_tempBody = $_rest_orders_coupons_codes_coupon;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCouponsCodesPost
     *
     * Validate multiple coupons
     *
     * @param  int $coupons The coupons to validate. (required)
     * @param  int $plenty_id The plenty id. (required)
     * @param  int $ship_to_country The country of delivery. (required)
     * @param  bool $call_from_scheduler Flag that indicates whether the validation is requested by a subscription order or not. TRUE &#x3D; The validation is requested by a subscription order. FALSE &#x3D; The validation is not requested by a subscription order. (optional)
     * @param  string $tax_id_number The tax id number. (optional)
     * @param  int $contact_class The contact class. (optional)
     * @param  int $contact_type The contact type. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject170 $_rest_orders_coupons_codes _rest_orders_coupons_codes (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CouponCodeValidation[]
     */
    public function restOrdersCouponsCodesPost($coupons, $plenty_id, $ship_to_country, $call_from_scheduler = null, $tax_id_number = null, $contact_class = null, $contact_type = null, $_rest_orders_coupons_codes = null)
    {
        list($response) = $this->restOrdersCouponsCodesPostWithHttpInfo($coupons, $plenty_id, $ship_to_country, $call_from_scheduler, $tax_id_number, $contact_class, $contact_type, $_rest_orders_coupons_codes);
        return $response;
    }

    /**
     * Operation restOrdersCouponsCodesPostWithHttpInfo
     *
     * Validate multiple coupons
     *
     * @param  int $coupons The coupons to validate. (required)
     * @param  int $plenty_id The plenty id. (required)
     * @param  int $ship_to_country The country of delivery. (required)
     * @param  bool $call_from_scheduler Flag that indicates whether the validation is requested by a subscription order or not. TRUE &#x3D; The validation is requested by a subscription order. FALSE &#x3D; The validation is not requested by a subscription order. (optional)
     * @param  string $tax_id_number The tax id number. (optional)
     * @param  int $contact_class The contact class. (optional)
     * @param  int $contact_type The contact type. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject170 $_rest_orders_coupons_codes (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CouponCodeValidation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCouponsCodesPostWithHttpInfo($coupons, $plenty_id, $ship_to_country, $call_from_scheduler = null, $tax_id_number = null, $contact_class = null, $contact_type = null, $_rest_orders_coupons_codes = null)
    {
        $request = $this->restOrdersCouponsCodesPostRequest($coupons, $plenty_id, $ship_to_country, $call_from_scheduler, $tax_id_number, $contact_class, $contact_type, $_rest_orders_coupons_codes);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CouponCodeValidation[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CouponCodeValidation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CouponCodeValidation[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CouponCodeValidation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCouponsCodesPostAsync
     *
     * Validate multiple coupons
     *
     * @param  int $coupons The coupons to validate. (required)
     * @param  int $plenty_id The plenty id. (required)
     * @param  int $ship_to_country The country of delivery. (required)
     * @param  bool $call_from_scheduler Flag that indicates whether the validation is requested by a subscription order or not. TRUE &#x3D; The validation is requested by a subscription order. FALSE &#x3D; The validation is not requested by a subscription order. (optional)
     * @param  string $tax_id_number The tax id number. (optional)
     * @param  int $contact_class The contact class. (optional)
     * @param  int $contact_type The contact type. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject170 $_rest_orders_coupons_codes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCouponsCodesPostAsync($coupons, $plenty_id, $ship_to_country, $call_from_scheduler = null, $tax_id_number = null, $contact_class = null, $contact_type = null, $_rest_orders_coupons_codes = null)
    {
        return $this->restOrdersCouponsCodesPostAsyncWithHttpInfo($coupons, $plenty_id, $ship_to_country, $call_from_scheduler, $tax_id_number, $contact_class, $contact_type, $_rest_orders_coupons_codes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCouponsCodesPostAsyncWithHttpInfo
     *
     * Validate multiple coupons
     *
     * @param  int $coupons The coupons to validate. (required)
     * @param  int $plenty_id The plenty id. (required)
     * @param  int $ship_to_country The country of delivery. (required)
     * @param  bool $call_from_scheduler Flag that indicates whether the validation is requested by a subscription order or not. TRUE &#x3D; The validation is requested by a subscription order. FALSE &#x3D; The validation is not requested by a subscription order. (optional)
     * @param  string $tax_id_number The tax id number. (optional)
     * @param  int $contact_class The contact class. (optional)
     * @param  int $contact_type The contact type. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject170 $_rest_orders_coupons_codes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCouponsCodesPostAsyncWithHttpInfo($coupons, $plenty_id, $ship_to_country, $call_from_scheduler = null, $tax_id_number = null, $contact_class = null, $contact_type = null, $_rest_orders_coupons_codes = null)
    {
        $returnType = '\OpenAPI\Client\Model\CouponCodeValidation[]';
        $request = $this->restOrdersCouponsCodesPostRequest($coupons, $plenty_id, $ship_to_country, $call_from_scheduler, $tax_id_number, $contact_class, $contact_type, $_rest_orders_coupons_codes);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCouponsCodesPost'
     *
     * @param  int $coupons The coupons to validate. (required)
     * @param  int $plenty_id The plenty id. (required)
     * @param  int $ship_to_country The country of delivery. (required)
     * @param  bool $call_from_scheduler Flag that indicates whether the validation is requested by a subscription order or not. TRUE &#x3D; The validation is requested by a subscription order. FALSE &#x3D; The validation is not requested by a subscription order. (optional)
     * @param  string $tax_id_number The tax id number. (optional)
     * @param  int $contact_class The contact class. (optional)
     * @param  int $contact_type The contact type. (optional)
     * @param  \OpenAPI\Client\Model\InlineObject170 $_rest_orders_coupons_codes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersCouponsCodesPostRequest($coupons, $plenty_id, $ship_to_country, $call_from_scheduler = null, $tax_id_number = null, $contact_class = null, $contact_type = null, $_rest_orders_coupons_codes = null)
    {
        // verify the required parameter 'coupons' is set
        if ($coupons === null || (is_array($coupons) && count($coupons) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $coupons when calling restOrdersCouponsCodesPost'
            );
        }
        // verify the required parameter 'plenty_id' is set
        if ($plenty_id === null || (is_array($plenty_id) && count($plenty_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $plenty_id when calling restOrdersCouponsCodesPost'
            );
        }
        // verify the required parameter 'ship_to_country' is set
        if ($ship_to_country === null || (is_array($ship_to_country) && count($ship_to_country) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ship_to_country when calling restOrdersCouponsCodesPost'
            );
        }

        $resourcePath = '/rest/orders/coupons/codes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($coupons)) {
            $coupons = ObjectSerializer::serializeCollection($coupons, '', true);
        }
        if ($coupons !== null) {
            $queryParams['coupons'] = $coupons;
        }
        // query params
        if (is_array($call_from_scheduler)) {
            $call_from_scheduler = ObjectSerializer::serializeCollection($call_from_scheduler, '', true);
        }
        if ($call_from_scheduler !== null) {
            $queryParams['callFromScheduler'] = $call_from_scheduler;
        }
        // query params
        if (is_array($plenty_id)) {
            $plenty_id = ObjectSerializer::serializeCollection($plenty_id, '', true);
        }
        if ($plenty_id !== null) {
            $queryParams['plentyId'] = $plenty_id;
        }
        // query params
        if (is_array($ship_to_country)) {
            $ship_to_country = ObjectSerializer::serializeCollection($ship_to_country, '', true);
        }
        if ($ship_to_country !== null) {
            $queryParams['shipToCountry'] = $ship_to_country;
        }
        // query params
        if (is_array($tax_id_number)) {
            $tax_id_number = ObjectSerializer::serializeCollection($tax_id_number, '', true);
        }
        if ($tax_id_number !== null) {
            $queryParams['taxIdNumber'] = $tax_id_number;
        }
        // query params
        if (is_array($contact_class)) {
            $contact_class = ObjectSerializer::serializeCollection($contact_class, '', true);
        }
        if ($contact_class !== null) {
            $queryParams['contactClass'] = $contact_class;
        }
        // query params
        if (is_array($contact_type)) {
            $contact_type = ObjectSerializer::serializeCollection($contact_type, '', true);
        }
        if ($contact_type !== null) {
            $queryParams['contactType'] = $contact_type;
        }



        // body params
        $_tempBody = null;
        if (isset($_rest_orders_coupons_codes)) {
            $_tempBody = $_rest_orders_coupons_codes;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCurrenciesCountriesCountryIdGet
     *
     * Get a currency for a country
     *
     * @param  int $country_id country_id (required)
     * @param  int $columns The attributes to be loaded (optional)
     * @param  int $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39;). (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Currency
     */
    public function restOrdersCurrenciesCountriesCountryIdGet($country_id, $columns = null, $with = null)
    {
        list($response) = $this->restOrdersCurrenciesCountriesCountryIdGetWithHttpInfo($country_id, $columns, $with);
        return $response;
    }

    /**
     * Operation restOrdersCurrenciesCountriesCountryIdGetWithHttpInfo
     *
     * Get a currency for a country
     *
     * @param  int $country_id (required)
     * @param  int $columns The attributes to be loaded (optional)
     * @param  int $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39;). (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Currency, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCurrenciesCountriesCountryIdGetWithHttpInfo($country_id, $columns = null, $with = null)
    {
        $request = $this->restOrdersCurrenciesCountriesCountryIdGetRequest($country_id, $columns, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Currency' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Currency', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Currency';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Currency',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCurrenciesCountriesCountryIdGetAsync
     *
     * Get a currency for a country
     *
     * @param  int $country_id (required)
     * @param  int $columns The attributes to be loaded (optional)
     * @param  int $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39;). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCurrenciesCountriesCountryIdGetAsync($country_id, $columns = null, $with = null)
    {
        return $this->restOrdersCurrenciesCountriesCountryIdGetAsyncWithHttpInfo($country_id, $columns, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCurrenciesCountriesCountryIdGetAsyncWithHttpInfo
     *
     * Get a currency for a country
     *
     * @param  int $country_id (required)
     * @param  int $columns The attributes to be loaded (optional)
     * @param  int $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39;). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCurrenciesCountriesCountryIdGetAsyncWithHttpInfo($country_id, $columns = null, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\Currency';
        $request = $this->restOrdersCurrenciesCountriesCountryIdGetRequest($country_id, $columns, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCurrenciesCountriesCountryIdGet'
     *
     * @param  int $country_id (required)
     * @param  int $columns The attributes to be loaded (optional)
     * @param  int $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39;). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersCurrenciesCountriesCountryIdGetRequest($country_id, $columns = null, $with = null)
    {
        // verify the required parameter 'country_id' is set
        if ($country_id === null || (is_array($country_id) && count($country_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_id when calling restOrdersCurrenciesCountriesCountryIdGet'
            );
        }

        $resourcePath = '/rest/orders/currencies/countries/{countryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($columns)) {
            $columns = ObjectSerializer::serializeCollection($columns, '', true);
        }
        if ($columns !== null) {
            $queryParams['columns'] = $columns;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }


        // path params
        if ($country_id !== null) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCurrenciesCurrencyIsoCountriesGet
     *
     * List countries for a currency
     *
     * @param  string $currency_iso The ISO 4217 code of the currency (required)
     * @param  int $columns The attributes to be loaded (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Country[]
     */
    public function restOrdersCurrenciesCurrencyIsoCountriesGet($currency_iso, $columns = null)
    {
        list($response) = $this->restOrdersCurrenciesCurrencyIsoCountriesGetWithHttpInfo($currency_iso, $columns);
        return $response;
    }

    /**
     * Operation restOrdersCurrenciesCurrencyIsoCountriesGetWithHttpInfo
     *
     * List countries for a currency
     *
     * @param  string $currency_iso The ISO 4217 code of the currency (required)
     * @param  int $columns The attributes to be loaded (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Country[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCurrenciesCurrencyIsoCountriesGetWithHttpInfo($currency_iso, $columns = null)
    {
        $request = $this->restOrdersCurrenciesCurrencyIsoCountriesGetRequest($currency_iso, $columns);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Country[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Country[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Country[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Country[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCurrenciesCurrencyIsoCountriesGetAsync
     *
     * List countries for a currency
     *
     * @param  string $currency_iso The ISO 4217 code of the currency (required)
     * @param  int $columns The attributes to be loaded (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCurrenciesCurrencyIsoCountriesGetAsync($currency_iso, $columns = null)
    {
        return $this->restOrdersCurrenciesCurrencyIsoCountriesGetAsyncWithHttpInfo($currency_iso, $columns)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCurrenciesCurrencyIsoCountriesGetAsyncWithHttpInfo
     *
     * List countries for a currency
     *
     * @param  string $currency_iso The ISO 4217 code of the currency (required)
     * @param  int $columns The attributes to be loaded (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCurrenciesCurrencyIsoCountriesGetAsyncWithHttpInfo($currency_iso, $columns = null)
    {
        $returnType = '\OpenAPI\Client\Model\Country[]';
        $request = $this->restOrdersCurrenciesCurrencyIsoCountriesGetRequest($currency_iso, $columns);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCurrenciesCurrencyIsoCountriesGet'
     *
     * @param  string $currency_iso The ISO 4217 code of the currency (required)
     * @param  int $columns The attributes to be loaded (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersCurrenciesCurrencyIsoCountriesGetRequest($currency_iso, $columns = null)
    {
        // verify the required parameter 'currency_iso' is set
        if ($currency_iso === null || (is_array($currency_iso) && count($currency_iso) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency_iso when calling restOrdersCurrenciesCurrencyIsoCountriesGet'
            );
        }

        $resourcePath = '/rest/orders/currencies/{currencyIso}/countries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($columns)) {
            $columns = ObjectSerializer::serializeCollection($columns, '', true);
        }
        if ($columns !== null) {
            $queryParams['columns'] = $columns;
        }


        // path params
        if ($currency_iso !== null) {
            $resourcePath = str_replace(
                '{' . 'currencyIso' . '}',
                ObjectSerializer::toPathValue($currency_iso),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCurrenciesCurrencyIsoExchangeRateGet
     *
     * Get the exchange rate for a currency
     *
     * @param  int $currency_iso currency_iso (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurrencyExchangeRate
     */
    public function restOrdersCurrenciesCurrencyIsoExchangeRateGet($currency_iso)
    {
        list($response) = $this->restOrdersCurrenciesCurrencyIsoExchangeRateGetWithHttpInfo($currency_iso);
        return $response;
    }

    /**
     * Operation restOrdersCurrenciesCurrencyIsoExchangeRateGetWithHttpInfo
     *
     * Get the exchange rate for a currency
     *
     * @param  int $currency_iso (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurrencyExchangeRate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCurrenciesCurrencyIsoExchangeRateGetWithHttpInfo($currency_iso)
    {
        $request = $this->restOrdersCurrenciesCurrencyIsoExchangeRateGetRequest($currency_iso);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurrencyExchangeRate' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurrencyExchangeRate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurrencyExchangeRate';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurrencyExchangeRate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCurrenciesCurrencyIsoExchangeRateGetAsync
     *
     * Get the exchange rate for a currency
     *
     * @param  int $currency_iso (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCurrenciesCurrencyIsoExchangeRateGetAsync($currency_iso)
    {
        return $this->restOrdersCurrenciesCurrencyIsoExchangeRateGetAsyncWithHttpInfo($currency_iso)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCurrenciesCurrencyIsoExchangeRateGetAsyncWithHttpInfo
     *
     * Get the exchange rate for a currency
     *
     * @param  int $currency_iso (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCurrenciesCurrencyIsoExchangeRateGetAsyncWithHttpInfo($currency_iso)
    {
        $returnType = '\OpenAPI\Client\Model\CurrencyExchangeRate';
        $request = $this->restOrdersCurrenciesCurrencyIsoExchangeRateGetRequest($currency_iso);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCurrenciesCurrencyIsoExchangeRateGet'
     *
     * @param  int $currency_iso (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersCurrenciesCurrencyIsoExchangeRateGetRequest($currency_iso)
    {
        // verify the required parameter 'currency_iso' is set
        if ($currency_iso === null || (is_array($currency_iso) && count($currency_iso) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency_iso when calling restOrdersCurrenciesCurrencyIsoExchangeRateGet'
            );
        }

        $resourcePath = '/rest/orders/currencies/{currencyIso}/exchangeRate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($currency_iso !== null) {
            $resourcePath = str_replace(
                '{' . 'currencyIso' . '}',
                ObjectSerializer::toPathValue($currency_iso),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCurrenciesCurrencyIsoGet
     *
     * Get a currency
     *
     * @param  string $currency_iso The ISO 4217 code of the currency (required)
     * @param  int $columns The attributes to be loaded (optional)
     * @param  int $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39; (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Currency
     */
    public function restOrdersCurrenciesCurrencyIsoGet($currency_iso, $columns = null, $with = null)
    {
        list($response) = $this->restOrdersCurrenciesCurrencyIsoGetWithHttpInfo($currency_iso, $columns, $with);
        return $response;
    }

    /**
     * Operation restOrdersCurrenciesCurrencyIsoGetWithHttpInfo
     *
     * Get a currency
     *
     * @param  string $currency_iso The ISO 4217 code of the currency (required)
     * @param  int $columns The attributes to be loaded (optional)
     * @param  int $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39; (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Currency, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCurrenciesCurrencyIsoGetWithHttpInfo($currency_iso, $columns = null, $with = null)
    {
        $request = $this->restOrdersCurrenciesCurrencyIsoGetRequest($currency_iso, $columns, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Currency' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Currency', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Currency';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Currency',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCurrenciesCurrencyIsoGetAsync
     *
     * Get a currency
     *
     * @param  string $currency_iso The ISO 4217 code of the currency (required)
     * @param  int $columns The attributes to be loaded (optional)
     * @param  int $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCurrenciesCurrencyIsoGetAsync($currency_iso, $columns = null, $with = null)
    {
        return $this->restOrdersCurrenciesCurrencyIsoGetAsyncWithHttpInfo($currency_iso, $columns, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCurrenciesCurrencyIsoGetAsyncWithHttpInfo
     *
     * Get a currency
     *
     * @param  string $currency_iso The ISO 4217 code of the currency (required)
     * @param  int $columns The attributes to be loaded (optional)
     * @param  int $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCurrenciesCurrencyIsoGetAsyncWithHttpInfo($currency_iso, $columns = null, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\Currency';
        $request = $this->restOrdersCurrenciesCurrencyIsoGetRequest($currency_iso, $columns, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCurrenciesCurrencyIsoGet'
     *
     * @param  string $currency_iso The ISO 4217 code of the currency (required)
     * @param  int $columns The attributes to be loaded (optional)
     * @param  int $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersCurrenciesCurrencyIsoGetRequest($currency_iso, $columns = null, $with = null)
    {
        // verify the required parameter 'currency_iso' is set
        if ($currency_iso === null || (is_array($currency_iso) && count($currency_iso) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency_iso when calling restOrdersCurrenciesCurrencyIsoGet'
            );
        }

        $resourcePath = '/rest/orders/currencies/{currencyIso}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($columns)) {
            $columns = ObjectSerializer::serializeCollection($columns, '', true);
        }
        if ($columns !== null) {
            $queryParams['columns'] = $columns;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }


        // path params
        if ($currency_iso !== null) {
            $resourcePath = str_replace(
                '{' . 'currencyIso' . '}',
                ObjectSerializer::toPathValue($currency_iso),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCurrenciesExchangeRatesFromCurrencyIsoGet
     *
     * Get the exchange rates from a currency
     *
     * @param  int $currency_iso currency_iso (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function restOrdersCurrenciesExchangeRatesFromCurrencyIsoGet($currency_iso)
    {
        list($response) = $this->restOrdersCurrenciesExchangeRatesFromCurrencyIsoGetWithHttpInfo($currency_iso);
        return $response;
    }

    /**
     * Operation restOrdersCurrenciesExchangeRatesFromCurrencyIsoGetWithHttpInfo
     *
     * Get the exchange rates from a currency
     *
     * @param  int $currency_iso (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCurrenciesExchangeRatesFromCurrencyIsoGetWithHttpInfo($currency_iso)
    {
        $request = $this->restOrdersCurrenciesExchangeRatesFromCurrencyIsoGetRequest($currency_iso);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCurrenciesExchangeRatesFromCurrencyIsoGetAsync
     *
     * Get the exchange rates from a currency
     *
     * @param  int $currency_iso (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCurrenciesExchangeRatesFromCurrencyIsoGetAsync($currency_iso)
    {
        return $this->restOrdersCurrenciesExchangeRatesFromCurrencyIsoGetAsyncWithHttpInfo($currency_iso)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCurrenciesExchangeRatesFromCurrencyIsoGetAsyncWithHttpInfo
     *
     * Get the exchange rates from a currency
     *
     * @param  int $currency_iso (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCurrenciesExchangeRatesFromCurrencyIsoGetAsyncWithHttpInfo($currency_iso)
    {
        $returnType = 'object[]';
        $request = $this->restOrdersCurrenciesExchangeRatesFromCurrencyIsoGetRequest($currency_iso);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCurrenciesExchangeRatesFromCurrencyIsoGet'
     *
     * @param  int $currency_iso (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersCurrenciesExchangeRatesFromCurrencyIsoGetRequest($currency_iso)
    {
        // verify the required parameter 'currency_iso' is set
        if ($currency_iso === null || (is_array($currency_iso) && count($currency_iso) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency_iso when calling restOrdersCurrenciesExchangeRatesFromCurrencyIsoGet'
            );
        }

        $resourcePath = '/rest/orders/currencies/exchange_rates/from/{currencyIso}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($currency_iso !== null) {
            $resourcePath = str_replace(
                '{' . 'currencyIso' . '}',
                ObjectSerializer::toPathValue($currency_iso),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCurrenciesExchangeRatesToCurrencyIsoGet
     *
     * Get the exchange rates to a currency
     *
     * @param  int $currency_iso currency_iso (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function restOrdersCurrenciesExchangeRatesToCurrencyIsoGet($currency_iso)
    {
        list($response) = $this->restOrdersCurrenciesExchangeRatesToCurrencyIsoGetWithHttpInfo($currency_iso);
        return $response;
    }

    /**
     * Operation restOrdersCurrenciesExchangeRatesToCurrencyIsoGetWithHttpInfo
     *
     * Get the exchange rates to a currency
     *
     * @param  int $currency_iso (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCurrenciesExchangeRatesToCurrencyIsoGetWithHttpInfo($currency_iso)
    {
        $request = $this->restOrdersCurrenciesExchangeRatesToCurrencyIsoGetRequest($currency_iso);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCurrenciesExchangeRatesToCurrencyIsoGetAsync
     *
     * Get the exchange rates to a currency
     *
     * @param  int $currency_iso (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCurrenciesExchangeRatesToCurrencyIsoGetAsync($currency_iso)
    {
        return $this->restOrdersCurrenciesExchangeRatesToCurrencyIsoGetAsyncWithHttpInfo($currency_iso)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCurrenciesExchangeRatesToCurrencyIsoGetAsyncWithHttpInfo
     *
     * Get the exchange rates to a currency
     *
     * @param  int $currency_iso (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCurrenciesExchangeRatesToCurrencyIsoGetAsyncWithHttpInfo($currency_iso)
    {
        $returnType = 'object[]';
        $request = $this->restOrdersCurrenciesExchangeRatesToCurrencyIsoGetRequest($currency_iso);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCurrenciesExchangeRatesToCurrencyIsoGet'
     *
     * @param  int $currency_iso (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersCurrenciesExchangeRatesToCurrencyIsoGetRequest($currency_iso)
    {
        // verify the required parameter 'currency_iso' is set
        if ($currency_iso === null || (is_array($currency_iso) && count($currency_iso) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency_iso when calling restOrdersCurrenciesExchangeRatesToCurrencyIsoGet'
            );
        }

        $resourcePath = '/rest/orders/currencies/exchange_rates/to/{currencyIso}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($currency_iso !== null) {
            $resourcePath = str_replace(
                '{' . 'currencyIso' . '}',
                ObjectSerializer::toPathValue($currency_iso),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCurrenciesGet
     *
     * List currencies
     *
     * @param  int $columns The attributes to be loaded (optional)
     * @param  int $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Currency[]
     */
    public function restOrdersCurrenciesGet($columns = null, $with = null)
    {
        list($response) = $this->restOrdersCurrenciesGetWithHttpInfo($columns, $with);
        return $response;
    }

    /**
     * Operation restOrdersCurrenciesGetWithHttpInfo
     *
     * List currencies
     *
     * @param  int $columns The attributes to be loaded (optional)
     * @param  int $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Currency[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCurrenciesGetWithHttpInfo($columns = null, $with = null)
    {
        $request = $this->restOrdersCurrenciesGetRequest($columns, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Currency[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Currency[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Currency[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Currency[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCurrenciesGetAsync
     *
     * List currencies
     *
     * @param  int $columns The attributes to be loaded (optional)
     * @param  int $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCurrenciesGetAsync($columns = null, $with = null)
    {
        return $this->restOrdersCurrenciesGetAsyncWithHttpInfo($columns, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCurrenciesGetAsyncWithHttpInfo
     *
     * List currencies
     *
     * @param  int $columns The attributes to be loaded (optional)
     * @param  int $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersCurrenciesGetAsyncWithHttpInfo($columns = null, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\Currency[]';
        $request = $this->restOrdersCurrenciesGetRequest($columns, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCurrenciesGet'
     *
     * @param  int $columns The attributes to be loaded (optional)
     * @param  int $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersCurrenciesGetRequest($columns = null, $with = null)
    {

        $resourcePath = '/rest/orders/currencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($columns)) {
            $columns = ObjectSerializer::serializeCollection($columns, '', true);
        }
        if ($columns !== null) {
            $queryParams['columns'] = $columns;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersDatesTypesGet
     *
     * List order date types
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderDateType[]
     */
    public function restOrdersDatesTypesGet()
    {
        list($response) = $this->restOrdersDatesTypesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restOrdersDatesTypesGetWithHttpInfo
     *
     * List order date types
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderDateType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersDatesTypesGetWithHttpInfo()
    {
        $request = $this->restOrdersDatesTypesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderDateType[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderDateType[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderDateType[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderDateType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersDatesTypesGetAsync
     *
     * List order date types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersDatesTypesGetAsync()
    {
        return $this->restOrdersDatesTypesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersDatesTypesGetAsyncWithHttpInfo
     *
     * List order date types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersDatesTypesGetAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\OrderDateType[]';
        $request = $this->restOrdersDatesTypesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersDatesTypesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersDatesTypesGetRequest()
    {

        $resourcePath = '/rest/orders/dates/types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersDatesTypesTypeIdGet
     *
     * Find an order date type
     *
     * @param  int $type_id type_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderDateType
     */
    public function restOrdersDatesTypesTypeIdGet($type_id)
    {
        list($response) = $this->restOrdersDatesTypesTypeIdGetWithHttpInfo($type_id);
        return $response;
    }

    /**
     * Operation restOrdersDatesTypesTypeIdGetWithHttpInfo
     *
     * Find an order date type
     *
     * @param  int $type_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderDateType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersDatesTypesTypeIdGetWithHttpInfo($type_id)
    {
        $request = $this->restOrdersDatesTypesTypeIdGetRequest($type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderDateType' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderDateType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderDateType';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderDateType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersDatesTypesTypeIdGetAsync
     *
     * Find an order date type
     *
     * @param  int $type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersDatesTypesTypeIdGetAsync($type_id)
    {
        return $this->restOrdersDatesTypesTypeIdGetAsyncWithHttpInfo($type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersDatesTypesTypeIdGetAsyncWithHttpInfo
     *
     * Find an order date type
     *
     * @param  int $type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersDatesTypesTypeIdGetAsyncWithHttpInfo($type_id)
    {
        $returnType = '\OpenAPI\Client\Model\OrderDateType';
        $request = $this->restOrdersDatesTypesTypeIdGetRequest($type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersDatesTypesTypeIdGet'
     *
     * @param  int $type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersDatesTypesTypeIdGetRequest($type_id)
    {
        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersDatesTypesTypeIdGet'
            );
        }

        $resourcePath = '/rest/orders/dates/types/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersDatesTypesTypeIdNamesGet
     *
     * List names of an order date type
     *
     * @param  int $type_id The Id of the OrderDateType to be found (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderDateTypeName[]
     */
    public function restOrdersDatesTypesTypeIdNamesGet($type_id)
    {
        list($response) = $this->restOrdersDatesTypesTypeIdNamesGetWithHttpInfo($type_id);
        return $response;
    }

    /**
     * Operation restOrdersDatesTypesTypeIdNamesGetWithHttpInfo
     *
     * List names of an order date type
     *
     * @param  int $type_id The Id of the OrderDateType to be found (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderDateTypeName[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersDatesTypesTypeIdNamesGetWithHttpInfo($type_id)
    {
        $request = $this->restOrdersDatesTypesTypeIdNamesGetRequest($type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderDateTypeName[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderDateTypeName[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderDateTypeName[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderDateTypeName[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersDatesTypesTypeIdNamesGetAsync
     *
     * List names of an order date type
     *
     * @param  int $type_id The Id of the OrderDateType to be found (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersDatesTypesTypeIdNamesGetAsync($type_id)
    {
        return $this->restOrdersDatesTypesTypeIdNamesGetAsyncWithHttpInfo($type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersDatesTypesTypeIdNamesGetAsyncWithHttpInfo
     *
     * List names of an order date type
     *
     * @param  int $type_id The Id of the OrderDateType to be found (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersDatesTypesTypeIdNamesGetAsyncWithHttpInfo($type_id)
    {
        $returnType = '\OpenAPI\Client\Model\OrderDateTypeName[]';
        $request = $this->restOrdersDatesTypesTypeIdNamesGetRequest($type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersDatesTypesTypeIdNamesGet'
     *
     * @param  int $type_id The Id of the OrderDateType to be found (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersDatesTypesTypeIdNamesGetRequest($type_id)
    {
        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersDatesTypesTypeIdNamesGet'
            );
        }

        $resourcePath = '/rest/orders/dates/types/{typeId}/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersDatesTypesTypeIdNamesLangGet
     *
     * Get a name of an order date type
     *
     * @param  int $type_id The ID of the order date type that should be found (required)
     * @param  string $lang The language of the order date type name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderDateTypeName
     */
    public function restOrdersDatesTypesTypeIdNamesLangGet($type_id, $lang)
    {
        list($response) = $this->restOrdersDatesTypesTypeIdNamesLangGetWithHttpInfo($type_id, $lang);
        return $response;
    }

    /**
     * Operation restOrdersDatesTypesTypeIdNamesLangGetWithHttpInfo
     *
     * Get a name of an order date type
     *
     * @param  int $type_id The ID of the order date type that should be found (required)
     * @param  string $lang The language of the order date type name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderDateTypeName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersDatesTypesTypeIdNamesLangGetWithHttpInfo($type_id, $lang)
    {
        $request = $this->restOrdersDatesTypesTypeIdNamesLangGetRequest($type_id, $lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderDateTypeName' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderDateTypeName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderDateTypeName';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderDateTypeName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersDatesTypesTypeIdNamesLangGetAsync
     *
     * Get a name of an order date type
     *
     * @param  int $type_id The ID of the order date type that should be found (required)
     * @param  string $lang The language of the order date type name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersDatesTypesTypeIdNamesLangGetAsync($type_id, $lang)
    {
        return $this->restOrdersDatesTypesTypeIdNamesLangGetAsyncWithHttpInfo($type_id, $lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersDatesTypesTypeIdNamesLangGetAsyncWithHttpInfo
     *
     * Get a name of an order date type
     *
     * @param  int $type_id The ID of the order date type that should be found (required)
     * @param  string $lang The language of the order date type name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersDatesTypesTypeIdNamesLangGetAsyncWithHttpInfo($type_id, $lang)
    {
        $returnType = '\OpenAPI\Client\Model\OrderDateTypeName';
        $request = $this->restOrdersDatesTypesTypeIdNamesLangGetRequest($type_id, $lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersDatesTypesTypeIdNamesLangGet'
     *
     * @param  int $type_id The ID of the order date type that should be found (required)
     * @param  string $lang The language of the order date type name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersDatesTypesTypeIdNamesLangGetRequest($type_id, $lang)
    {
        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersDatesTypesTypeIdNamesLangGet'
            );
        }
        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lang when calling restOrdersDatesTypesTypeIdNamesLangGet'
            );
        }

        $resourcePath = '/rest/orders/dates/types/{typeId}/names/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersDocumentsAccountingSummaryGet
     *
     * List document accounting summaries
     *
     * @param  int $order_id The ID of the order. (optional)
     * @param  string $document_type The document type. The types that can be returned are the following: reversal_document (reversal document for an invoice) and reversal_refund (reversal document for an invoice). (optional)
     * @param  string $created_at_from Get entries with createdAt date after this date. (optional)
     * @param  string $created_at_to Get entries with createdAt date before this date. (optional)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of summaries that should be displayed per page. The default number of orders per page is 10. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersDocumentsAccountingSummaryGet($order_id = null, $document_type = null, $created_at_from = null, $created_at_to = null, $page = null, $items_per_page = null)
    {
        list($response) = $this->restOrdersDocumentsAccountingSummaryGetWithHttpInfo($order_id, $document_type, $created_at_from, $created_at_to, $page, $items_per_page);
        return $response;
    }

    /**
     * Operation restOrdersDocumentsAccountingSummaryGetWithHttpInfo
     *
     * List document accounting summaries
     *
     * @param  int $order_id The ID of the order. (optional)
     * @param  string $document_type The document type. The types that can be returned are the following: reversal_document (reversal document for an invoice) and reversal_refund (reversal document for an invoice). (optional)
     * @param  string $created_at_from Get entries with createdAt date after this date. (optional)
     * @param  string $created_at_to Get entries with createdAt date before this date. (optional)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of summaries that should be displayed per page. The default number of orders per page is 10. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersDocumentsAccountingSummaryGetWithHttpInfo($order_id = null, $document_type = null, $created_at_from = null, $created_at_to = null, $page = null, $items_per_page = null)
    {
        $request = $this->restOrdersDocumentsAccountingSummaryGetRequest($order_id, $document_type, $created_at_from, $created_at_to, $page, $items_per_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersDocumentsAccountingSummaryGetAsync
     *
     * List document accounting summaries
     *
     * @param  int $order_id The ID of the order. (optional)
     * @param  string $document_type The document type. The types that can be returned are the following: reversal_document (reversal document for an invoice) and reversal_refund (reversal document for an invoice). (optional)
     * @param  string $created_at_from Get entries with createdAt date after this date. (optional)
     * @param  string $created_at_to Get entries with createdAt date before this date. (optional)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of summaries that should be displayed per page. The default number of orders per page is 10. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersDocumentsAccountingSummaryGetAsync($order_id = null, $document_type = null, $created_at_from = null, $created_at_to = null, $page = null, $items_per_page = null)
    {
        return $this->restOrdersDocumentsAccountingSummaryGetAsyncWithHttpInfo($order_id, $document_type, $created_at_from, $created_at_to, $page, $items_per_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersDocumentsAccountingSummaryGetAsyncWithHttpInfo
     *
     * List document accounting summaries
     *
     * @param  int $order_id The ID of the order. (optional)
     * @param  string $document_type The document type. The types that can be returned are the following: reversal_document (reversal document for an invoice) and reversal_refund (reversal document for an invoice). (optional)
     * @param  string $created_at_from Get entries with createdAt date after this date. (optional)
     * @param  string $created_at_to Get entries with createdAt date before this date. (optional)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of summaries that should be displayed per page. The default number of orders per page is 10. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersDocumentsAccountingSummaryGetAsyncWithHttpInfo($order_id = null, $document_type = null, $created_at_from = null, $created_at_to = null, $page = null, $items_per_page = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersDocumentsAccountingSummaryGetRequest($order_id, $document_type, $created_at_from, $created_at_to, $page, $items_per_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersDocumentsAccountingSummaryGet'
     *
     * @param  int $order_id The ID of the order. (optional)
     * @param  string $document_type The document type. The types that can be returned are the following: reversal_document (reversal document for an invoice) and reversal_refund (reversal document for an invoice). (optional)
     * @param  string $created_at_from Get entries with createdAt date after this date. (optional)
     * @param  string $created_at_to Get entries with createdAt date before this date. (optional)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of summaries that should be displayed per page. The default number of orders per page is 10. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersDocumentsAccountingSummaryGetRequest($order_id = null, $document_type = null, $created_at_from = null, $created_at_to = null, $page = null, $items_per_page = null)
    {

        $resourcePath = '/rest/orders/documents/accounting_summary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($order_id)) {
            $order_id = ObjectSerializer::serializeCollection($order_id, '', true);
        }
        if ($order_id !== null) {
            $queryParams['orderId'] = $order_id;
        }
        // query params
        if (is_array($document_type)) {
            $document_type = ObjectSerializer::serializeCollection($document_type, '', true);
        }
        if ($document_type !== null) {
            $queryParams['documentType'] = $document_type;
        }
        // query params
        if (is_array($created_at_from)) {
            $created_at_from = ObjectSerializer::serializeCollection($created_at_from, '', true);
        }
        if ($created_at_from !== null) {
            $queryParams['createdAtFrom'] = $created_at_from;
        }
        // query params
        if (is_array($created_at_to)) {
            $created_at_to = ObjectSerializer::serializeCollection($created_at_to, '', true);
        }
        if ($created_at_to !== null) {
            $queryParams['createdAtTo'] = $created_at_to;
        }
        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersGet
     *
     * Search order
     *
     * @param  string $order_type Filter that restricts the search result to orders of specific order types. The ID of the order types must be specified. Several order type IDs can be entered separated by commas. @see order model typeId (optional)
     * @param  int $contact_id Filter that restricts the search result to orders of a contact. The ID of the contact must be specified. (optional)
     * @param  int $referrer_id Filter that restricts the search result to orders of a specific order referrer. The ID of the order referrer must be specified. (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to orders with a specific shipping profile. The ID of shipping profile must be specified. (optional)
     * @param  int $shipping_service_provider_id Filter that restricts the search result to orders with a specific shipping service provider (like DHL, UPS, etc.). The ID of shipping service provider must be specified. (optional)
     * @param  int $owner_user_id Filter that restricts the search result to orders with a specific owner. The user ID of the owner must be specified. (optional)
     * @param  int $warehouse_id Filter that restricts the search result to orders with a specific main warehouse. The ID of the warehouse must be specified. (optional)
     * @param  bool $is_ebay_plus Filter that restricts the search result to orders with the referrer eBay PLUS. (optional)
     * @param  int $included_variation Filter that restricts the search result to orders including a specific variation. The ID of the variation must be specified. (optional)
     * @param  int $included_item Filter that restricts the search result to orders including a specific item. The ID of the item must be specified. (optional)
     * @param  int $order_ids Filter that restricts the search result to orders with a specific ID. To list several orders, the order IDs must be enetered separated by commas. (optional)
     * @param  int $country_id Filter that restricts the search result to orders with a specific delivery or invoice country. The ID of the country must be specified. (optional)
     * @param  string $order_item_name Filter that restricts the search result to orders including a specific item name. The name of the item must be specified. (optional)
     * @param  int $variation_number Filter that restricts the search result to orders including a specific variation number. The number of the variation must be specified. (optional)
     * @param  int $sender_contact Filter that restricts the search result to orders including a specific sender of the type contact. For example, the supplier is a sender of the type contact for reorders. The ID of the sender must be specified. (optional)
     * @param  int $sender_warehouse Filter that restricts the search result to orders including a specific sender of the type warehouse. For example, the sending warehouse is a sender of the type warehouse for redistributions. The ID of the sender must be specified. (optional)
     * @param  int $receiver_contact Filter that restricts the search result to orders including a specific receiver of the type contact. For example, a receiver of the type contact is the recipient of a main order. The ID of the receiver must be specified. (optional)
     * @param  int $receiver_warehouse Filter that restricts the search result to orders with a specific receiver of the type warehouse. TFor example, the receiving receiving warehouse is a receiver of the type warehouse for redistributions. The ID of the receiver must be specified. (optional)
     * @param  string $external_order_id Filter that restricts the search result to orders including a specific external order ID. The external order ID must be specified. (optional)
     * @param  int $client_id Filter that restricts the search result to orders belonging to a specific client. The ID of the client must be specified. (optional)
     * @param  string $payment_status Filter that restricts the search result to orders with a specific payment status. Valid values are unpaid, partlyPaid, fullyPaid, overpaid. One of these values must be specified. (optional)
     * @param  string $updated_at_from Filter that restricts the search result to orders that were last updated on a specified date. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to orders that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_from Filter that restricts the search result to orders that were created from a specified date up to the present date. This filter can be used alone or can be combined with the CreatedAtTo filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to orders that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $paid_at_from Filter that restricts the search result to orders that received a payment on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $paid_at_to Filter that restricts the search result to orders that received a payment within a certain period of time. This filter can be used alone or can be combined with the paidAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $outgoing_items_booked_at_from Filter that restricts the search result to orders where the outgoing items were booked on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $outgoing_items_booked_at_to Filter that restricts the search result to orders where the outgoing items were booked within a specified period of time. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $status_from Filter that restricts the search result to orders in a specific order status. The value of the order status must be specified. (optional)
     * @param  int $status_to Filter that restricts the search result to orders within a range of order statuses. This filter can be used alone or can be combined with the statusFrom filter. The value of the order status must be specified. (optional)
     * @param  string $has_document Filter that restricts the search result to orders which hold the given document type. Valid values are &lt;i&gt;multi_invoice&lt;/i&gt;, &lt;i&gt;multi_credit_note&lt;/i&gt;, &lt;i&gt;success_confirmation&lt;/i&gt;, &lt;i&gt;return_note&lt;/i&gt;, &lt;i&gt;pickup_delivery&lt;/i&gt;, &lt;i&gt;repair_bill&lt;/i&gt;, &lt;i&gt;dunning_letter&lt;/i&gt;, &lt;i&gt;offer&lt;/i&gt;, &lt;i&gt;order_confirmation&lt;/i&gt;, &lt;i&gt;credit_note&lt;/i&gt;, &lt;i&gt;correction_document&lt;/i&gt;, &lt;i&gt;delivery_note&lt;/i&gt;, &lt;i&gt;invoice&lt;/i&gt;, &lt;i&gt;invoice_external&lt;/i&gt;, &lt;i&gt;receipt&lt;/i&gt; (optional)
     * @param  string $has_document_number Filter that restricts the search result to orders which hold documents with given number. (optional)
     * @param  int $parent_order_id Filter that restricts the search result to orders which have the given order ID as parent. (optional)
     * @param  bool $add_order_items Add the order items to the results. Default &#x3D; true. (optional)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int $with Load additional relations for an order. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the the reference type, the ID of the reference and the relation itself.&lt;/li&gt;     &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;     &lt;li&gt;&#39;location&#39; &#x3D; The accounting location of the order.&lt;/li&gt;     &lt;li&gt;&#39;payments&#39; &#x3D; The payments that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;documents&#39; &#x3D; The documents that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;contactSender&#39; &#x3D; The associated contact for the contact-sender relation.&lt;/li&gt;     &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The associated contact for the contact-receiver relation.&lt;/li&gt;     &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The associated warehouse for the warehouse-sender relation.&lt;/li&gt;     &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The associated warehouse for the warehouse-receiver relation.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation that is associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes that are associated with variation of the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;originOrderReferences&#39; &#x3D; The references to other orders, e.g. returns or credit notes, associated with this order.&lt;/li&gt;     &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;     &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations that are associated with the order item.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20036
     */
    public function restOrdersGet($order_type = null, $contact_id = null, $referrer_id = null, $shipping_profile_id = null, $shipping_service_provider_id = null, $owner_user_id = null, $warehouse_id = null, $is_ebay_plus = null, $included_variation = null, $included_item = null, $order_ids = null, $country_id = null, $order_item_name = null, $variation_number = null, $sender_contact = null, $sender_warehouse = null, $receiver_contact = null, $receiver_warehouse = null, $external_order_id = null, $client_id = null, $payment_status = null, $updated_at_from = null, $updated_at_to = null, $created_at_from = null, $created_at_to = null, $paid_at_from = null, $paid_at_to = null, $outgoing_items_booked_at_from = null, $outgoing_items_booked_at_to = null, $status_from = null, $status_to = null, $has_document = null, $has_document_number = null, $parent_order_id = null, $add_order_items = null, $page = null, $items_per_page = null, $with = null)
    {
        list($response) = $this->restOrdersGetWithHttpInfo($order_type, $contact_id, $referrer_id, $shipping_profile_id, $shipping_service_provider_id, $owner_user_id, $warehouse_id, $is_ebay_plus, $included_variation, $included_item, $order_ids, $country_id, $order_item_name, $variation_number, $sender_contact, $sender_warehouse, $receiver_contact, $receiver_warehouse, $external_order_id, $client_id, $payment_status, $updated_at_from, $updated_at_to, $created_at_from, $created_at_to, $paid_at_from, $paid_at_to, $outgoing_items_booked_at_from, $outgoing_items_booked_at_to, $status_from, $status_to, $has_document, $has_document_number, $parent_order_id, $add_order_items, $page, $items_per_page, $with);
        return $response;
    }

    /**
     * Operation restOrdersGetWithHttpInfo
     *
     * Search order
     *
     * @param  string $order_type Filter that restricts the search result to orders of specific order types. The ID of the order types must be specified. Several order type IDs can be entered separated by commas. @see order model typeId (optional)
     * @param  int $contact_id Filter that restricts the search result to orders of a contact. The ID of the contact must be specified. (optional)
     * @param  int $referrer_id Filter that restricts the search result to orders of a specific order referrer. The ID of the order referrer must be specified. (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to orders with a specific shipping profile. The ID of shipping profile must be specified. (optional)
     * @param  int $shipping_service_provider_id Filter that restricts the search result to orders with a specific shipping service provider (like DHL, UPS, etc.). The ID of shipping service provider must be specified. (optional)
     * @param  int $owner_user_id Filter that restricts the search result to orders with a specific owner. The user ID of the owner must be specified. (optional)
     * @param  int $warehouse_id Filter that restricts the search result to orders with a specific main warehouse. The ID of the warehouse must be specified. (optional)
     * @param  bool $is_ebay_plus Filter that restricts the search result to orders with the referrer eBay PLUS. (optional)
     * @param  int $included_variation Filter that restricts the search result to orders including a specific variation. The ID of the variation must be specified. (optional)
     * @param  int $included_item Filter that restricts the search result to orders including a specific item. The ID of the item must be specified. (optional)
     * @param  int $order_ids Filter that restricts the search result to orders with a specific ID. To list several orders, the order IDs must be enetered separated by commas. (optional)
     * @param  int $country_id Filter that restricts the search result to orders with a specific delivery or invoice country. The ID of the country must be specified. (optional)
     * @param  string $order_item_name Filter that restricts the search result to orders including a specific item name. The name of the item must be specified. (optional)
     * @param  int $variation_number Filter that restricts the search result to orders including a specific variation number. The number of the variation must be specified. (optional)
     * @param  int $sender_contact Filter that restricts the search result to orders including a specific sender of the type contact. For example, the supplier is a sender of the type contact for reorders. The ID of the sender must be specified. (optional)
     * @param  int $sender_warehouse Filter that restricts the search result to orders including a specific sender of the type warehouse. For example, the sending warehouse is a sender of the type warehouse for redistributions. The ID of the sender must be specified. (optional)
     * @param  int $receiver_contact Filter that restricts the search result to orders including a specific receiver of the type contact. For example, a receiver of the type contact is the recipient of a main order. The ID of the receiver must be specified. (optional)
     * @param  int $receiver_warehouse Filter that restricts the search result to orders with a specific receiver of the type warehouse. TFor example, the receiving receiving warehouse is a receiver of the type warehouse for redistributions. The ID of the receiver must be specified. (optional)
     * @param  string $external_order_id Filter that restricts the search result to orders including a specific external order ID. The external order ID must be specified. (optional)
     * @param  int $client_id Filter that restricts the search result to orders belonging to a specific client. The ID of the client must be specified. (optional)
     * @param  string $payment_status Filter that restricts the search result to orders with a specific payment status. Valid values are unpaid, partlyPaid, fullyPaid, overpaid. One of these values must be specified. (optional)
     * @param  string $updated_at_from Filter that restricts the search result to orders that were last updated on a specified date. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to orders that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_from Filter that restricts the search result to orders that were created from a specified date up to the present date. This filter can be used alone or can be combined with the CreatedAtTo filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to orders that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $paid_at_from Filter that restricts the search result to orders that received a payment on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $paid_at_to Filter that restricts the search result to orders that received a payment within a certain period of time. This filter can be used alone or can be combined with the paidAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $outgoing_items_booked_at_from Filter that restricts the search result to orders where the outgoing items were booked on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $outgoing_items_booked_at_to Filter that restricts the search result to orders where the outgoing items were booked within a specified period of time. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $status_from Filter that restricts the search result to orders in a specific order status. The value of the order status must be specified. (optional)
     * @param  int $status_to Filter that restricts the search result to orders within a range of order statuses. This filter can be used alone or can be combined with the statusFrom filter. The value of the order status must be specified. (optional)
     * @param  string $has_document Filter that restricts the search result to orders which hold the given document type. Valid values are &lt;i&gt;multi_invoice&lt;/i&gt;, &lt;i&gt;multi_credit_note&lt;/i&gt;, &lt;i&gt;success_confirmation&lt;/i&gt;, &lt;i&gt;return_note&lt;/i&gt;, &lt;i&gt;pickup_delivery&lt;/i&gt;, &lt;i&gt;repair_bill&lt;/i&gt;, &lt;i&gt;dunning_letter&lt;/i&gt;, &lt;i&gt;offer&lt;/i&gt;, &lt;i&gt;order_confirmation&lt;/i&gt;, &lt;i&gt;credit_note&lt;/i&gt;, &lt;i&gt;correction_document&lt;/i&gt;, &lt;i&gt;delivery_note&lt;/i&gt;, &lt;i&gt;invoice&lt;/i&gt;, &lt;i&gt;invoice_external&lt;/i&gt;, &lt;i&gt;receipt&lt;/i&gt; (optional)
     * @param  string $has_document_number Filter that restricts the search result to orders which hold documents with given number. (optional)
     * @param  int $parent_order_id Filter that restricts the search result to orders which have the given order ID as parent. (optional)
     * @param  bool $add_order_items Add the order items to the results. Default &#x3D; true. (optional)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int $with Load additional relations for an order. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the the reference type, the ID of the reference and the relation itself.&lt;/li&gt;     &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;     &lt;li&gt;&#39;location&#39; &#x3D; The accounting location of the order.&lt;/li&gt;     &lt;li&gt;&#39;payments&#39; &#x3D; The payments that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;documents&#39; &#x3D; The documents that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;contactSender&#39; &#x3D; The associated contact for the contact-sender relation.&lt;/li&gt;     &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The associated contact for the contact-receiver relation.&lt;/li&gt;     &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The associated warehouse for the warehouse-sender relation.&lt;/li&gt;     &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The associated warehouse for the warehouse-receiver relation.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation that is associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes that are associated with variation of the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;originOrderReferences&#39; &#x3D; The references to other orders, e.g. returns or credit notes, associated with this order.&lt;/li&gt;     &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;     &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations that are associated with the order item.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20036, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersGetWithHttpInfo($order_type = null, $contact_id = null, $referrer_id = null, $shipping_profile_id = null, $shipping_service_provider_id = null, $owner_user_id = null, $warehouse_id = null, $is_ebay_plus = null, $included_variation = null, $included_item = null, $order_ids = null, $country_id = null, $order_item_name = null, $variation_number = null, $sender_contact = null, $sender_warehouse = null, $receiver_contact = null, $receiver_warehouse = null, $external_order_id = null, $client_id = null, $payment_status = null, $updated_at_from = null, $updated_at_to = null, $created_at_from = null, $created_at_to = null, $paid_at_from = null, $paid_at_to = null, $outgoing_items_booked_at_from = null, $outgoing_items_booked_at_to = null, $status_from = null, $status_to = null, $has_document = null, $has_document_number = null, $parent_order_id = null, $add_order_items = null, $page = null, $items_per_page = null, $with = null)
    {
        $request = $this->restOrdersGetRequest($order_type, $contact_id, $referrer_id, $shipping_profile_id, $shipping_service_provider_id, $owner_user_id, $warehouse_id, $is_ebay_plus, $included_variation, $included_item, $order_ids, $country_id, $order_item_name, $variation_number, $sender_contact, $sender_warehouse, $receiver_contact, $receiver_warehouse, $external_order_id, $client_id, $payment_status, $updated_at_from, $updated_at_to, $created_at_from, $created_at_to, $paid_at_from, $paid_at_to, $outgoing_items_booked_at_from, $outgoing_items_booked_at_to, $status_from, $status_to, $has_document, $has_document_number, $parent_order_id, $add_order_items, $page, $items_per_page, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20036' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20036', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20036';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20036',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersGetAsync
     *
     * Search order
     *
     * @param  string $order_type Filter that restricts the search result to orders of specific order types. The ID of the order types must be specified. Several order type IDs can be entered separated by commas. @see order model typeId (optional)
     * @param  int $contact_id Filter that restricts the search result to orders of a contact. The ID of the contact must be specified. (optional)
     * @param  int $referrer_id Filter that restricts the search result to orders of a specific order referrer. The ID of the order referrer must be specified. (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to orders with a specific shipping profile. The ID of shipping profile must be specified. (optional)
     * @param  int $shipping_service_provider_id Filter that restricts the search result to orders with a specific shipping service provider (like DHL, UPS, etc.). The ID of shipping service provider must be specified. (optional)
     * @param  int $owner_user_id Filter that restricts the search result to orders with a specific owner. The user ID of the owner must be specified. (optional)
     * @param  int $warehouse_id Filter that restricts the search result to orders with a specific main warehouse. The ID of the warehouse must be specified. (optional)
     * @param  bool $is_ebay_plus Filter that restricts the search result to orders with the referrer eBay PLUS. (optional)
     * @param  int $included_variation Filter that restricts the search result to orders including a specific variation. The ID of the variation must be specified. (optional)
     * @param  int $included_item Filter that restricts the search result to orders including a specific item. The ID of the item must be specified. (optional)
     * @param  int $order_ids Filter that restricts the search result to orders with a specific ID. To list several orders, the order IDs must be enetered separated by commas. (optional)
     * @param  int $country_id Filter that restricts the search result to orders with a specific delivery or invoice country. The ID of the country must be specified. (optional)
     * @param  string $order_item_name Filter that restricts the search result to orders including a specific item name. The name of the item must be specified. (optional)
     * @param  int $variation_number Filter that restricts the search result to orders including a specific variation number. The number of the variation must be specified. (optional)
     * @param  int $sender_contact Filter that restricts the search result to orders including a specific sender of the type contact. For example, the supplier is a sender of the type contact for reorders. The ID of the sender must be specified. (optional)
     * @param  int $sender_warehouse Filter that restricts the search result to orders including a specific sender of the type warehouse. For example, the sending warehouse is a sender of the type warehouse for redistributions. The ID of the sender must be specified. (optional)
     * @param  int $receiver_contact Filter that restricts the search result to orders including a specific receiver of the type contact. For example, a receiver of the type contact is the recipient of a main order. The ID of the receiver must be specified. (optional)
     * @param  int $receiver_warehouse Filter that restricts the search result to orders with a specific receiver of the type warehouse. TFor example, the receiving receiving warehouse is a receiver of the type warehouse for redistributions. The ID of the receiver must be specified. (optional)
     * @param  string $external_order_id Filter that restricts the search result to orders including a specific external order ID. The external order ID must be specified. (optional)
     * @param  int $client_id Filter that restricts the search result to orders belonging to a specific client. The ID of the client must be specified. (optional)
     * @param  string $payment_status Filter that restricts the search result to orders with a specific payment status. Valid values are unpaid, partlyPaid, fullyPaid, overpaid. One of these values must be specified. (optional)
     * @param  string $updated_at_from Filter that restricts the search result to orders that were last updated on a specified date. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to orders that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_from Filter that restricts the search result to orders that were created from a specified date up to the present date. This filter can be used alone or can be combined with the CreatedAtTo filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to orders that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $paid_at_from Filter that restricts the search result to orders that received a payment on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $paid_at_to Filter that restricts the search result to orders that received a payment within a certain period of time. This filter can be used alone or can be combined with the paidAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $outgoing_items_booked_at_from Filter that restricts the search result to orders where the outgoing items were booked on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $outgoing_items_booked_at_to Filter that restricts the search result to orders where the outgoing items were booked within a specified period of time. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $status_from Filter that restricts the search result to orders in a specific order status. The value of the order status must be specified. (optional)
     * @param  int $status_to Filter that restricts the search result to orders within a range of order statuses. This filter can be used alone or can be combined with the statusFrom filter. The value of the order status must be specified. (optional)
     * @param  string $has_document Filter that restricts the search result to orders which hold the given document type. Valid values are &lt;i&gt;multi_invoice&lt;/i&gt;, &lt;i&gt;multi_credit_note&lt;/i&gt;, &lt;i&gt;success_confirmation&lt;/i&gt;, &lt;i&gt;return_note&lt;/i&gt;, &lt;i&gt;pickup_delivery&lt;/i&gt;, &lt;i&gt;repair_bill&lt;/i&gt;, &lt;i&gt;dunning_letter&lt;/i&gt;, &lt;i&gt;offer&lt;/i&gt;, &lt;i&gt;order_confirmation&lt;/i&gt;, &lt;i&gt;credit_note&lt;/i&gt;, &lt;i&gt;correction_document&lt;/i&gt;, &lt;i&gt;delivery_note&lt;/i&gt;, &lt;i&gt;invoice&lt;/i&gt;, &lt;i&gt;invoice_external&lt;/i&gt;, &lt;i&gt;receipt&lt;/i&gt; (optional)
     * @param  string $has_document_number Filter that restricts the search result to orders which hold documents with given number. (optional)
     * @param  int $parent_order_id Filter that restricts the search result to orders which have the given order ID as parent. (optional)
     * @param  bool $add_order_items Add the order items to the results. Default &#x3D; true. (optional)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int $with Load additional relations for an order. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the the reference type, the ID of the reference and the relation itself.&lt;/li&gt;     &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;     &lt;li&gt;&#39;location&#39; &#x3D; The accounting location of the order.&lt;/li&gt;     &lt;li&gt;&#39;payments&#39; &#x3D; The payments that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;documents&#39; &#x3D; The documents that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;contactSender&#39; &#x3D; The associated contact for the contact-sender relation.&lt;/li&gt;     &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The associated contact for the contact-receiver relation.&lt;/li&gt;     &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The associated warehouse for the warehouse-sender relation.&lt;/li&gt;     &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The associated warehouse for the warehouse-receiver relation.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation that is associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes that are associated with variation of the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;originOrderReferences&#39; &#x3D; The references to other orders, e.g. returns or credit notes, associated with this order.&lt;/li&gt;     &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;     &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations that are associated with the order item.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersGetAsync($order_type = null, $contact_id = null, $referrer_id = null, $shipping_profile_id = null, $shipping_service_provider_id = null, $owner_user_id = null, $warehouse_id = null, $is_ebay_plus = null, $included_variation = null, $included_item = null, $order_ids = null, $country_id = null, $order_item_name = null, $variation_number = null, $sender_contact = null, $sender_warehouse = null, $receiver_contact = null, $receiver_warehouse = null, $external_order_id = null, $client_id = null, $payment_status = null, $updated_at_from = null, $updated_at_to = null, $created_at_from = null, $created_at_to = null, $paid_at_from = null, $paid_at_to = null, $outgoing_items_booked_at_from = null, $outgoing_items_booked_at_to = null, $status_from = null, $status_to = null, $has_document = null, $has_document_number = null, $parent_order_id = null, $add_order_items = null, $page = null, $items_per_page = null, $with = null)
    {
        return $this->restOrdersGetAsyncWithHttpInfo($order_type, $contact_id, $referrer_id, $shipping_profile_id, $shipping_service_provider_id, $owner_user_id, $warehouse_id, $is_ebay_plus, $included_variation, $included_item, $order_ids, $country_id, $order_item_name, $variation_number, $sender_contact, $sender_warehouse, $receiver_contact, $receiver_warehouse, $external_order_id, $client_id, $payment_status, $updated_at_from, $updated_at_to, $created_at_from, $created_at_to, $paid_at_from, $paid_at_to, $outgoing_items_booked_at_from, $outgoing_items_booked_at_to, $status_from, $status_to, $has_document, $has_document_number, $parent_order_id, $add_order_items, $page, $items_per_page, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersGetAsyncWithHttpInfo
     *
     * Search order
     *
     * @param  string $order_type Filter that restricts the search result to orders of specific order types. The ID of the order types must be specified. Several order type IDs can be entered separated by commas. @see order model typeId (optional)
     * @param  int $contact_id Filter that restricts the search result to orders of a contact. The ID of the contact must be specified. (optional)
     * @param  int $referrer_id Filter that restricts the search result to orders of a specific order referrer. The ID of the order referrer must be specified. (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to orders with a specific shipping profile. The ID of shipping profile must be specified. (optional)
     * @param  int $shipping_service_provider_id Filter that restricts the search result to orders with a specific shipping service provider (like DHL, UPS, etc.). The ID of shipping service provider must be specified. (optional)
     * @param  int $owner_user_id Filter that restricts the search result to orders with a specific owner. The user ID of the owner must be specified. (optional)
     * @param  int $warehouse_id Filter that restricts the search result to orders with a specific main warehouse. The ID of the warehouse must be specified. (optional)
     * @param  bool $is_ebay_plus Filter that restricts the search result to orders with the referrer eBay PLUS. (optional)
     * @param  int $included_variation Filter that restricts the search result to orders including a specific variation. The ID of the variation must be specified. (optional)
     * @param  int $included_item Filter that restricts the search result to orders including a specific item. The ID of the item must be specified. (optional)
     * @param  int $order_ids Filter that restricts the search result to orders with a specific ID. To list several orders, the order IDs must be enetered separated by commas. (optional)
     * @param  int $country_id Filter that restricts the search result to orders with a specific delivery or invoice country. The ID of the country must be specified. (optional)
     * @param  string $order_item_name Filter that restricts the search result to orders including a specific item name. The name of the item must be specified. (optional)
     * @param  int $variation_number Filter that restricts the search result to orders including a specific variation number. The number of the variation must be specified. (optional)
     * @param  int $sender_contact Filter that restricts the search result to orders including a specific sender of the type contact. For example, the supplier is a sender of the type contact for reorders. The ID of the sender must be specified. (optional)
     * @param  int $sender_warehouse Filter that restricts the search result to orders including a specific sender of the type warehouse. For example, the sending warehouse is a sender of the type warehouse for redistributions. The ID of the sender must be specified. (optional)
     * @param  int $receiver_contact Filter that restricts the search result to orders including a specific receiver of the type contact. For example, a receiver of the type contact is the recipient of a main order. The ID of the receiver must be specified. (optional)
     * @param  int $receiver_warehouse Filter that restricts the search result to orders with a specific receiver of the type warehouse. TFor example, the receiving receiving warehouse is a receiver of the type warehouse for redistributions. The ID of the receiver must be specified. (optional)
     * @param  string $external_order_id Filter that restricts the search result to orders including a specific external order ID. The external order ID must be specified. (optional)
     * @param  int $client_id Filter that restricts the search result to orders belonging to a specific client. The ID of the client must be specified. (optional)
     * @param  string $payment_status Filter that restricts the search result to orders with a specific payment status. Valid values are unpaid, partlyPaid, fullyPaid, overpaid. One of these values must be specified. (optional)
     * @param  string $updated_at_from Filter that restricts the search result to orders that were last updated on a specified date. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to orders that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_from Filter that restricts the search result to orders that were created from a specified date up to the present date. This filter can be used alone or can be combined with the CreatedAtTo filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to orders that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $paid_at_from Filter that restricts the search result to orders that received a payment on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $paid_at_to Filter that restricts the search result to orders that received a payment within a certain period of time. This filter can be used alone or can be combined with the paidAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $outgoing_items_booked_at_from Filter that restricts the search result to orders where the outgoing items were booked on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $outgoing_items_booked_at_to Filter that restricts the search result to orders where the outgoing items were booked within a specified period of time. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $status_from Filter that restricts the search result to orders in a specific order status. The value of the order status must be specified. (optional)
     * @param  int $status_to Filter that restricts the search result to orders within a range of order statuses. This filter can be used alone or can be combined with the statusFrom filter. The value of the order status must be specified. (optional)
     * @param  string $has_document Filter that restricts the search result to orders which hold the given document type. Valid values are &lt;i&gt;multi_invoice&lt;/i&gt;, &lt;i&gt;multi_credit_note&lt;/i&gt;, &lt;i&gt;success_confirmation&lt;/i&gt;, &lt;i&gt;return_note&lt;/i&gt;, &lt;i&gt;pickup_delivery&lt;/i&gt;, &lt;i&gt;repair_bill&lt;/i&gt;, &lt;i&gt;dunning_letter&lt;/i&gt;, &lt;i&gt;offer&lt;/i&gt;, &lt;i&gt;order_confirmation&lt;/i&gt;, &lt;i&gt;credit_note&lt;/i&gt;, &lt;i&gt;correction_document&lt;/i&gt;, &lt;i&gt;delivery_note&lt;/i&gt;, &lt;i&gt;invoice&lt;/i&gt;, &lt;i&gt;invoice_external&lt;/i&gt;, &lt;i&gt;receipt&lt;/i&gt; (optional)
     * @param  string $has_document_number Filter that restricts the search result to orders which hold documents with given number. (optional)
     * @param  int $parent_order_id Filter that restricts the search result to orders which have the given order ID as parent. (optional)
     * @param  bool $add_order_items Add the order items to the results. Default &#x3D; true. (optional)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int $with Load additional relations for an order. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the the reference type, the ID of the reference and the relation itself.&lt;/li&gt;     &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;     &lt;li&gt;&#39;location&#39; &#x3D; The accounting location of the order.&lt;/li&gt;     &lt;li&gt;&#39;payments&#39; &#x3D; The payments that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;documents&#39; &#x3D; The documents that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;contactSender&#39; &#x3D; The associated contact for the contact-sender relation.&lt;/li&gt;     &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The associated contact for the contact-receiver relation.&lt;/li&gt;     &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The associated warehouse for the warehouse-sender relation.&lt;/li&gt;     &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The associated warehouse for the warehouse-receiver relation.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation that is associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes that are associated with variation of the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;originOrderReferences&#39; &#x3D; The references to other orders, e.g. returns or credit notes, associated with this order.&lt;/li&gt;     &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;     &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations that are associated with the order item.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersGetAsyncWithHttpInfo($order_type = null, $contact_id = null, $referrer_id = null, $shipping_profile_id = null, $shipping_service_provider_id = null, $owner_user_id = null, $warehouse_id = null, $is_ebay_plus = null, $included_variation = null, $included_item = null, $order_ids = null, $country_id = null, $order_item_name = null, $variation_number = null, $sender_contact = null, $sender_warehouse = null, $receiver_contact = null, $receiver_warehouse = null, $external_order_id = null, $client_id = null, $payment_status = null, $updated_at_from = null, $updated_at_to = null, $created_at_from = null, $created_at_to = null, $paid_at_from = null, $paid_at_to = null, $outgoing_items_booked_at_from = null, $outgoing_items_booked_at_to = null, $status_from = null, $status_to = null, $has_document = null, $has_document_number = null, $parent_order_id = null, $add_order_items = null, $page = null, $items_per_page = null, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20036';
        $request = $this->restOrdersGetRequest($order_type, $contact_id, $referrer_id, $shipping_profile_id, $shipping_service_provider_id, $owner_user_id, $warehouse_id, $is_ebay_plus, $included_variation, $included_item, $order_ids, $country_id, $order_item_name, $variation_number, $sender_contact, $sender_warehouse, $receiver_contact, $receiver_warehouse, $external_order_id, $client_id, $payment_status, $updated_at_from, $updated_at_to, $created_at_from, $created_at_to, $paid_at_from, $paid_at_to, $outgoing_items_booked_at_from, $outgoing_items_booked_at_to, $status_from, $status_to, $has_document, $has_document_number, $parent_order_id, $add_order_items, $page, $items_per_page, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersGet'
     *
     * @param  string $order_type Filter that restricts the search result to orders of specific order types. The ID of the order types must be specified. Several order type IDs can be entered separated by commas. @see order model typeId (optional)
     * @param  int $contact_id Filter that restricts the search result to orders of a contact. The ID of the contact must be specified. (optional)
     * @param  int $referrer_id Filter that restricts the search result to orders of a specific order referrer. The ID of the order referrer must be specified. (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to orders with a specific shipping profile. The ID of shipping profile must be specified. (optional)
     * @param  int $shipping_service_provider_id Filter that restricts the search result to orders with a specific shipping service provider (like DHL, UPS, etc.). The ID of shipping service provider must be specified. (optional)
     * @param  int $owner_user_id Filter that restricts the search result to orders with a specific owner. The user ID of the owner must be specified. (optional)
     * @param  int $warehouse_id Filter that restricts the search result to orders with a specific main warehouse. The ID of the warehouse must be specified. (optional)
     * @param  bool $is_ebay_plus Filter that restricts the search result to orders with the referrer eBay PLUS. (optional)
     * @param  int $included_variation Filter that restricts the search result to orders including a specific variation. The ID of the variation must be specified. (optional)
     * @param  int $included_item Filter that restricts the search result to orders including a specific item. The ID of the item must be specified. (optional)
     * @param  int $order_ids Filter that restricts the search result to orders with a specific ID. To list several orders, the order IDs must be enetered separated by commas. (optional)
     * @param  int $country_id Filter that restricts the search result to orders with a specific delivery or invoice country. The ID of the country must be specified. (optional)
     * @param  string $order_item_name Filter that restricts the search result to orders including a specific item name. The name of the item must be specified. (optional)
     * @param  int $variation_number Filter that restricts the search result to orders including a specific variation number. The number of the variation must be specified. (optional)
     * @param  int $sender_contact Filter that restricts the search result to orders including a specific sender of the type contact. For example, the supplier is a sender of the type contact for reorders. The ID of the sender must be specified. (optional)
     * @param  int $sender_warehouse Filter that restricts the search result to orders including a specific sender of the type warehouse. For example, the sending warehouse is a sender of the type warehouse for redistributions. The ID of the sender must be specified. (optional)
     * @param  int $receiver_contact Filter that restricts the search result to orders including a specific receiver of the type contact. For example, a receiver of the type contact is the recipient of a main order. The ID of the receiver must be specified. (optional)
     * @param  int $receiver_warehouse Filter that restricts the search result to orders with a specific receiver of the type warehouse. TFor example, the receiving receiving warehouse is a receiver of the type warehouse for redistributions. The ID of the receiver must be specified. (optional)
     * @param  string $external_order_id Filter that restricts the search result to orders including a specific external order ID. The external order ID must be specified. (optional)
     * @param  int $client_id Filter that restricts the search result to orders belonging to a specific client. The ID of the client must be specified. (optional)
     * @param  string $payment_status Filter that restricts the search result to orders with a specific payment status. Valid values are unpaid, partlyPaid, fullyPaid, overpaid. One of these values must be specified. (optional)
     * @param  string $updated_at_from Filter that restricts the search result to orders that were last updated on a specified date. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to orders that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_from Filter that restricts the search result to orders that were created from a specified date up to the present date. This filter can be used alone or can be combined with the CreatedAtTo filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to orders that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $paid_at_from Filter that restricts the search result to orders that received a payment on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $paid_at_to Filter that restricts the search result to orders that received a payment within a certain period of time. This filter can be used alone or can be combined with the paidAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $outgoing_items_booked_at_from Filter that restricts the search result to orders where the outgoing items were booked on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $outgoing_items_booked_at_to Filter that restricts the search result to orders where the outgoing items were booked within a specified period of time. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $status_from Filter that restricts the search result to orders in a specific order status. The value of the order status must be specified. (optional)
     * @param  int $status_to Filter that restricts the search result to orders within a range of order statuses. This filter can be used alone or can be combined with the statusFrom filter. The value of the order status must be specified. (optional)
     * @param  string $has_document Filter that restricts the search result to orders which hold the given document type. Valid values are &lt;i&gt;multi_invoice&lt;/i&gt;, &lt;i&gt;multi_credit_note&lt;/i&gt;, &lt;i&gt;success_confirmation&lt;/i&gt;, &lt;i&gt;return_note&lt;/i&gt;, &lt;i&gt;pickup_delivery&lt;/i&gt;, &lt;i&gt;repair_bill&lt;/i&gt;, &lt;i&gt;dunning_letter&lt;/i&gt;, &lt;i&gt;offer&lt;/i&gt;, &lt;i&gt;order_confirmation&lt;/i&gt;, &lt;i&gt;credit_note&lt;/i&gt;, &lt;i&gt;correction_document&lt;/i&gt;, &lt;i&gt;delivery_note&lt;/i&gt;, &lt;i&gt;invoice&lt;/i&gt;, &lt;i&gt;invoice_external&lt;/i&gt;, &lt;i&gt;receipt&lt;/i&gt; (optional)
     * @param  string $has_document_number Filter that restricts the search result to orders which hold documents with given number. (optional)
     * @param  int $parent_order_id Filter that restricts the search result to orders which have the given order ID as parent. (optional)
     * @param  bool $add_order_items Add the order items to the results. Default &#x3D; true. (optional)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int $with Load additional relations for an order. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the the reference type, the ID of the reference and the relation itself.&lt;/li&gt;     &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;     &lt;li&gt;&#39;location&#39; &#x3D; The accounting location of the order.&lt;/li&gt;     &lt;li&gt;&#39;payments&#39; &#x3D; The payments that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;documents&#39; &#x3D; The documents that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;contactSender&#39; &#x3D; The associated contact for the contact-sender relation.&lt;/li&gt;     &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The associated contact for the contact-receiver relation.&lt;/li&gt;     &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The associated warehouse for the warehouse-sender relation.&lt;/li&gt;     &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The associated warehouse for the warehouse-receiver relation.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation that is associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes that are associated with variation of the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;originOrderReferences&#39; &#x3D; The references to other orders, e.g. returns or credit notes, associated with this order.&lt;/li&gt;     &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;     &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations that are associated with the order item.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersGetRequest($order_type = null, $contact_id = null, $referrer_id = null, $shipping_profile_id = null, $shipping_service_provider_id = null, $owner_user_id = null, $warehouse_id = null, $is_ebay_plus = null, $included_variation = null, $included_item = null, $order_ids = null, $country_id = null, $order_item_name = null, $variation_number = null, $sender_contact = null, $sender_warehouse = null, $receiver_contact = null, $receiver_warehouse = null, $external_order_id = null, $client_id = null, $payment_status = null, $updated_at_from = null, $updated_at_to = null, $created_at_from = null, $created_at_to = null, $paid_at_from = null, $paid_at_to = null, $outgoing_items_booked_at_from = null, $outgoing_items_booked_at_to = null, $status_from = null, $status_to = null, $has_document = null, $has_document_number = null, $parent_order_id = null, $add_order_items = null, $page = null, $items_per_page = null, $with = null)
    {

        $resourcePath = '/rest/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($order_type)) {
            $order_type = ObjectSerializer::serializeCollection($order_type, '', true);
        }
        if ($order_type !== null) {
            $queryParams['orderType'] = $order_type;
        }
        // query params
        if (is_array($contact_id)) {
            $contact_id = ObjectSerializer::serializeCollection($contact_id, '', true);
        }
        if ($contact_id !== null) {
            $queryParams['contactId'] = $contact_id;
        }
        // query params
        if (is_array($referrer_id)) {
            $referrer_id = ObjectSerializer::serializeCollection($referrer_id, '', true);
        }
        if ($referrer_id !== null) {
            $queryParams['referrerId'] = $referrer_id;
        }
        // query params
        if (is_array($shipping_profile_id)) {
            $shipping_profile_id = ObjectSerializer::serializeCollection($shipping_profile_id, '', true);
        }
        if ($shipping_profile_id !== null) {
            $queryParams['shippingProfileId'] = $shipping_profile_id;
        }
        // query params
        if (is_array($shipping_service_provider_id)) {
            $shipping_service_provider_id = ObjectSerializer::serializeCollection($shipping_service_provider_id, '', true);
        }
        if ($shipping_service_provider_id !== null) {
            $queryParams['shippingServiceProviderId'] = $shipping_service_provider_id;
        }
        // query params
        if (is_array($owner_user_id)) {
            $owner_user_id = ObjectSerializer::serializeCollection($owner_user_id, '', true);
        }
        if ($owner_user_id !== null) {
            $queryParams['ownerUserId'] = $owner_user_id;
        }
        // query params
        if (is_array($warehouse_id)) {
            $warehouse_id = ObjectSerializer::serializeCollection($warehouse_id, '', true);
        }
        if ($warehouse_id !== null) {
            $queryParams['warehouseId'] = $warehouse_id;
        }
        // query params
        if (is_array($is_ebay_plus)) {
            $is_ebay_plus = ObjectSerializer::serializeCollection($is_ebay_plus, '', true);
        }
        if ($is_ebay_plus !== null) {
            $queryParams['isEbayPlus'] = $is_ebay_plus;
        }
        // query params
        if (is_array($included_variation)) {
            $included_variation = ObjectSerializer::serializeCollection($included_variation, '', true);
        }
        if ($included_variation !== null) {
            $queryParams['includedVariation'] = $included_variation;
        }
        // query params
        if (is_array($included_item)) {
            $included_item = ObjectSerializer::serializeCollection($included_item, '', true);
        }
        if ($included_item !== null) {
            $queryParams['includedItem'] = $included_item;
        }
        // query params
        if (is_array($order_ids)) {
            $order_ids = ObjectSerializer::serializeCollection($order_ids, '', true);
        }
        if ($order_ids !== null) {
            $queryParams['orderIds'] = $order_ids;
        }
        // query params
        if (is_array($country_id)) {
            $country_id = ObjectSerializer::serializeCollection($country_id, '', true);
        }
        if ($country_id !== null) {
            $queryParams['countryId'] = $country_id;
        }
        // query params
        if (is_array($order_item_name)) {
            $order_item_name = ObjectSerializer::serializeCollection($order_item_name, '', true);
        }
        if ($order_item_name !== null) {
            $queryParams['orderItemName'] = $order_item_name;
        }
        // query params
        if (is_array($variation_number)) {
            $variation_number = ObjectSerializer::serializeCollection($variation_number, '', true);
        }
        if ($variation_number !== null) {
            $queryParams['variationNumber'] = $variation_number;
        }
        // query params
        if (is_array($sender_contact)) {
            $sender_contact = ObjectSerializer::serializeCollection($sender_contact, '', true);
        }
        if ($sender_contact !== null) {
            $queryParams['sender.contact'] = $sender_contact;
        }
        // query params
        if (is_array($sender_warehouse)) {
            $sender_warehouse = ObjectSerializer::serializeCollection($sender_warehouse, '', true);
        }
        if ($sender_warehouse !== null) {
            $queryParams['sender.warehouse'] = $sender_warehouse;
        }
        // query params
        if (is_array($receiver_contact)) {
            $receiver_contact = ObjectSerializer::serializeCollection($receiver_contact, '', true);
        }
        if ($receiver_contact !== null) {
            $queryParams['receiver.contact'] = $receiver_contact;
        }
        // query params
        if (is_array($receiver_warehouse)) {
            $receiver_warehouse = ObjectSerializer::serializeCollection($receiver_warehouse, '', true);
        }
        if ($receiver_warehouse !== null) {
            $queryParams['receiver.warehouse'] = $receiver_warehouse;
        }
        // query params
        if (is_array($external_order_id)) {
            $external_order_id = ObjectSerializer::serializeCollection($external_order_id, '', true);
        }
        if ($external_order_id !== null) {
            $queryParams['externalOrderId'] = $external_order_id;
        }
        // query params
        if (is_array($client_id)) {
            $client_id = ObjectSerializer::serializeCollection($client_id, '', true);
        }
        if ($client_id !== null) {
            $queryParams['clientId'] = $client_id;
        }
        // query params
        if (is_array($payment_status)) {
            $payment_status = ObjectSerializer::serializeCollection($payment_status, '', true);
        }
        if ($payment_status !== null) {
            $queryParams['paymentStatus'] = $payment_status;
        }
        // query params
        if (is_array($updated_at_from)) {
            $updated_at_from = ObjectSerializer::serializeCollection($updated_at_from, '', true);
        }
        if ($updated_at_from !== null) {
            $queryParams['updatedAtFrom'] = $updated_at_from;
        }
        // query params
        if (is_array($updated_at_to)) {
            $updated_at_to = ObjectSerializer::serializeCollection($updated_at_to, '', true);
        }
        if ($updated_at_to !== null) {
            $queryParams['updatedAtTo'] = $updated_at_to;
        }
        // query params
        if (is_array($created_at_from)) {
            $created_at_from = ObjectSerializer::serializeCollection($created_at_from, '', true);
        }
        if ($created_at_from !== null) {
            $queryParams['createdAtFrom'] = $created_at_from;
        }
        // query params
        if (is_array($created_at_to)) {
            $created_at_to = ObjectSerializer::serializeCollection($created_at_to, '', true);
        }
        if ($created_at_to !== null) {
            $queryParams['createdAtTo'] = $created_at_to;
        }
        // query params
        if (is_array($paid_at_from)) {
            $paid_at_from = ObjectSerializer::serializeCollection($paid_at_from, '', true);
        }
        if ($paid_at_from !== null) {
            $queryParams['paidAtFrom'] = $paid_at_from;
        }
        // query params
        if (is_array($paid_at_to)) {
            $paid_at_to = ObjectSerializer::serializeCollection($paid_at_to, '', true);
        }
        if ($paid_at_to !== null) {
            $queryParams['paidAtTo'] = $paid_at_to;
        }
        // query params
        if (is_array($outgoing_items_booked_at_from)) {
            $outgoing_items_booked_at_from = ObjectSerializer::serializeCollection($outgoing_items_booked_at_from, '', true);
        }
        if ($outgoing_items_booked_at_from !== null) {
            $queryParams['outgoingItemsBookedAtFrom'] = $outgoing_items_booked_at_from;
        }
        // query params
        if (is_array($outgoing_items_booked_at_to)) {
            $outgoing_items_booked_at_to = ObjectSerializer::serializeCollection($outgoing_items_booked_at_to, '', true);
        }
        if ($outgoing_items_booked_at_to !== null) {
            $queryParams['outgoingItemsBookedAtTo'] = $outgoing_items_booked_at_to;
        }
        // query params
        if (is_array($status_from)) {
            $status_from = ObjectSerializer::serializeCollection($status_from, '', true);
        }
        if ($status_from !== null) {
            $queryParams['statusFrom'] = $status_from;
        }
        // query params
        if (is_array($status_to)) {
            $status_to = ObjectSerializer::serializeCollection($status_to, '', true);
        }
        if ($status_to !== null) {
            $queryParams['statusTo'] = $status_to;
        }
        // query params
        if (is_array($has_document)) {
            $has_document = ObjectSerializer::serializeCollection($has_document, '', true);
        }
        if ($has_document !== null) {
            $queryParams['hasDocument'] = $has_document;
        }
        // query params
        if (is_array($has_document_number)) {
            $has_document_number = ObjectSerializer::serializeCollection($has_document_number, '', true);
        }
        if ($has_document_number !== null) {
            $queryParams['hasDocumentNumber'] = $has_document_number;
        }
        // query params
        if (is_array($parent_order_id)) {
            $parent_order_id = ObjectSerializer::serializeCollection($parent_order_id, '', true);
        }
        if ($parent_order_id !== null) {
            $queryParams['parentOrderId'] = $parent_order_id;
        }
        // query params
        if (is_array($add_order_items)) {
            $add_order_items = ObjectSerializer::serializeCollection($add_order_items, '', true);
        }
        if ($add_order_items !== null) {
            $queryParams['addOrderItems'] = $add_order_items;
        }
        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsDatesIdDelete
     *
     * Delete a date of an order item
     *
     * @param  int $id The ID of the order item date (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restOrdersItemsDatesIdDelete($id)
    {
        $this->restOrdersItemsDatesIdDeleteWithHttpInfo($id);
    }

    /**
     * Operation restOrdersItemsDatesIdDeleteWithHttpInfo
     *
     * Delete a date of an order item
     *
     * @param  int $id The ID of the order item date (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsDatesIdDeleteWithHttpInfo($id)
    {
        $request = $this->restOrdersItemsDatesIdDeleteRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsDatesIdDeleteAsync
     *
     * Delete a date of an order item
     *
     * @param  int $id The ID of the order item date (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsDatesIdDeleteAsync($id)
    {
        return $this->restOrdersItemsDatesIdDeleteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsDatesIdDeleteAsyncWithHttpInfo
     *
     * Delete a date of an order item
     *
     * @param  int $id The ID of the order item date (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsDatesIdDeleteAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->restOrdersItemsDatesIdDeleteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsDatesIdDelete'
     *
     * @param  int $id The ID of the order item date (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsDatesIdDeleteRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restOrdersItemsDatesIdDelete'
            );
        }

        $resourcePath = '/rest/orders/items/dates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsDatesIdGet
     *
     * Get date of an order item
     *
     * @param  int $id The ID of the order item date (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderItemDate
     */
    public function restOrdersItemsDatesIdGet($id)
    {
        list($response) = $this->restOrdersItemsDatesIdGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restOrdersItemsDatesIdGetWithHttpInfo
     *
     * Get date of an order item
     *
     * @param  int $id The ID of the order item date (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderItemDate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsDatesIdGetWithHttpInfo($id)
    {
        $request = $this->restOrdersItemsDatesIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderItemDate' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderItemDate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderItemDate';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderItemDate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsDatesIdGetAsync
     *
     * Get date of an order item
     *
     * @param  int $id The ID of the order item date (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsDatesIdGetAsync($id)
    {
        return $this->restOrdersItemsDatesIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsDatesIdGetAsyncWithHttpInfo
     *
     * Get date of an order item
     *
     * @param  int $id The ID of the order item date (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsDatesIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\OpenAPI\Client\Model\OrderItemDate';
        $request = $this->restOrdersItemsDatesIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsDatesIdGet'
     *
     * @param  int $id The ID of the order item date (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsDatesIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restOrdersItemsDatesIdGet'
            );
        }

        $resourcePath = '/rest/orders/items/dates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsDatesIdPut
     *
     * Update a date of an order item
     *
     * @param  int $id The ID of the order item date (required)
     * @param  \OpenAPI\Client\Model\InlineObject173 $_rest_orders_items_dates_id _rest_orders_items_dates_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderItemDate
     */
    public function restOrdersItemsDatesIdPut($id, $_rest_orders_items_dates_id = null)
    {
        list($response) = $this->restOrdersItemsDatesIdPutWithHttpInfo($id, $_rest_orders_items_dates_id);
        return $response;
    }

    /**
     * Operation restOrdersItemsDatesIdPutWithHttpInfo
     *
     * Update a date of an order item
     *
     * @param  int $id The ID of the order item date (required)
     * @param  \OpenAPI\Client\Model\InlineObject173 $_rest_orders_items_dates_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderItemDate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsDatesIdPutWithHttpInfo($id, $_rest_orders_items_dates_id = null)
    {
        $request = $this->restOrdersItemsDatesIdPutRequest($id, $_rest_orders_items_dates_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderItemDate' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderItemDate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderItemDate';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderItemDate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsDatesIdPutAsync
     *
     * Update a date of an order item
     *
     * @param  int $id The ID of the order item date (required)
     * @param  \OpenAPI\Client\Model\InlineObject173 $_rest_orders_items_dates_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsDatesIdPutAsync($id, $_rest_orders_items_dates_id = null)
    {
        return $this->restOrdersItemsDatesIdPutAsyncWithHttpInfo($id, $_rest_orders_items_dates_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsDatesIdPutAsyncWithHttpInfo
     *
     * Update a date of an order item
     *
     * @param  int $id The ID of the order item date (required)
     * @param  \OpenAPI\Client\Model\InlineObject173 $_rest_orders_items_dates_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsDatesIdPutAsyncWithHttpInfo($id, $_rest_orders_items_dates_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderItemDate';
        $request = $this->restOrdersItemsDatesIdPutRequest($id, $_rest_orders_items_dates_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsDatesIdPut'
     *
     * @param  int $id The ID of the order item date (required)
     * @param  \OpenAPI\Client\Model\InlineObject173 $_rest_orders_items_dates_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsDatesIdPutRequest($id, $_rest_orders_items_dates_id = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restOrdersItemsDatesIdPut'
            );
        }

        $resourcePath = '/rest/orders/items/dates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_orders_items_dates_id)) {
            $_tempBody = $_rest_orders_items_dates_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsDatesPost
     *
     * Create a date for an order item
     *
     * @param  \OpenAPI\Client\Model\InlineObject172 $_rest_orders_items_dates _rest_orders_items_dates (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderItemDate
     */
    public function restOrdersItemsDatesPost($_rest_orders_items_dates = null)
    {
        list($response) = $this->restOrdersItemsDatesPostWithHttpInfo($_rest_orders_items_dates);
        return $response;
    }

    /**
     * Operation restOrdersItemsDatesPostWithHttpInfo
     *
     * Create a date for an order item
     *
     * @param  \OpenAPI\Client\Model\InlineObject172 $_rest_orders_items_dates (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderItemDate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsDatesPostWithHttpInfo($_rest_orders_items_dates = null)
    {
        $request = $this->restOrdersItemsDatesPostRequest($_rest_orders_items_dates);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderItemDate' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderItemDate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderItemDate';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderItemDate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsDatesPostAsync
     *
     * Create a date for an order item
     *
     * @param  \OpenAPI\Client\Model\InlineObject172 $_rest_orders_items_dates (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsDatesPostAsync($_rest_orders_items_dates = null)
    {
        return $this->restOrdersItemsDatesPostAsyncWithHttpInfo($_rest_orders_items_dates)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsDatesPostAsyncWithHttpInfo
     *
     * Create a date for an order item
     *
     * @param  \OpenAPI\Client\Model\InlineObject172 $_rest_orders_items_dates (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsDatesPostAsyncWithHttpInfo($_rest_orders_items_dates = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderItemDate';
        $request = $this->restOrdersItemsDatesPostRequest($_rest_orders_items_dates);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsDatesPost'
     *
     * @param  \OpenAPI\Client\Model\InlineObject172 $_rest_orders_items_dates (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsDatesPostRequest($_rest_orders_items_dates = null)
    {

        $resourcePath = '/rest/orders/items/dates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_orders_items_dates)) {
            $_tempBody = $_rest_orders_items_dates;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdBookingPost
     *
     * Book an order item in
     *
     * @param  int $order_item_id The ID of the order item. (required)
     * @param  string $delivery_note_number If desired, set the delivery note number provided by the supplier. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersItemsOrderItemIdBookingPost($order_item_id, $delivery_note_number = null)
    {
        list($response) = $this->restOrdersItemsOrderItemIdBookingPostWithHttpInfo($order_item_id, $delivery_note_number);
        return $response;
    }

    /**
     * Operation restOrdersItemsOrderItemIdBookingPostWithHttpInfo
     *
     * Book an order item in
     *
     * @param  int $order_item_id The ID of the order item. (required)
     * @param  string $delivery_note_number If desired, set the delivery note number provided by the supplier. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdBookingPostWithHttpInfo($order_item_id, $delivery_note_number = null)
    {
        $request = $this->restOrdersItemsOrderItemIdBookingPostRequest($order_item_id, $delivery_note_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdBookingPostAsync
     *
     * Book an order item in
     *
     * @param  int $order_item_id The ID of the order item. (required)
     * @param  string $delivery_note_number If desired, set the delivery note number provided by the supplier. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdBookingPostAsync($order_item_id, $delivery_note_number = null)
    {
        return $this->restOrdersItemsOrderItemIdBookingPostAsyncWithHttpInfo($order_item_id, $delivery_note_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdBookingPostAsyncWithHttpInfo
     *
     * Book an order item in
     *
     * @param  int $order_item_id The ID of the order item. (required)
     * @param  string $delivery_note_number If desired, set the delivery note number provided by the supplier. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdBookingPostAsyncWithHttpInfo($order_item_id, $delivery_note_number = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersItemsOrderItemIdBookingPostRequest($order_item_id, $delivery_note_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdBookingPost'
     *
     * @param  int $order_item_id The ID of the order item. (required)
     * @param  string $delivery_note_number If desired, set the delivery note number provided by the supplier. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsOrderItemIdBookingPostRequest($order_item_id, $delivery_note_number = null)
    {
        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdBookingPost'
            );
        }

        $resourcePath = '/rest/orders/items/{orderItemId}/booking';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($delivery_note_number)) {
            $delivery_note_number = ObjectSerializer::serializeCollection($delivery_note_number, '', true);
        }
        if ($delivery_note_number !== null) {
            $queryParams['deliveryNoteNumber'] = $delivery_note_number;
        }


        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesGet
     *
     * List all dates of an order item
     *
     * @param  int $order_item_id The ID of the order item (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderItemDate[]
     */
    public function restOrdersItemsOrderItemIdDatesGet($order_item_id)
    {
        list($response) = $this->restOrdersItemsOrderItemIdDatesGetWithHttpInfo($order_item_id);
        return $response;
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesGetWithHttpInfo
     *
     * List all dates of an order item
     *
     * @param  int $order_item_id The ID of the order item (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderItemDate[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdDatesGetWithHttpInfo($order_item_id)
    {
        $request = $this->restOrdersItemsOrderItemIdDatesGetRequest($order_item_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderItemDate[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderItemDate[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderItemDate[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderItemDate[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesGetAsync
     *
     * List all dates of an order item
     *
     * @param  int $order_item_id The ID of the order item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdDatesGetAsync($order_item_id)
    {
        return $this->restOrdersItemsOrderItemIdDatesGetAsyncWithHttpInfo($order_item_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesGetAsyncWithHttpInfo
     *
     * List all dates of an order item
     *
     * @param  int $order_item_id The ID of the order item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdDatesGetAsyncWithHttpInfo($order_item_id)
    {
        $returnType = '\OpenAPI\Client\Model\OrderItemDate[]';
        $request = $this->restOrdersItemsOrderItemIdDatesGetRequest($order_item_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdDatesGet'
     *
     * @param  int $order_item_id The ID of the order item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsOrderItemIdDatesGetRequest($order_item_id)
    {
        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdDatesGet'
            );
        }

        $resourcePath = '/rest/orders/items/{orderItemId}/dates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdDelete
     *
     * Delete a date of an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdDelete($order_item_id, $type_id)
    {
        $this->restOrdersItemsOrderItemIdDatesTypeIdDeleteWithHttpInfo($order_item_id, $type_id);
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdDeleteWithHttpInfo
     *
     * Delete a date of an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdDeleteWithHttpInfo($order_item_id, $type_id)
    {
        $request = $this->restOrdersItemsOrderItemIdDatesTypeIdDeleteRequest($order_item_id, $type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdDeleteAsync
     *
     * Delete a date of an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdDeleteAsync($order_item_id, $type_id)
    {
        return $this->restOrdersItemsOrderItemIdDatesTypeIdDeleteAsyncWithHttpInfo($order_item_id, $type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdDeleteAsyncWithHttpInfo
     *
     * Delete a date of an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdDeleteAsyncWithHttpInfo($order_item_id, $type_id)
    {
        $returnType = '';
        $request = $this->restOrdersItemsOrderItemIdDatesTypeIdDeleteRequest($order_item_id, $type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdDatesTypeIdDelete'
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsOrderItemIdDatesTypeIdDeleteRequest($order_item_id, $type_id)
    {
        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdDatesTypeIdDelete'
            );
        }
        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersItemsOrderItemIdDatesTypeIdDelete'
            );
        }

        $resourcePath = '/rest/orders/items/{orderItemId}/dates/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }
        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdGet
     *
     * Get a date of an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderItemDate
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdGet($order_item_id, $type_id)
    {
        list($response) = $this->restOrdersItemsOrderItemIdDatesTypeIdGetWithHttpInfo($order_item_id, $type_id);
        return $response;
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdGetWithHttpInfo
     *
     * Get a date of an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderItemDate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdGetWithHttpInfo($order_item_id, $type_id)
    {
        $request = $this->restOrdersItemsOrderItemIdDatesTypeIdGetRequest($order_item_id, $type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderItemDate' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderItemDate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderItemDate';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderItemDate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdGetAsync
     *
     * Get a date of an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdGetAsync($order_item_id, $type_id)
    {
        return $this->restOrdersItemsOrderItemIdDatesTypeIdGetAsyncWithHttpInfo($order_item_id, $type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdGetAsyncWithHttpInfo
     *
     * Get a date of an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdGetAsyncWithHttpInfo($order_item_id, $type_id)
    {
        $returnType = '\OpenAPI\Client\Model\OrderItemDate';
        $request = $this->restOrdersItemsOrderItemIdDatesTypeIdGetRequest($order_item_id, $type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdDatesTypeIdGet'
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsOrderItemIdDatesTypeIdGetRequest($order_item_id, $type_id)
    {
        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdDatesTypeIdGet'
            );
        }
        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersItemsOrderItemIdDatesTypeIdGet'
            );
        }

        $resourcePath = '/rest/orders/items/{orderItemId}/dates/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }
        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdPost
     *
     * Create a date for an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  \OpenAPI\Client\Model\InlineObject179 $_rest_orders_items_order_item_id_dates_type_id _rest_orders_items_order_item_id_dates_type_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderItemDate
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdPost($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id = null)
    {
        list($response) = $this->restOrdersItemsOrderItemIdDatesTypeIdPostWithHttpInfo($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id);
        return $response;
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdPostWithHttpInfo
     *
     * Create a date for an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  \OpenAPI\Client\Model\InlineObject179 $_rest_orders_items_order_item_id_dates_type_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderItemDate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdPostWithHttpInfo($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id = null)
    {
        $request = $this->restOrdersItemsOrderItemIdDatesTypeIdPostRequest($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderItemDate' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderItemDate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderItemDate';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderItemDate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdPostAsync
     *
     * Create a date for an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  \OpenAPI\Client\Model\InlineObject179 $_rest_orders_items_order_item_id_dates_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdPostAsync($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id = null)
    {
        return $this->restOrdersItemsOrderItemIdDatesTypeIdPostAsyncWithHttpInfo($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdPostAsyncWithHttpInfo
     *
     * Create a date for an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  \OpenAPI\Client\Model\InlineObject179 $_rest_orders_items_order_item_id_dates_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdPostAsyncWithHttpInfo($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderItemDate';
        $request = $this->restOrdersItemsOrderItemIdDatesTypeIdPostRequest($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdDatesTypeIdPost'
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  \OpenAPI\Client\Model\InlineObject179 $_rest_orders_items_order_item_id_dates_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsOrderItemIdDatesTypeIdPostRequest($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id = null)
    {
        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdDatesTypeIdPost'
            );
        }
        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersItemsOrderItemIdDatesTypeIdPost'
            );
        }

        $resourcePath = '/rest/orders/items/{orderItemId}/dates/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }
        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_orders_items_order_item_id_dates_type_id)) {
            $_tempBody = $_rest_orders_items_order_item_id_dates_type_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdPut
     *
     * Update a date of an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  \OpenAPI\Client\Model\InlineObject178 $_rest_orders_items_order_item_id_dates_type_id _rest_orders_items_order_item_id_dates_type_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderItemDate
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdPut($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id = null)
    {
        list($response) = $this->restOrdersItemsOrderItemIdDatesTypeIdPutWithHttpInfo($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id);
        return $response;
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdPutWithHttpInfo
     *
     * Update a date of an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  \OpenAPI\Client\Model\InlineObject178 $_rest_orders_items_order_item_id_dates_type_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderItemDate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdPutWithHttpInfo($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id = null)
    {
        $request = $this->restOrdersItemsOrderItemIdDatesTypeIdPutRequest($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderItemDate' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderItemDate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderItemDate';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderItemDate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdPutAsync
     *
     * Update a date of an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  \OpenAPI\Client\Model\InlineObject178 $_rest_orders_items_order_item_id_dates_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdPutAsync($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id = null)
    {
        return $this->restOrdersItemsOrderItemIdDatesTypeIdPutAsyncWithHttpInfo($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdPutAsyncWithHttpInfo
     *
     * Update a date of an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  \OpenAPI\Client\Model\InlineObject178 $_rest_orders_items_order_item_id_dates_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdPutAsyncWithHttpInfo($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderItemDate';
        $request = $this->restOrdersItemsOrderItemIdDatesTypeIdPutRequest($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdDatesTypeIdPut'
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  \OpenAPI\Client\Model\InlineObject178 $_rest_orders_items_order_item_id_dates_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsOrderItemIdDatesTypeIdPutRequest($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id = null)
    {
        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdDatesTypeIdPut'
            );
        }
        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersItemsOrderItemIdDatesTypeIdPut'
            );
        }

        $resourcePath = '/rest/orders/items/{orderItemId}/dates/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }
        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_orders_items_order_item_id_dates_type_id)) {
            $_tempBody = $_rest_orders_items_order_item_id_dates_type_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesGet
     *
     * Get all order item properties
     *
     * @param  int $order_item_id The order item ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderItemProperty[]
     */
    public function restOrdersItemsOrderItemIdPropertiesGet($order_item_id)
    {
        list($response) = $this->restOrdersItemsOrderItemIdPropertiesGetWithHttpInfo($order_item_id);
        return $response;
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesGetWithHttpInfo
     *
     * Get all order item properties
     *
     * @param  int $order_item_id The order item ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderItemProperty[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdPropertiesGetWithHttpInfo($order_item_id)
    {
        $request = $this->restOrdersItemsOrderItemIdPropertiesGetRequest($order_item_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderItemProperty[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderItemProperty[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderItemProperty[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderItemProperty[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesGetAsync
     *
     * Get all order item properties
     *
     * @param  int $order_item_id The order item ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdPropertiesGetAsync($order_item_id)
    {
        return $this->restOrdersItemsOrderItemIdPropertiesGetAsyncWithHttpInfo($order_item_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesGetAsyncWithHttpInfo
     *
     * Get all order item properties
     *
     * @param  int $order_item_id The order item ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdPropertiesGetAsyncWithHttpInfo($order_item_id)
    {
        $returnType = '\OpenAPI\Client\Model\OrderItemProperty[]';
        $request = $this->restOrdersItemsOrderItemIdPropertiesGetRequest($order_item_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdPropertiesGet'
     *
     * @param  int $order_item_id The order item ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsOrderItemIdPropertiesGetRequest($order_item_id)
    {
        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdPropertiesGet'
            );
        }

        $resourcePath = '/rest/orders/items/{orderItemId}/properties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdDelete
     *
     * Delete order item property
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdDelete($order_item_id, $type_id)
    {
        $this->restOrdersItemsOrderItemIdPropertiesTypeIdDeleteWithHttpInfo($order_item_id, $type_id);
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdDeleteWithHttpInfo
     *
     * Delete order item property
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdDeleteWithHttpInfo($order_item_id, $type_id)
    {
        $request = $this->restOrdersItemsOrderItemIdPropertiesTypeIdDeleteRequest($order_item_id, $type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdDeleteAsync
     *
     * Delete order item property
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdDeleteAsync($order_item_id, $type_id)
    {
        return $this->restOrdersItemsOrderItemIdPropertiesTypeIdDeleteAsyncWithHttpInfo($order_item_id, $type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdDeleteAsyncWithHttpInfo
     *
     * Delete order item property
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdDeleteAsyncWithHttpInfo($order_item_id, $type_id)
    {
        $returnType = '';
        $request = $this->restOrdersItemsOrderItemIdPropertiesTypeIdDeleteRequest($order_item_id, $type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdPropertiesTypeIdDelete'
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsOrderItemIdPropertiesTypeIdDeleteRequest($order_item_id, $type_id)
    {
        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdPropertiesTypeIdDelete'
            );
        }
        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersItemsOrderItemIdPropertiesTypeIdDelete'
            );
        }

        $resourcePath = '/rest/orders/items/{orderItemId}/properties/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }
        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdGet
     *
     * Get order item property
     *
     * @param  int $order_item_id The ID of the order item. (required)
     * @param  int $type_id The ID of the order item property type. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderItemProperty
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdGet($order_item_id, $type_id)
    {
        list($response) = $this->restOrdersItemsOrderItemIdPropertiesTypeIdGetWithHttpInfo($order_item_id, $type_id);
        return $response;
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdGetWithHttpInfo
     *
     * Get order item property
     *
     * @param  int $order_item_id The ID of the order item. (required)
     * @param  int $type_id The ID of the order item property type. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderItemProperty, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdGetWithHttpInfo($order_item_id, $type_id)
    {
        $request = $this->restOrdersItemsOrderItemIdPropertiesTypeIdGetRequest($order_item_id, $type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderItemProperty' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderItemProperty', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderItemProperty';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderItemProperty',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdGetAsync
     *
     * Get order item property
     *
     * @param  int $order_item_id The ID of the order item. (required)
     * @param  int $type_id The ID of the order item property type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdGetAsync($order_item_id, $type_id)
    {
        return $this->restOrdersItemsOrderItemIdPropertiesTypeIdGetAsyncWithHttpInfo($order_item_id, $type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdGetAsyncWithHttpInfo
     *
     * Get order item property
     *
     * @param  int $order_item_id The ID of the order item. (required)
     * @param  int $type_id The ID of the order item property type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdGetAsyncWithHttpInfo($order_item_id, $type_id)
    {
        $returnType = '\OpenAPI\Client\Model\OrderItemProperty';
        $request = $this->restOrdersItemsOrderItemIdPropertiesTypeIdGetRequest($order_item_id, $type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdPropertiesTypeIdGet'
     *
     * @param  int $order_item_id The ID of the order item. (required)
     * @param  int $type_id The ID of the order item property type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsOrderItemIdPropertiesTypeIdGetRequest($order_item_id, $type_id)
    {
        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdPropertiesTypeIdGet'
            );
        }
        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersItemsOrderItemIdPropertiesTypeIdGet'
            );
        }

        $resourcePath = '/rest/orders/items/{orderItemId}/properties/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }
        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdPost
     *
     * Create order item property
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject181 $_rest_orders_items_order_item_id_properties_type_id _rest_orders_items_order_item_id_properties_type_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderItemProperty
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdPost($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id = null)
    {
        list($response) = $this->restOrdersItemsOrderItemIdPropertiesTypeIdPostWithHttpInfo($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id);
        return $response;
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdPostWithHttpInfo
     *
     * Create order item property
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject181 $_rest_orders_items_order_item_id_properties_type_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderItemProperty, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdPostWithHttpInfo($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id = null)
    {
        $request = $this->restOrdersItemsOrderItemIdPropertiesTypeIdPostRequest($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderItemProperty' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderItemProperty', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderItemProperty';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderItemProperty',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdPostAsync
     *
     * Create order item property
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject181 $_rest_orders_items_order_item_id_properties_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdPostAsync($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id = null)
    {
        return $this->restOrdersItemsOrderItemIdPropertiesTypeIdPostAsyncWithHttpInfo($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdPostAsyncWithHttpInfo
     *
     * Create order item property
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject181 $_rest_orders_items_order_item_id_properties_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdPostAsyncWithHttpInfo($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderItemProperty';
        $request = $this->restOrdersItemsOrderItemIdPropertiesTypeIdPostRequest($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdPropertiesTypeIdPost'
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject181 $_rest_orders_items_order_item_id_properties_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsOrderItemIdPropertiesTypeIdPostRequest($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id = null)
    {
        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdPropertiesTypeIdPost'
            );
        }
        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersItemsOrderItemIdPropertiesTypeIdPost'
            );
        }

        $resourcePath = '/rest/orders/items/{orderItemId}/properties/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }
        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_orders_items_order_item_id_properties_type_id)) {
            $_tempBody = $_rest_orders_items_order_item_id_properties_type_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdPut
     *
     * Update order item property
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject180 $_rest_orders_items_order_item_id_properties_type_id _rest_orders_items_order_item_id_properties_type_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderItemProperty
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdPut($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id = null)
    {
        list($response) = $this->restOrdersItemsOrderItemIdPropertiesTypeIdPutWithHttpInfo($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id);
        return $response;
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdPutWithHttpInfo
     *
     * Update order item property
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject180 $_rest_orders_items_order_item_id_properties_type_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderItemProperty, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdPutWithHttpInfo($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id = null)
    {
        $request = $this->restOrdersItemsOrderItemIdPropertiesTypeIdPutRequest($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderItemProperty' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderItemProperty', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderItemProperty';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderItemProperty',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdPutAsync
     *
     * Update order item property
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject180 $_rest_orders_items_order_item_id_properties_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdPutAsync($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id = null)
    {
        return $this->restOrdersItemsOrderItemIdPropertiesTypeIdPutAsyncWithHttpInfo($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdPutAsyncWithHttpInfo
     *
     * Update order item property
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject180 $_rest_orders_items_order_item_id_properties_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdPutAsyncWithHttpInfo($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderItemProperty';
        $request = $this->restOrdersItemsOrderItemIdPropertiesTypeIdPutRequest($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdPropertiesTypeIdPut'
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject180 $_rest_orders_items_order_item_id_properties_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsOrderItemIdPropertiesTypeIdPutRequest($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id = null)
    {
        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdPropertiesTypeIdPut'
            );
        }
        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersItemsOrderItemIdPropertiesTypeIdPut'
            );
        }

        $resourcePath = '/rest/orders/items/{orderItemId}/properties/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }
        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_orders_items_order_item_id_properties_type_id)) {
            $_tempBody = $_rest_orders_items_order_item_id_properties_type_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdTransactionsGet
     *
     * List order item transactions
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $columns The properties to be loaded (optional)
     * @param  int $with Load additional relations for a transaction. Currently possible are &#39;orderItem&#39; and &#39;warehouseLocation&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderItemTransaction[]
     */
    public function restOrdersItemsOrderItemIdTransactionsGet($order_item_id, $columns = null, $with = null)
    {
        list($response) = $this->restOrdersItemsOrderItemIdTransactionsGetWithHttpInfo($order_item_id, $columns, $with);
        return $response;
    }

    /**
     * Operation restOrdersItemsOrderItemIdTransactionsGetWithHttpInfo
     *
     * List order item transactions
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $columns The properties to be loaded (optional)
     * @param  int $with Load additional relations for a transaction. Currently possible are &#39;orderItem&#39; and &#39;warehouseLocation&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderItemTransaction[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdTransactionsGetWithHttpInfo($order_item_id, $columns = null, $with = null)
    {
        $request = $this->restOrdersItemsOrderItemIdTransactionsGetRequest($order_item_id, $columns, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderItemTransaction[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderItemTransaction[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderItemTransaction[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderItemTransaction[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdTransactionsGetAsync
     *
     * List order item transactions
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $columns The properties to be loaded (optional)
     * @param  int $with Load additional relations for a transaction. Currently possible are &#39;orderItem&#39; and &#39;warehouseLocation&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdTransactionsGetAsync($order_item_id, $columns = null, $with = null)
    {
        return $this->restOrdersItemsOrderItemIdTransactionsGetAsyncWithHttpInfo($order_item_id, $columns, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdTransactionsGetAsyncWithHttpInfo
     *
     * List order item transactions
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $columns The properties to be loaded (optional)
     * @param  int $with Load additional relations for a transaction. Currently possible are &#39;orderItem&#39; and &#39;warehouseLocation&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdTransactionsGetAsyncWithHttpInfo($order_item_id, $columns = null, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderItemTransaction[]';
        $request = $this->restOrdersItemsOrderItemIdTransactionsGetRequest($order_item_id, $columns, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdTransactionsGet'
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $columns The properties to be loaded (optional)
     * @param  int $with Load additional relations for a transaction. Currently possible are &#39;orderItem&#39; and &#39;warehouseLocation&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsOrderItemIdTransactionsGetRequest($order_item_id, $columns = null, $with = null)
    {
        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdTransactionsGet'
            );
        }

        $resourcePath = '/rest/orders/items/{orderItemId}/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($columns)) {
            $columns = ObjectSerializer::serializeCollection($columns, '', true);
        }
        if ($columns !== null) {
            $queryParams['columns'] = $columns;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }


        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdTransactionsPost
     *
     * Create order item transaction
     *
     * @param  int $order_item_id order_item_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject182 $_rest_orders_items_order_item_id_transactions _rest_orders_items_order_item_id_transactions (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderItemTransaction
     */
    public function restOrdersItemsOrderItemIdTransactionsPost($order_item_id, $_rest_orders_items_order_item_id_transactions = null)
    {
        list($response) = $this->restOrdersItemsOrderItemIdTransactionsPostWithHttpInfo($order_item_id, $_rest_orders_items_order_item_id_transactions);
        return $response;
    }

    /**
     * Operation restOrdersItemsOrderItemIdTransactionsPostWithHttpInfo
     *
     * Create order item transaction
     *
     * @param  int $order_item_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject182 $_rest_orders_items_order_item_id_transactions (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderItemTransaction, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdTransactionsPostWithHttpInfo($order_item_id, $_rest_orders_items_order_item_id_transactions = null)
    {
        $request = $this->restOrdersItemsOrderItemIdTransactionsPostRequest($order_item_id, $_rest_orders_items_order_item_id_transactions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderItemTransaction' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderItemTransaction', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderItemTransaction';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderItemTransaction',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdTransactionsPostAsync
     *
     * Create order item transaction
     *
     * @param  int $order_item_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject182 $_rest_orders_items_order_item_id_transactions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdTransactionsPostAsync($order_item_id, $_rest_orders_items_order_item_id_transactions = null)
    {
        return $this->restOrdersItemsOrderItemIdTransactionsPostAsyncWithHttpInfo($order_item_id, $_rest_orders_items_order_item_id_transactions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdTransactionsPostAsyncWithHttpInfo
     *
     * Create order item transaction
     *
     * @param  int $order_item_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject182 $_rest_orders_items_order_item_id_transactions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOrderItemIdTransactionsPostAsyncWithHttpInfo($order_item_id, $_rest_orders_items_order_item_id_transactions = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderItemTransaction';
        $request = $this->restOrdersItemsOrderItemIdTransactionsPostRequest($order_item_id, $_rest_orders_items_order_item_id_transactions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdTransactionsPost'
     *
     * @param  int $order_item_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject182 $_rest_orders_items_order_item_id_transactions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsOrderItemIdTransactionsPostRequest($order_item_id, $_rest_orders_items_order_item_id_transactions = null)
    {
        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdTransactionsPost'
            );
        }

        $resourcePath = '/rest/orders/items/{orderItemId}/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_orders_items_order_item_id_transactions)) {
            $_tempBody = $_rest_orders_items_order_item_id_transactions;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOutgoingStocksDelete
     *
     * Revert outgoing stock for order items
     *
     * @param  \OpenAPI\Client\Model\InlineObject174 $_rest_orders_items_outgoing_stocks _rest_orders_items_outgoing_stocks (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restOrdersItemsOutgoingStocksDelete($_rest_orders_items_outgoing_stocks = null)
    {
        $this->restOrdersItemsOutgoingStocksDeleteWithHttpInfo($_rest_orders_items_outgoing_stocks);
    }

    /**
     * Operation restOrdersItemsOutgoingStocksDeleteWithHttpInfo
     *
     * Revert outgoing stock for order items
     *
     * @param  \OpenAPI\Client\Model\InlineObject174 $_rest_orders_items_outgoing_stocks (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOutgoingStocksDeleteWithHttpInfo($_rest_orders_items_outgoing_stocks = null)
    {
        $request = $this->restOrdersItemsOutgoingStocksDeleteRequest($_rest_orders_items_outgoing_stocks);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOutgoingStocksDeleteAsync
     *
     * Revert outgoing stock for order items
     *
     * @param  \OpenAPI\Client\Model\InlineObject174 $_rest_orders_items_outgoing_stocks (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOutgoingStocksDeleteAsync($_rest_orders_items_outgoing_stocks = null)
    {
        return $this->restOrdersItemsOutgoingStocksDeleteAsyncWithHttpInfo($_rest_orders_items_outgoing_stocks)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOutgoingStocksDeleteAsyncWithHttpInfo
     *
     * Revert outgoing stock for order items
     *
     * @param  \OpenAPI\Client\Model\InlineObject174 $_rest_orders_items_outgoing_stocks (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsOutgoingStocksDeleteAsyncWithHttpInfo($_rest_orders_items_outgoing_stocks = null)
    {
        $returnType = '';
        $request = $this->restOrdersItemsOutgoingStocksDeleteRequest($_rest_orders_items_outgoing_stocks);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOutgoingStocksDelete'
     *
     * @param  \OpenAPI\Client\Model\InlineObject174 $_rest_orders_items_outgoing_stocks (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsOutgoingStocksDeleteRequest($_rest_orders_items_outgoing_stocks = null)
    {

        $resourcePath = '/rest/orders/items/outgoing_stocks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_orders_items_outgoing_stocks)) {
            $_tempBody = $_rest_orders_items_outgoing_stocks;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsPropertiesIdDelete
     *
     * Delete order item property
     *
     * @param  int $id The ID of the order item property. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restOrdersItemsPropertiesIdDelete($id)
    {
        $this->restOrdersItemsPropertiesIdDeleteWithHttpInfo($id);
    }

    /**
     * Operation restOrdersItemsPropertiesIdDeleteWithHttpInfo
     *
     * Delete order item property
     *
     * @param  int $id The ID of the order item property. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsPropertiesIdDeleteWithHttpInfo($id)
    {
        $request = $this->restOrdersItemsPropertiesIdDeleteRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsPropertiesIdDeleteAsync
     *
     * Delete order item property
     *
     * @param  int $id The ID of the order item property. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsPropertiesIdDeleteAsync($id)
    {
        return $this->restOrdersItemsPropertiesIdDeleteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsPropertiesIdDeleteAsyncWithHttpInfo
     *
     * Delete order item property
     *
     * @param  int $id The ID of the order item property. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsPropertiesIdDeleteAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->restOrdersItemsPropertiesIdDeleteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsPropertiesIdDelete'
     *
     * @param  int $id The ID of the order item property. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsPropertiesIdDeleteRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restOrdersItemsPropertiesIdDelete'
            );
        }

        $resourcePath = '/rest/orders/items/properties/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsPropertiesIdGet
     *
     * Get order item property
     *
     * @param  int $id The ID of the order item property. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderItemProperty
     */
    public function restOrdersItemsPropertiesIdGet($id)
    {
        list($response) = $this->restOrdersItemsPropertiesIdGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restOrdersItemsPropertiesIdGetWithHttpInfo
     *
     * Get order item property
     *
     * @param  int $id The ID of the order item property. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderItemProperty, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsPropertiesIdGetWithHttpInfo($id)
    {
        $request = $this->restOrdersItemsPropertiesIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderItemProperty' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderItemProperty', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderItemProperty';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderItemProperty',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsPropertiesIdGetAsync
     *
     * Get order item property
     *
     * @param  int $id The ID of the order item property. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsPropertiesIdGetAsync($id)
    {
        return $this->restOrdersItemsPropertiesIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsPropertiesIdGetAsyncWithHttpInfo
     *
     * Get order item property
     *
     * @param  int $id The ID of the order item property. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsPropertiesIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\OpenAPI\Client\Model\OrderItemProperty';
        $request = $this->restOrdersItemsPropertiesIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsPropertiesIdGet'
     *
     * @param  int $id The ID of the order item property. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsPropertiesIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restOrdersItemsPropertiesIdGet'
            );
        }

        $resourcePath = '/rest/orders/items/properties/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsPropertiesIdPut
     *
     * Update order item property
     *
     * @param  int $id The ID of the order item property instance to be updated. (required)
     * @param  \OpenAPI\Client\Model\InlineObject176 $_rest_orders_items_properties_id _rest_orders_items_properties_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderItemProperty
     */
    public function restOrdersItemsPropertiesIdPut($id, $_rest_orders_items_properties_id = null)
    {
        list($response) = $this->restOrdersItemsPropertiesIdPutWithHttpInfo($id, $_rest_orders_items_properties_id);
        return $response;
    }

    /**
     * Operation restOrdersItemsPropertiesIdPutWithHttpInfo
     *
     * Update order item property
     *
     * @param  int $id The ID of the order item property instance to be updated. (required)
     * @param  \OpenAPI\Client\Model\InlineObject176 $_rest_orders_items_properties_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderItemProperty, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsPropertiesIdPutWithHttpInfo($id, $_rest_orders_items_properties_id = null)
    {
        $request = $this->restOrdersItemsPropertiesIdPutRequest($id, $_rest_orders_items_properties_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderItemProperty' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderItemProperty', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderItemProperty';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderItemProperty',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsPropertiesIdPutAsync
     *
     * Update order item property
     *
     * @param  int $id The ID of the order item property instance to be updated. (required)
     * @param  \OpenAPI\Client\Model\InlineObject176 $_rest_orders_items_properties_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsPropertiesIdPutAsync($id, $_rest_orders_items_properties_id = null)
    {
        return $this->restOrdersItemsPropertiesIdPutAsyncWithHttpInfo($id, $_rest_orders_items_properties_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsPropertiesIdPutAsyncWithHttpInfo
     *
     * Update order item property
     *
     * @param  int $id The ID of the order item property instance to be updated. (required)
     * @param  \OpenAPI\Client\Model\InlineObject176 $_rest_orders_items_properties_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsPropertiesIdPutAsyncWithHttpInfo($id, $_rest_orders_items_properties_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderItemProperty';
        $request = $this->restOrdersItemsPropertiesIdPutRequest($id, $_rest_orders_items_properties_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsPropertiesIdPut'
     *
     * @param  int $id The ID of the order item property instance to be updated. (required)
     * @param  \OpenAPI\Client\Model\InlineObject176 $_rest_orders_items_properties_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsPropertiesIdPutRequest($id, $_rest_orders_items_properties_id = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restOrdersItemsPropertiesIdPut'
            );
        }

        $resourcePath = '/rest/orders/items/properties/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_orders_items_properties_id)) {
            $_tempBody = $_rest_orders_items_properties_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsPropertiesPost
     *
     * Create order item property
     *
     * @param  \OpenAPI\Client\Model\InlineObject175 $_rest_orders_items_properties _rest_orders_items_properties (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderItemProperty
     */
    public function restOrdersItemsPropertiesPost($_rest_orders_items_properties = null)
    {
        list($response) = $this->restOrdersItemsPropertiesPostWithHttpInfo($_rest_orders_items_properties);
        return $response;
    }

    /**
     * Operation restOrdersItemsPropertiesPostWithHttpInfo
     *
     * Create order item property
     *
     * @param  \OpenAPI\Client\Model\InlineObject175 $_rest_orders_items_properties (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderItemProperty, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsPropertiesPostWithHttpInfo($_rest_orders_items_properties = null)
    {
        $request = $this->restOrdersItemsPropertiesPostRequest($_rest_orders_items_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderItemProperty' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderItemProperty', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderItemProperty';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderItemProperty',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsPropertiesPostAsync
     *
     * Create order item property
     *
     * @param  \OpenAPI\Client\Model\InlineObject175 $_rest_orders_items_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsPropertiesPostAsync($_rest_orders_items_properties = null)
    {
        return $this->restOrdersItemsPropertiesPostAsyncWithHttpInfo($_rest_orders_items_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsPropertiesPostAsyncWithHttpInfo
     *
     * Create order item property
     *
     * @param  \OpenAPI\Client\Model\InlineObject175 $_rest_orders_items_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsPropertiesPostAsyncWithHttpInfo($_rest_orders_items_properties = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderItemProperty';
        $request = $this->restOrdersItemsPropertiesPostRequest($_rest_orders_items_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsPropertiesPost'
     *
     * @param  \OpenAPI\Client\Model\InlineObject175 $_rest_orders_items_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsPropertiesPostRequest($_rest_orders_items_properties = null)
    {

        $resourcePath = '/rest/orders/items/properties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_orders_items_properties)) {
            $_tempBody = $_rest_orders_items_properties;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsTransactionsBookingPost
     *
     * Book order item transactions
     *
     * @param  int $transaction_ids The IDs of the order item transactions. (required)
     * @param  string $delivery_note_number If desired, set a delivery note number. The delivery note number has to match the type of order item transaction. For incoming items, set an external delivery note number. For outgoing items, set an external or an internal delivery note number. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersItemsTransactionsBookingPost($transaction_ids, $delivery_note_number = null)
    {
        list($response) = $this->restOrdersItemsTransactionsBookingPostWithHttpInfo($transaction_ids, $delivery_note_number);
        return $response;
    }

    /**
     * Operation restOrdersItemsTransactionsBookingPostWithHttpInfo
     *
     * Book order item transactions
     *
     * @param  int $transaction_ids The IDs of the order item transactions. (required)
     * @param  string $delivery_note_number If desired, set a delivery note number. The delivery note number has to match the type of order item transaction. For incoming items, set an external delivery note number. For outgoing items, set an external or an internal delivery note number. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsTransactionsBookingPostWithHttpInfo($transaction_ids, $delivery_note_number = null)
    {
        $request = $this->restOrdersItemsTransactionsBookingPostRequest($transaction_ids, $delivery_note_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsTransactionsBookingPostAsync
     *
     * Book order item transactions
     *
     * @param  int $transaction_ids The IDs of the order item transactions. (required)
     * @param  string $delivery_note_number If desired, set a delivery note number. The delivery note number has to match the type of order item transaction. For incoming items, set an external delivery note number. For outgoing items, set an external or an internal delivery note number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsTransactionsBookingPostAsync($transaction_ids, $delivery_note_number = null)
    {
        return $this->restOrdersItemsTransactionsBookingPostAsyncWithHttpInfo($transaction_ids, $delivery_note_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsTransactionsBookingPostAsyncWithHttpInfo
     *
     * Book order item transactions
     *
     * @param  int $transaction_ids The IDs of the order item transactions. (required)
     * @param  string $delivery_note_number If desired, set a delivery note number. The delivery note number has to match the type of order item transaction. For incoming items, set an external delivery note number. For outgoing items, set an external or an internal delivery note number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsTransactionsBookingPostAsyncWithHttpInfo($transaction_ids, $delivery_note_number = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersItemsTransactionsBookingPostRequest($transaction_ids, $delivery_note_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsTransactionsBookingPost'
     *
     * @param  int $transaction_ids The IDs of the order item transactions. (required)
     * @param  string $delivery_note_number If desired, set a delivery note number. The delivery note number has to match the type of order item transaction. For incoming items, set an external delivery note number. For outgoing items, set an external or an internal delivery note number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsTransactionsBookingPostRequest($transaction_ids, $delivery_note_number = null)
    {
        // verify the required parameter 'transaction_ids' is set
        if ($transaction_ids === null || (is_array($transaction_ids) && count($transaction_ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $transaction_ids when calling restOrdersItemsTransactionsBookingPost'
            );
        }

        $resourcePath = '/rest/orders/items/transactions/booking';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($transaction_ids)) {
            $transaction_ids = ObjectSerializer::serializeCollection($transaction_ids, '', true);
        }
        if ($transaction_ids !== null) {
            $queryParams['transactionIds'] = $transaction_ids;
        }
        // query params
        if (is_array($delivery_note_number)) {
            $delivery_note_number = ObjectSerializer::serializeCollection($delivery_note_number, '', true);
        }
        if ($delivery_note_number !== null) {
            $queryParams['deliveryNoteNumber'] = $delivery_note_number;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsTransactionsGet
     *
     * Search order item transactions
     *
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int $columns Specifies the properties of the order item transactions to be loaded. (optional)
     * @param  int $with Loads additional relations of the order item transactions. The available relations are &#39;orderItem&#39; and &#39;warehouseLocation&#39;. (optional)
     * @param  string $sort_by Sort search result according to createdAt, updatedAt, orderItemId, receiptId or quantity. The default value is orderItemId. (optional)
     * @param  string $sort_order Sort direction desc or asc. The default value is asc. (optional)
     * @param  int $order_item_id The ID of the order item (optional)
     * @param  int $order_id The ID of the order (optional)
     * @param  string $direction The direction of the order item transactions (optional)
     * @param  string $status The status of the order item transactions (&#39;in&#39; for incoming or &#39;out&#39; for outgoing) (optional)
     * @param  bool $is_booked Returns all booked order item transactions. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20038
     */
    public function restOrdersItemsTransactionsGet($page = null, $items_per_page = null, $columns = null, $with = null, $sort_by = null, $sort_order = null, $order_item_id = null, $order_id = null, $direction = null, $status = null, $is_booked = null)
    {
        list($response) = $this->restOrdersItemsTransactionsGetWithHttpInfo($page, $items_per_page, $columns, $with, $sort_by, $sort_order, $order_item_id, $order_id, $direction, $status, $is_booked);
        return $response;
    }

    /**
     * Operation restOrdersItemsTransactionsGetWithHttpInfo
     *
     * Search order item transactions
     *
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int $columns Specifies the properties of the order item transactions to be loaded. (optional)
     * @param  int $with Loads additional relations of the order item transactions. The available relations are &#39;orderItem&#39; and &#39;warehouseLocation&#39;. (optional)
     * @param  string $sort_by Sort search result according to createdAt, updatedAt, orderItemId, receiptId or quantity. The default value is orderItemId. (optional)
     * @param  string $sort_order Sort direction desc or asc. The default value is asc. (optional)
     * @param  int $order_item_id The ID of the order item (optional)
     * @param  int $order_id The ID of the order (optional)
     * @param  string $direction The direction of the order item transactions (optional)
     * @param  string $status The status of the order item transactions (&#39;in&#39; for incoming or &#39;out&#39; for outgoing) (optional)
     * @param  bool $is_booked Returns all booked order item transactions. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20038, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsTransactionsGetWithHttpInfo($page = null, $items_per_page = null, $columns = null, $with = null, $sort_by = null, $sort_order = null, $order_item_id = null, $order_id = null, $direction = null, $status = null, $is_booked = null)
    {
        $request = $this->restOrdersItemsTransactionsGetRequest($page, $items_per_page, $columns, $with, $sort_by, $sort_order, $order_item_id, $order_id, $direction, $status, $is_booked);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20038' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20038', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20038';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20038',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsTransactionsGetAsync
     *
     * Search order item transactions
     *
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int $columns Specifies the properties of the order item transactions to be loaded. (optional)
     * @param  int $with Loads additional relations of the order item transactions. The available relations are &#39;orderItem&#39; and &#39;warehouseLocation&#39;. (optional)
     * @param  string $sort_by Sort search result according to createdAt, updatedAt, orderItemId, receiptId or quantity. The default value is orderItemId. (optional)
     * @param  string $sort_order Sort direction desc or asc. The default value is asc. (optional)
     * @param  int $order_item_id The ID of the order item (optional)
     * @param  int $order_id The ID of the order (optional)
     * @param  string $direction The direction of the order item transactions (optional)
     * @param  string $status The status of the order item transactions (&#39;in&#39; for incoming or &#39;out&#39; for outgoing) (optional)
     * @param  bool $is_booked Returns all booked order item transactions. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsTransactionsGetAsync($page = null, $items_per_page = null, $columns = null, $with = null, $sort_by = null, $sort_order = null, $order_item_id = null, $order_id = null, $direction = null, $status = null, $is_booked = null)
    {
        return $this->restOrdersItemsTransactionsGetAsyncWithHttpInfo($page, $items_per_page, $columns, $with, $sort_by, $sort_order, $order_item_id, $order_id, $direction, $status, $is_booked)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsTransactionsGetAsyncWithHttpInfo
     *
     * Search order item transactions
     *
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int $columns Specifies the properties of the order item transactions to be loaded. (optional)
     * @param  int $with Loads additional relations of the order item transactions. The available relations are &#39;orderItem&#39; and &#39;warehouseLocation&#39;. (optional)
     * @param  string $sort_by Sort search result according to createdAt, updatedAt, orderItemId, receiptId or quantity. The default value is orderItemId. (optional)
     * @param  string $sort_order Sort direction desc or asc. The default value is asc. (optional)
     * @param  int $order_item_id The ID of the order item (optional)
     * @param  int $order_id The ID of the order (optional)
     * @param  string $direction The direction of the order item transactions (optional)
     * @param  string $status The status of the order item transactions (&#39;in&#39; for incoming or &#39;out&#39; for outgoing) (optional)
     * @param  bool $is_booked Returns all booked order item transactions. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsTransactionsGetAsyncWithHttpInfo($page = null, $items_per_page = null, $columns = null, $with = null, $sort_by = null, $sort_order = null, $order_item_id = null, $order_id = null, $direction = null, $status = null, $is_booked = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20038';
        $request = $this->restOrdersItemsTransactionsGetRequest($page, $items_per_page, $columns, $with, $sort_by, $sort_order, $order_item_id, $order_id, $direction, $status, $is_booked);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsTransactionsGet'
     *
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int $columns Specifies the properties of the order item transactions to be loaded. (optional)
     * @param  int $with Loads additional relations of the order item transactions. The available relations are &#39;orderItem&#39; and &#39;warehouseLocation&#39;. (optional)
     * @param  string $sort_by Sort search result according to createdAt, updatedAt, orderItemId, receiptId or quantity. The default value is orderItemId. (optional)
     * @param  string $sort_order Sort direction desc or asc. The default value is asc. (optional)
     * @param  int $order_item_id The ID of the order item (optional)
     * @param  int $order_id The ID of the order (optional)
     * @param  string $direction The direction of the order item transactions (optional)
     * @param  string $status The status of the order item transactions (&#39;in&#39; for incoming or &#39;out&#39; for outgoing) (optional)
     * @param  bool $is_booked Returns all booked order item transactions. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsTransactionsGetRequest($page = null, $items_per_page = null, $columns = null, $with = null, $sort_by = null, $sort_order = null, $order_item_id = null, $order_id = null, $direction = null, $status = null, $is_booked = null)
    {

        $resourcePath = '/rest/orders/items/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }
        // query params
        if (is_array($columns)) {
            $columns = ObjectSerializer::serializeCollection($columns, '', true);
        }
        if ($columns !== null) {
            $queryParams['columns'] = $columns;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }
        // query params
        if (is_array($sort_by)) {
            $sort_by = ObjectSerializer::serializeCollection($sort_by, '', true);
        }
        if ($sort_by !== null) {
            $queryParams['sortBy'] = $sort_by;
        }
        // query params
        if (is_array($sort_order)) {
            $sort_order = ObjectSerializer::serializeCollection($sort_order, '', true);
        }
        if ($sort_order !== null) {
            $queryParams['sortOrder'] = $sort_order;
        }
        // query params
        if (is_array($order_item_id)) {
            $order_item_id = ObjectSerializer::serializeCollection($order_item_id, '', true);
        }
        if ($order_item_id !== null) {
            $queryParams['orderItemId'] = $order_item_id;
        }
        // query params
        if (is_array($order_id)) {
            $order_id = ObjectSerializer::serializeCollection($order_id, '', true);
        }
        if ($order_id !== null) {
            $queryParams['orderId'] = $order_id;
        }
        // query params
        if (is_array($direction)) {
            $direction = ObjectSerializer::serializeCollection($direction, '', true);
        }
        if ($direction !== null) {
            $queryParams['direction'] = $direction;
        }
        // query params
        if (is_array($status)) {
            $status = ObjectSerializer::serializeCollection($status, '', true);
        }
        if ($status !== null) {
            $queryParams['status'] = $status;
        }
        // query params
        if (is_array($is_booked)) {
            $is_booked = ObjectSerializer::serializeCollection($is_booked, '', true);
        }
        if ($is_booked !== null) {
            $queryParams['isBooked'] = $is_booked;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsTransactionsTransactionIdDelete
     *
     * Delete order item transaction
     *
     * @param  int $transaction_id transaction_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersItemsTransactionsTransactionIdDelete($transaction_id)
    {
        list($response) = $this->restOrdersItemsTransactionsTransactionIdDeleteWithHttpInfo($transaction_id);
        return $response;
    }

    /**
     * Operation restOrdersItemsTransactionsTransactionIdDeleteWithHttpInfo
     *
     * Delete order item transaction
     *
     * @param  int $transaction_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsTransactionsTransactionIdDeleteWithHttpInfo($transaction_id)
    {
        $request = $this->restOrdersItemsTransactionsTransactionIdDeleteRequest($transaction_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsTransactionsTransactionIdDeleteAsync
     *
     * Delete order item transaction
     *
     * @param  int $transaction_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsTransactionsTransactionIdDeleteAsync($transaction_id)
    {
        return $this->restOrdersItemsTransactionsTransactionIdDeleteAsyncWithHttpInfo($transaction_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsTransactionsTransactionIdDeleteAsyncWithHttpInfo
     *
     * Delete order item transaction
     *
     * @param  int $transaction_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsTransactionsTransactionIdDeleteAsyncWithHttpInfo($transaction_id)
    {
        $returnType = 'object';
        $request = $this->restOrdersItemsTransactionsTransactionIdDeleteRequest($transaction_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsTransactionsTransactionIdDelete'
     *
     * @param  int $transaction_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsTransactionsTransactionIdDeleteRequest($transaction_id)
    {
        // verify the required parameter 'transaction_id' is set
        if ($transaction_id === null || (is_array($transaction_id) && count($transaction_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $transaction_id when calling restOrdersItemsTransactionsTransactionIdDelete'
            );
        }

        $resourcePath = '/rest/orders/items/transactions/{transactionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($transaction_id !== null) {
            $resourcePath = str_replace(
                '{' . 'transactionId' . '}',
                ObjectSerializer::toPathValue($transaction_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsTransactionsTransactionIdPut
     *
     * Update order item transaction
     *
     * @param  int $transaction_id transaction_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject177 $_rest_orders_items_transactions_transaction_id _rest_orders_items_transactions_transaction_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderItemTransaction
     */
    public function restOrdersItemsTransactionsTransactionIdPut($transaction_id, $_rest_orders_items_transactions_transaction_id = null)
    {
        list($response) = $this->restOrdersItemsTransactionsTransactionIdPutWithHttpInfo($transaction_id, $_rest_orders_items_transactions_transaction_id);
        return $response;
    }

    /**
     * Operation restOrdersItemsTransactionsTransactionIdPutWithHttpInfo
     *
     * Update order item transaction
     *
     * @param  int $transaction_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject177 $_rest_orders_items_transactions_transaction_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderItemTransaction, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsTransactionsTransactionIdPutWithHttpInfo($transaction_id, $_rest_orders_items_transactions_transaction_id = null)
    {
        $request = $this->restOrdersItemsTransactionsTransactionIdPutRequest($transaction_id, $_rest_orders_items_transactions_transaction_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderItemTransaction' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderItemTransaction', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderItemTransaction';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderItemTransaction',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsTransactionsTransactionIdPutAsync
     *
     * Update order item transaction
     *
     * @param  int $transaction_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject177 $_rest_orders_items_transactions_transaction_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsTransactionsTransactionIdPutAsync($transaction_id, $_rest_orders_items_transactions_transaction_id = null)
    {
        return $this->restOrdersItemsTransactionsTransactionIdPutAsyncWithHttpInfo($transaction_id, $_rest_orders_items_transactions_transaction_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsTransactionsTransactionIdPutAsyncWithHttpInfo
     *
     * Update order item transaction
     *
     * @param  int $transaction_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject177 $_rest_orders_items_transactions_transaction_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersItemsTransactionsTransactionIdPutAsyncWithHttpInfo($transaction_id, $_rest_orders_items_transactions_transaction_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderItemTransaction';
        $request = $this->restOrdersItemsTransactionsTransactionIdPutRequest($transaction_id, $_rest_orders_items_transactions_transaction_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsTransactionsTransactionIdPut'
     *
     * @param  int $transaction_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject177 $_rest_orders_items_transactions_transaction_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersItemsTransactionsTransactionIdPutRequest($transaction_id, $_rest_orders_items_transactions_transaction_id = null)
    {
        // verify the required parameter 'transaction_id' is set
        if ($transaction_id === null || (is_array($transaction_id) && count($transaction_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $transaction_id when calling restOrdersItemsTransactionsTransactionIdPut'
            );
        }

        $resourcePath = '/rest/orders/items/transactions/{transactionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($transaction_id !== null) {
            $resourcePath = str_replace(
                '{' . 'transactionId' . '}',
                ObjectSerializer::toPathValue($transaction_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_orders_items_transactions_transaction_id)) {
            $_tempBody = $_rest_orders_items_transactions_transaction_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdBookingPost
     *
     * Book an order in
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $delivery_note_number If desired, set the delivery note number provided by the supplier. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdBookingPost($order_id, $delivery_note_number = null)
    {
        list($response) = $this->restOrdersOrderIdBookingPostWithHttpInfo($order_id, $delivery_note_number);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdBookingPostWithHttpInfo
     *
     * Book an order in
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $delivery_note_number If desired, set the delivery note number provided by the supplier. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdBookingPostWithHttpInfo($order_id, $delivery_note_number = null)
    {
        $request = $this->restOrdersOrderIdBookingPostRequest($order_id, $delivery_note_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdBookingPostAsync
     *
     * Book an order in
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $delivery_note_number If desired, set the delivery note number provided by the supplier. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdBookingPostAsync($order_id, $delivery_note_number = null)
    {
        return $this->restOrdersOrderIdBookingPostAsyncWithHttpInfo($order_id, $delivery_note_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdBookingPostAsyncWithHttpInfo
     *
     * Book an order in
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $delivery_note_number If desired, set the delivery note number provided by the supplier. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdBookingPostAsyncWithHttpInfo($order_id, $delivery_note_number = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdBookingPostRequest($order_id, $delivery_note_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdBookingPost'
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $delivery_note_number If desired, set the delivery note number provided by the supplier. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdBookingPostRequest($order_id, $delivery_note_number = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdBookingPost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/booking';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($delivery_note_number)) {
            $delivery_note_number = ObjectSerializer::serializeCollection($delivery_note_number, '', true);
        }
        if ($delivery_note_number !== null) {
            $queryParams['deliveryNoteNumber'] = $delivery_note_number;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdCancelPut
     *
     * Cancel an order
     *
     * @param  int $order_id The ID of the order to be canceled. (required)
     * @param  \OpenAPI\Client\Model\InlineObject192 $_rest_orders_order_id_cancel _rest_orders_order_id_cancel (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restOrdersOrderIdCancelPut($order_id, $_rest_orders_order_id_cancel = null)
    {
        $this->restOrdersOrderIdCancelPutWithHttpInfo($order_id, $_rest_orders_order_id_cancel);
    }

    /**
     * Operation restOrdersOrderIdCancelPutWithHttpInfo
     *
     * Cancel an order
     *
     * @param  int $order_id The ID of the order to be canceled. (required)
     * @param  \OpenAPI\Client\Model\InlineObject192 $_rest_orders_order_id_cancel (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdCancelPutWithHttpInfo($order_id, $_rest_orders_order_id_cancel = null)
    {
        $request = $this->restOrdersOrderIdCancelPutRequest($order_id, $_rest_orders_order_id_cancel);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdCancelPutAsync
     *
     * Cancel an order
     *
     * @param  int $order_id The ID of the order to be canceled. (required)
     * @param  \OpenAPI\Client\Model\InlineObject192 $_rest_orders_order_id_cancel (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdCancelPutAsync($order_id, $_rest_orders_order_id_cancel = null)
    {
        return $this->restOrdersOrderIdCancelPutAsyncWithHttpInfo($order_id, $_rest_orders_order_id_cancel)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdCancelPutAsyncWithHttpInfo
     *
     * Cancel an order
     *
     * @param  int $order_id The ID of the order to be canceled. (required)
     * @param  \OpenAPI\Client\Model\InlineObject192 $_rest_orders_order_id_cancel (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdCancelPutAsyncWithHttpInfo($order_id, $_rest_orders_order_id_cancel = null)
    {
        $returnType = '';
        $request = $this->restOrdersOrderIdCancelPutRequest($order_id, $_rest_orders_order_id_cancel);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdCancelPut'
     *
     * @param  int $order_id The ID of the order to be canceled. (required)
     * @param  \OpenAPI\Client\Model\InlineObject192 $_rest_orders_order_id_cancel (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdCancelPutRequest($order_id, $_rest_orders_order_id_cancel = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdCancelPut'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/cancel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_orders_order_id_cancel)) {
            $_tempBody = $_rest_orders_order_id_cancel;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdContactWishGet
     *
     * Get a contact wish
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContactWish
     */
    public function restOrdersOrderIdContactWishGet($order_id)
    {
        list($response) = $this->restOrdersOrderIdContactWishGetWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdContactWishGetWithHttpInfo
     *
     * Get a contact wish
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContactWish, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdContactWishGetWithHttpInfo($order_id)
    {
        $request = $this->restOrdersOrderIdContactWishGetRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContactWish' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContactWish', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ContactWish';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContactWish',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdContactWishGetAsync
     *
     * Get a contact wish
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdContactWishGetAsync($order_id)
    {
        return $this->restOrdersOrderIdContactWishGetAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdContactWishGetAsyncWithHttpInfo
     *
     * Get a contact wish
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdContactWishGetAsyncWithHttpInfo($order_id)
    {
        $returnType = '\OpenAPI\Client\Model\ContactWish';
        $request = $this->restOrdersOrderIdContactWishGetRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdContactWishGet'
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdContactWishGetRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdContactWishGet'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/contactWish';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdCouponsCouponPost
     *
     * Redeem a coupon code
     *
     * @param  int $order_id The ID of the order to redeem the coupon (required)
     * @param  string $coupon The coupon code to be redeemed (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CouponCodeValidation
     */
    public function restOrdersOrderIdCouponsCouponPost($order_id, $coupon)
    {
        list($response) = $this->restOrdersOrderIdCouponsCouponPostWithHttpInfo($order_id, $coupon);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdCouponsCouponPostWithHttpInfo
     *
     * Redeem a coupon code
     *
     * @param  int $order_id The ID of the order to redeem the coupon (required)
     * @param  string $coupon The coupon code to be redeemed (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CouponCodeValidation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdCouponsCouponPostWithHttpInfo($order_id, $coupon)
    {
        $request = $this->restOrdersOrderIdCouponsCouponPostRequest($order_id, $coupon);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CouponCodeValidation' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CouponCodeValidation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CouponCodeValidation';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CouponCodeValidation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdCouponsCouponPostAsync
     *
     * Redeem a coupon code
     *
     * @param  int $order_id The ID of the order to redeem the coupon (required)
     * @param  string $coupon The coupon code to be redeemed (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdCouponsCouponPostAsync($order_id, $coupon)
    {
        return $this->restOrdersOrderIdCouponsCouponPostAsyncWithHttpInfo($order_id, $coupon)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdCouponsCouponPostAsyncWithHttpInfo
     *
     * Redeem a coupon code
     *
     * @param  int $order_id The ID of the order to redeem the coupon (required)
     * @param  string $coupon The coupon code to be redeemed (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdCouponsCouponPostAsyncWithHttpInfo($order_id, $coupon)
    {
        $returnType = '\OpenAPI\Client\Model\CouponCodeValidation';
        $request = $this->restOrdersOrderIdCouponsCouponPostRequest($order_id, $coupon);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdCouponsCouponPost'
     *
     * @param  int $order_id The ID of the order to redeem the coupon (required)
     * @param  string $coupon The coupon code to be redeemed (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdCouponsCouponPostRequest($order_id, $coupon)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdCouponsCouponPost'
            );
        }
        // verify the required parameter 'coupon' is set
        if ($coupon === null || (is_array($coupon) && count($coupon) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $coupon when calling restOrdersOrderIdCouponsCouponPost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/coupons/{coupon}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($coupon !== null) {
            $resourcePath = str_replace(
                '{' . 'coupon' . '}',
                ObjectSerializer::toPathValue($coupon),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDatesGet
     *
     * List all dates of an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderDate[]
     */
    public function restOrdersOrderIdDatesGet($order_id)
    {
        list($response) = $this->restOrdersOrderIdDatesGetWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDatesGetWithHttpInfo
     *
     * List all dates of an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderDate[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDatesGetWithHttpInfo($order_id)
    {
        $request = $this->restOrdersOrderIdDatesGetRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderDate[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderDate[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderDate[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderDate[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDatesGetAsync
     *
     * List all dates of an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDatesGetAsync($order_id)
    {
        return $this->restOrdersOrderIdDatesGetAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDatesGetAsyncWithHttpInfo
     *
     * List all dates of an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDatesGetAsyncWithHttpInfo($order_id)
    {
        $returnType = '\OpenAPI\Client\Model\OrderDate[]';
        $request = $this->restOrdersOrderIdDatesGetRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDatesGet'
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDatesGetRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDatesGet'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/dates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDatesTypeIdGet
     *
     * Get a date
     *
     * @param  int $type_id The ID of the order date type that should be found (required)
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderDate
     */
    public function restOrdersOrderIdDatesTypeIdGet($type_id, $order_id)
    {
        list($response) = $this->restOrdersOrderIdDatesTypeIdGetWithHttpInfo($type_id, $order_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDatesTypeIdGetWithHttpInfo
     *
     * Get a date
     *
     * @param  int $type_id The ID of the order date type that should be found (required)
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderDate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDatesTypeIdGetWithHttpInfo($type_id, $order_id)
    {
        $request = $this->restOrdersOrderIdDatesTypeIdGetRequest($type_id, $order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderDate' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderDate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderDate';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderDate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDatesTypeIdGetAsync
     *
     * Get a date
     *
     * @param  int $type_id The ID of the order date type that should be found (required)
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDatesTypeIdGetAsync($type_id, $order_id)
    {
        return $this->restOrdersOrderIdDatesTypeIdGetAsyncWithHttpInfo($type_id, $order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDatesTypeIdGetAsyncWithHttpInfo
     *
     * Get a date
     *
     * @param  int $type_id The ID of the order date type that should be found (required)
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDatesTypeIdGetAsyncWithHttpInfo($type_id, $order_id)
    {
        $returnType = '\OpenAPI\Client\Model\OrderDate';
        $request = $this->restOrdersOrderIdDatesTypeIdGetRequest($type_id, $order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDatesTypeIdGet'
     *
     * @param  int $type_id The ID of the order date type that should be found (required)
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDatesTypeIdGetRequest($type_id, $order_id)
    {
        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersOrderIdDatesTypeIdGet'
            );
        }
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDatesTypeIdGet'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/dates/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }
        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDelete
     *
     * Delete an order
     *
     * @param  int $order_id The ID of the order to be deleted. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restOrdersOrderIdDelete($order_id)
    {
        $this->restOrdersOrderIdDeleteWithHttpInfo($order_id);
    }

    /**
     * Operation restOrdersOrderIdDeleteWithHttpInfo
     *
     * Delete an order
     *
     * @param  int $order_id The ID of the order to be deleted. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDeleteWithHttpInfo($order_id)
    {
        $request = $this->restOrdersOrderIdDeleteRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDeleteAsync
     *
     * Delete an order
     *
     * @param  int $order_id The ID of the order to be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDeleteAsync($order_id)
    {
        return $this->restOrdersOrderIdDeleteAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDeleteAsyncWithHttpInfo
     *
     * Delete an order
     *
     * @param  int $order_id The ID of the order to be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDeleteAsyncWithHttpInfo($order_id)
    {
        $returnType = '';
        $request = $this->restOrdersOrderIdDeleteRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDelete'
     *
     * @param  int $order_id The ID of the order to be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDeleteRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDelete'
            );
        }

        $resourcePath = '/rest/orders/{orderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDeliveryOrdersAutomaticPost
     *
     * Create delivery orders automatically for all order items
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDeliveryOrdersAutomaticPost($order_id)
    {
        list($response) = $this->restOrdersOrderIdDeliveryOrdersAutomaticPostWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDeliveryOrdersAutomaticPostWithHttpInfo
     *
     * Create delivery orders automatically for all order items
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDeliveryOrdersAutomaticPostWithHttpInfo($order_id)
    {
        $request = $this->restOrdersOrderIdDeliveryOrdersAutomaticPostRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDeliveryOrdersAutomaticPostAsync
     *
     * Create delivery orders automatically for all order items
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDeliveryOrdersAutomaticPostAsync($order_id)
    {
        return $this->restOrdersOrderIdDeliveryOrdersAutomaticPostAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDeliveryOrdersAutomaticPostAsyncWithHttpInfo
     *
     * Create delivery orders automatically for all order items
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDeliveryOrdersAutomaticPostAsyncWithHttpInfo($order_id)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDeliveryOrdersAutomaticPostRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDeliveryOrdersAutomaticPost'
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDeliveryOrdersAutomaticPostRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDeliveryOrdersAutomaticPost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/delivery_orders/automatic';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDeliveryOrdersPost
     *
     * Create a delivery order from a parent order
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Order
     */
    public function restOrdersOrderIdDeliveryOrdersPost($order_id)
    {
        list($response) = $this->restOrdersOrderIdDeliveryOrdersPostWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDeliveryOrdersPostWithHttpInfo
     *
     * Create a delivery order from a parent order
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDeliveryOrdersPostWithHttpInfo($order_id)
    {
        $request = $this->restOrdersOrderIdDeliveryOrdersPostRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Order' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Order';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDeliveryOrdersPostAsync
     *
     * Create a delivery order from a parent order
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDeliveryOrdersPostAsync($order_id)
    {
        return $this->restOrdersOrderIdDeliveryOrdersPostAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDeliveryOrdersPostAsyncWithHttpInfo
     *
     * Create a delivery order from a parent order
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDeliveryOrdersPostAsyncWithHttpInfo($order_id)
    {
        $returnType = '\OpenAPI\Client\Model\Order';
        $request = $this->restOrdersOrderIdDeliveryOrdersPostRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDeliveryOrdersPost'
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDeliveryOrdersPostRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDeliveryOrdersPost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/delivery_orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdGet
     *
     * Get an order
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  int $with Load additional relations for an order. The following relations are available:      * &lt;ul&gt;        &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the reference type. The available reference types are parent and reorder. The ID of the reference and the relation itself are also available.&lt;/li&gt;        &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;        &lt;li&gt;&#39;location&#39; &#x3D; The accounting location linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;payments&#39; &#x3D; The payments linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;documents&#39; &#x3D; The documents linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;contactSender&#39; &#x3D; The contact belonging the contact-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The contact belonging to the contact-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The warehouse belonging to the warehouse-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The warehouse belonging to the warehouse-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation data belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;        &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations linked to the order item.&lt;/li&gt;      &lt;/ul&gt;      Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     * @param  bool $add_order_items Add the order items to the result. Default &#x3D; true. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Order
     */
    public function restOrdersOrderIdGet($order_id, $with = null, $add_order_items = null)
    {
        list($response) = $this->restOrdersOrderIdGetWithHttpInfo($order_id, $with, $add_order_items);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdGetWithHttpInfo
     *
     * Get an order
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  int $with Load additional relations for an order. The following relations are available:      * &lt;ul&gt;        &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the reference type. The available reference types are parent and reorder. The ID of the reference and the relation itself are also available.&lt;/li&gt;        &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;        &lt;li&gt;&#39;location&#39; &#x3D; The accounting location linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;payments&#39; &#x3D; The payments linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;documents&#39; &#x3D; The documents linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;contactSender&#39; &#x3D; The contact belonging the contact-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The contact belonging to the contact-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The warehouse belonging to the warehouse-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The warehouse belonging to the warehouse-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation data belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;        &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations linked to the order item.&lt;/li&gt;      &lt;/ul&gt;      Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     * @param  bool $add_order_items Add the order items to the result. Default &#x3D; true. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdGetWithHttpInfo($order_id, $with = null, $add_order_items = null)
    {
        $request = $this->restOrdersOrderIdGetRequest($order_id, $with, $add_order_items);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Order' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Order';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdGetAsync
     *
     * Get an order
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  int $with Load additional relations for an order. The following relations are available:      * &lt;ul&gt;        &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the reference type. The available reference types are parent and reorder. The ID of the reference and the relation itself are also available.&lt;/li&gt;        &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;        &lt;li&gt;&#39;location&#39; &#x3D; The accounting location linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;payments&#39; &#x3D; The payments linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;documents&#39; &#x3D; The documents linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;contactSender&#39; &#x3D; The contact belonging the contact-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The contact belonging to the contact-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The warehouse belonging to the warehouse-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The warehouse belonging to the warehouse-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation data belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;        &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations linked to the order item.&lt;/li&gt;      &lt;/ul&gt;      Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     * @param  bool $add_order_items Add the order items to the result. Default &#x3D; true. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdGetAsync($order_id, $with = null, $add_order_items = null)
    {
        return $this->restOrdersOrderIdGetAsyncWithHttpInfo($order_id, $with, $add_order_items)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdGetAsyncWithHttpInfo
     *
     * Get an order
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  int $with Load additional relations for an order. The following relations are available:      * &lt;ul&gt;        &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the reference type. The available reference types are parent and reorder. The ID of the reference and the relation itself are also available.&lt;/li&gt;        &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;        &lt;li&gt;&#39;location&#39; &#x3D; The accounting location linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;payments&#39; &#x3D; The payments linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;documents&#39; &#x3D; The documents linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;contactSender&#39; &#x3D; The contact belonging the contact-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The contact belonging to the contact-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The warehouse belonging to the warehouse-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The warehouse belonging to the warehouse-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation data belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;        &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations linked to the order item.&lt;/li&gt;      &lt;/ul&gt;      Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     * @param  bool $add_order_items Add the order items to the result. Default &#x3D; true. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdGetAsyncWithHttpInfo($order_id, $with = null, $add_order_items = null)
    {
        $returnType = '\OpenAPI\Client\Model\Order';
        $request = $this->restOrdersOrderIdGetRequest($order_id, $with, $add_order_items);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdGet'
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  int $with Load additional relations for an order. The following relations are available:      * &lt;ul&gt;        &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the reference type. The available reference types are parent and reorder. The ID of the reference and the relation itself are also available.&lt;/li&gt;        &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;        &lt;li&gt;&#39;location&#39; &#x3D; The accounting location linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;payments&#39; &#x3D; The payments linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;documents&#39; &#x3D; The documents linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;contactSender&#39; &#x3D; The contact belonging the contact-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The contact belonging to the contact-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The warehouse belonging to the warehouse-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The warehouse belonging to the warehouse-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation data belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;        &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations linked to the order item.&lt;/li&gt;      &lt;/ul&gt;      Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     * @param  bool $add_order_items Add the order items to the result. Default &#x3D; true. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdGetRequest($order_id, $with = null, $add_order_items = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdGet'
            );
        }

        $resourcePath = '/rest/orders/{orderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }
        // query params
        if (is_array($add_order_items)) {
            $add_order_items = ObjectSerializer::serializeCollection($add_order_items, '', true);
        }
        if ($add_order_items !== null) {
            $queryParams['addOrderItems'] = $add_order_items;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdItemsGet
     *
     * Search order items
     *
     * @param  int $order_id order_id (required)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of order items to be displayed per page. The default number of order items per page is 50. The maximum number is 250. (optional)
     * @param  string $sort_by Sort search result according to itemVariationId, orderItemName, createdAt, updatedAt or id. The default value is orderItemId. (optional)
     * @param  string $sort_order Sort direction desc or asc. The default value is asc. (optional)
     * @param  int $with Load additional relations for an order item. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;variation&#39; &#x3D; The variation that is associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;giftCardCodes&#39; &#x3D; The gift card codes that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;transactions&#39; &#x3D; The transactions that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;serialNumbers&#39; &#x3D; The serial numbers that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;variationBarcodes&#39; &#x3D; The barcodes that are associated with variation of the order item.&lt;/li&gt;     &lt;/ul&gt; (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20044
     */
    public function restOrdersOrderIdItemsGet($order_id, $page = null, $items_per_page = null, $sort_by = null, $sort_order = null, $with = null)
    {
        list($response) = $this->restOrdersOrderIdItemsGetWithHttpInfo($order_id, $page, $items_per_page, $sort_by, $sort_order, $with);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdItemsGetWithHttpInfo
     *
     * Search order items
     *
     * @param  int $order_id (required)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of order items to be displayed per page. The default number of order items per page is 50. The maximum number is 250. (optional)
     * @param  string $sort_by Sort search result according to itemVariationId, orderItemName, createdAt, updatedAt or id. The default value is orderItemId. (optional)
     * @param  string $sort_order Sort direction desc or asc. The default value is asc. (optional)
     * @param  int $with Load additional relations for an order item. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;variation&#39; &#x3D; The variation that is associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;giftCardCodes&#39; &#x3D; The gift card codes that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;transactions&#39; &#x3D; The transactions that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;serialNumbers&#39; &#x3D; The serial numbers that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;variationBarcodes&#39; &#x3D; The barcodes that are associated with variation of the order item.&lt;/li&gt;     &lt;/ul&gt; (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20044, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdItemsGetWithHttpInfo($order_id, $page = null, $items_per_page = null, $sort_by = null, $sort_order = null, $with = null)
    {
        $request = $this->restOrdersOrderIdItemsGetRequest($order_id, $page, $items_per_page, $sort_by, $sort_order, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20044' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20044', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20044';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20044',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdItemsGetAsync
     *
     * Search order items
     *
     * @param  int $order_id (required)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of order items to be displayed per page. The default number of order items per page is 50. The maximum number is 250. (optional)
     * @param  string $sort_by Sort search result according to itemVariationId, orderItemName, createdAt, updatedAt or id. The default value is orderItemId. (optional)
     * @param  string $sort_order Sort direction desc or asc. The default value is asc. (optional)
     * @param  int $with Load additional relations for an order item. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;variation&#39; &#x3D; The variation that is associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;giftCardCodes&#39; &#x3D; The gift card codes that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;transactions&#39; &#x3D; The transactions that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;serialNumbers&#39; &#x3D; The serial numbers that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;variationBarcodes&#39; &#x3D; The barcodes that are associated with variation of the order item.&lt;/li&gt;     &lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdItemsGetAsync($order_id, $page = null, $items_per_page = null, $sort_by = null, $sort_order = null, $with = null)
    {
        return $this->restOrdersOrderIdItemsGetAsyncWithHttpInfo($order_id, $page, $items_per_page, $sort_by, $sort_order, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdItemsGetAsyncWithHttpInfo
     *
     * Search order items
     *
     * @param  int $order_id (required)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of order items to be displayed per page. The default number of order items per page is 50. The maximum number is 250. (optional)
     * @param  string $sort_by Sort search result according to itemVariationId, orderItemName, createdAt, updatedAt or id. The default value is orderItemId. (optional)
     * @param  string $sort_order Sort direction desc or asc. The default value is asc. (optional)
     * @param  int $with Load additional relations for an order item. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;variation&#39; &#x3D; The variation that is associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;giftCardCodes&#39; &#x3D; The gift card codes that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;transactions&#39; &#x3D; The transactions that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;serialNumbers&#39; &#x3D; The serial numbers that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;variationBarcodes&#39; &#x3D; The barcodes that are associated with variation of the order item.&lt;/li&gt;     &lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdItemsGetAsyncWithHttpInfo($order_id, $page = null, $items_per_page = null, $sort_by = null, $sort_order = null, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20044';
        $request = $this->restOrdersOrderIdItemsGetRequest($order_id, $page, $items_per_page, $sort_by, $sort_order, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdItemsGet'
     *
     * @param  int $order_id (required)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of order items to be displayed per page. The default number of order items per page is 50. The maximum number is 250. (optional)
     * @param  string $sort_by Sort search result according to itemVariationId, orderItemName, createdAt, updatedAt or id. The default value is orderItemId. (optional)
     * @param  string $sort_order Sort direction desc or asc. The default value is asc. (optional)
     * @param  int $with Load additional relations for an order item. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;variation&#39; &#x3D; The variation that is associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;giftCardCodes&#39; &#x3D; The gift card codes that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;transactions&#39; &#x3D; The transactions that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;serialNumbers&#39; &#x3D; The serial numbers that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;variationBarcodes&#39; &#x3D; The barcodes that are associated with variation of the order item.&lt;/li&gt;     &lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdItemsGetRequest($order_id, $page = null, $items_per_page = null, $sort_by = null, $sort_order = null, $with = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdItemsGet'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }
        // query params
        if (is_array($sort_by)) {
            $sort_by = ObjectSerializer::serializeCollection($sort_by, '', true);
        }
        if ($sort_by !== null) {
            $queryParams['sortBy'] = $sort_by;
        }
        // query params
        if (is_array($sort_order)) {
            $sort_order = ObjectSerializer::serializeCollection($sort_order, '', true);
        }
        if ($sort_order !== null) {
            $queryParams['sortOrder'] = $sort_order;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdItemsOrderItemIdDelete
     *
     * Delete an order item
     *
     * @param  int $order_id The ID of the order that the item belongs to. (required)
     * @param  int $order_item_id The ID of the order item to be deleted. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restOrdersOrderIdItemsOrderItemIdDelete($order_id, $order_item_id)
    {
        $this->restOrdersOrderIdItemsOrderItemIdDeleteWithHttpInfo($order_id, $order_item_id);
    }

    /**
     * Operation restOrdersOrderIdItemsOrderItemIdDeleteWithHttpInfo
     *
     * Delete an order item
     *
     * @param  int $order_id The ID of the order that the item belongs to. (required)
     * @param  int $order_item_id The ID of the order item to be deleted. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdItemsOrderItemIdDeleteWithHttpInfo($order_id, $order_item_id)
    {
        $request = $this->restOrdersOrderIdItemsOrderItemIdDeleteRequest($order_id, $order_item_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdItemsOrderItemIdDeleteAsync
     *
     * Delete an order item
     *
     * @param  int $order_id The ID of the order that the item belongs to. (required)
     * @param  int $order_item_id The ID of the order item to be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdItemsOrderItemIdDeleteAsync($order_id, $order_item_id)
    {
        return $this->restOrdersOrderIdItemsOrderItemIdDeleteAsyncWithHttpInfo($order_id, $order_item_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdItemsOrderItemIdDeleteAsyncWithHttpInfo
     *
     * Delete an order item
     *
     * @param  int $order_id The ID of the order that the item belongs to. (required)
     * @param  int $order_item_id The ID of the order item to be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdItemsOrderItemIdDeleteAsyncWithHttpInfo($order_id, $order_item_id)
    {
        $returnType = '';
        $request = $this->restOrdersOrderIdItemsOrderItemIdDeleteRequest($order_id, $order_item_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdItemsOrderItemIdDelete'
     *
     * @param  int $order_id The ID of the order that the item belongs to. (required)
     * @param  int $order_item_id The ID of the order item to be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdItemsOrderItemIdDeleteRequest($order_id, $order_item_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdItemsOrderItemIdDelete'
            );
        }
        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersOrderIdItemsOrderItemIdDelete'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/items/{orderItemId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdItemsOrderItemIdSerialNumbersGet
     *
     * List serial numbers of an order item
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_item_id The ID of the order item (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderSerialNumber[]
     */
    public function restOrdersOrderIdItemsOrderItemIdSerialNumbersGet($order_id, $order_item_id)
    {
        list($response) = $this->restOrdersOrderIdItemsOrderItemIdSerialNumbersGetWithHttpInfo($order_id, $order_item_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdItemsOrderItemIdSerialNumbersGetWithHttpInfo
     *
     * List serial numbers of an order item
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_item_id The ID of the order item (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderSerialNumber[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdItemsOrderItemIdSerialNumbersGetWithHttpInfo($order_id, $order_item_id)
    {
        $request = $this->restOrdersOrderIdItemsOrderItemIdSerialNumbersGetRequest($order_id, $order_item_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderSerialNumber[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderSerialNumber[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderSerialNumber[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderSerialNumber[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdItemsOrderItemIdSerialNumbersGetAsync
     *
     * List serial numbers of an order item
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_item_id The ID of the order item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdItemsOrderItemIdSerialNumbersGetAsync($order_id, $order_item_id)
    {
        return $this->restOrdersOrderIdItemsOrderItemIdSerialNumbersGetAsyncWithHttpInfo($order_id, $order_item_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdItemsOrderItemIdSerialNumbersGetAsyncWithHttpInfo
     *
     * List serial numbers of an order item
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_item_id The ID of the order item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdItemsOrderItemIdSerialNumbersGetAsyncWithHttpInfo($order_id, $order_item_id)
    {
        $returnType = '\OpenAPI\Client\Model\OrderSerialNumber[]';
        $request = $this->restOrdersOrderIdItemsOrderItemIdSerialNumbersGetRequest($order_id, $order_item_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdItemsOrderItemIdSerialNumbersGet'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_item_id The ID of the order item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdItemsOrderItemIdSerialNumbersGetRequest($order_id, $order_item_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdItemsOrderItemIdSerialNumbersGet'
            );
        }
        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersOrderIdItemsOrderItemIdSerialNumbersGet'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/items/{orderItemId}/serialNumbers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdItemsSerialNumbersGet
     *
     * List serial numbers of an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderSerialNumber[]
     */
    public function restOrdersOrderIdItemsSerialNumbersGet($order_id)
    {
        list($response) = $this->restOrdersOrderIdItemsSerialNumbersGetWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdItemsSerialNumbersGetWithHttpInfo
     *
     * List serial numbers of an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderSerialNumber[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdItemsSerialNumbersGetWithHttpInfo($order_id)
    {
        $request = $this->restOrdersOrderIdItemsSerialNumbersGetRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderSerialNumber[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderSerialNumber[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderSerialNumber[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderSerialNumber[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdItemsSerialNumbersGetAsync
     *
     * List serial numbers of an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdItemsSerialNumbersGetAsync($order_id)
    {
        return $this->restOrdersOrderIdItemsSerialNumbersGetAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdItemsSerialNumbersGetAsyncWithHttpInfo
     *
     * List serial numbers of an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdItemsSerialNumbersGetAsyncWithHttpInfo($order_id)
    {
        $returnType = '\OpenAPI\Client\Model\OrderSerialNumber[]';
        $request = $this->restOrdersOrderIdItemsSerialNumbersGetRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdItemsSerialNumbersGet'
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdItemsSerialNumbersGetRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdItemsSerialNumbersGet'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/items/serialNumbers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdOutgoingStocksDelete
     *
     * Revert outgoing stock
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restOrdersOrderIdOutgoingStocksDelete($order_id)
    {
        $this->restOrdersOrderIdOutgoingStocksDeleteWithHttpInfo($order_id);
    }

    /**
     * Operation restOrdersOrderIdOutgoingStocksDeleteWithHttpInfo
     *
     * Revert outgoing stock
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdOutgoingStocksDeleteWithHttpInfo($order_id)
    {
        $request = $this->restOrdersOrderIdOutgoingStocksDeleteRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdOutgoingStocksDeleteAsync
     *
     * Revert outgoing stock
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdOutgoingStocksDeleteAsync($order_id)
    {
        return $this->restOrdersOrderIdOutgoingStocksDeleteAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdOutgoingStocksDeleteAsyncWithHttpInfo
     *
     * Revert outgoing stock
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdOutgoingStocksDeleteAsyncWithHttpInfo($order_id)
    {
        $returnType = '';
        $request = $this->restOrdersOrderIdOutgoingStocksDeleteRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdOutgoingStocksDelete'
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdOutgoingStocksDeleteRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdOutgoingStocksDelete'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/outgoing_stocks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdOutgoingStocksPost
     *
     * Book out order items
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $date The date that is saved as booking date for the outgoing stock. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restOrdersOrderIdOutgoingStocksPost($order_id, $date = null)
    {
        $this->restOrdersOrderIdOutgoingStocksPostWithHttpInfo($order_id, $date);
    }

    /**
     * Operation restOrdersOrderIdOutgoingStocksPostWithHttpInfo
     *
     * Book out order items
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $date The date that is saved as booking date for the outgoing stock. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdOutgoingStocksPostWithHttpInfo($order_id, $date = null)
    {
        $request = $this->restOrdersOrderIdOutgoingStocksPostRequest($order_id, $date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdOutgoingStocksPostAsync
     *
     * Book out order items
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $date The date that is saved as booking date for the outgoing stock. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdOutgoingStocksPostAsync($order_id, $date = null)
    {
        return $this->restOrdersOrderIdOutgoingStocksPostAsyncWithHttpInfo($order_id, $date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdOutgoingStocksPostAsyncWithHttpInfo
     *
     * Book out order items
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $date The date that is saved as booking date for the outgoing stock. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdOutgoingStocksPostAsyncWithHttpInfo($order_id, $date = null)
    {
        $returnType = '';
        $request = $this->restOrdersOrderIdOutgoingStocksPostRequest($order_id, $date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdOutgoingStocksPost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $date The date that is saved as booking date for the outgoing stock. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdOutgoingStocksPostRequest($order_id, $date = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdOutgoingStocksPost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/outgoing_stocks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($date)) {
            $date = ObjectSerializer::serializeCollection($date, '', true);
        }
        if ($date !== null) {
            $queryParams['date'] = $date;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdPackagenumbersGet
     *
     * List package numbers of an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function restOrdersOrderIdPackagenumbersGet($order_id)
    {
        list($response) = $this->restOrdersOrderIdPackagenumbersGetWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdPackagenumbersGetWithHttpInfo
     *
     * List package numbers of an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdPackagenumbersGetWithHttpInfo($order_id)
    {
        $request = $this->restOrdersOrderIdPackagenumbersGetRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdPackagenumbersGetAsync
     *
     * List package numbers of an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdPackagenumbersGetAsync($order_id)
    {
        return $this->restOrdersOrderIdPackagenumbersGetAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdPackagenumbersGetAsyncWithHttpInfo
     *
     * List package numbers of an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdPackagenumbersGetAsyncWithHttpInfo($order_id)
    {
        $returnType = 'object[]';
        $request = $this->restOrdersOrderIdPackagenumbersGetRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdPackagenumbersGet'
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdPackagenumbersGetRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdPackagenumbersGet'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/packagenumbers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdPropertiesPost
     *
     * Create property for an order
     *
     * @param  int $order_id order_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject194 $_rest_orders_order_id_properties _rest_orders_order_id_properties (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderProperty
     */
    public function restOrdersOrderIdPropertiesPost($order_id, $_rest_orders_order_id_properties = null)
    {
        list($response) = $this->restOrdersOrderIdPropertiesPostWithHttpInfo($order_id, $_rest_orders_order_id_properties);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdPropertiesPostWithHttpInfo
     *
     * Create property for an order
     *
     * @param  int $order_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject194 $_rest_orders_order_id_properties (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderProperty, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdPropertiesPostWithHttpInfo($order_id, $_rest_orders_order_id_properties = null)
    {
        $request = $this->restOrdersOrderIdPropertiesPostRequest($order_id, $_rest_orders_order_id_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderProperty' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderProperty', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderProperty';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderProperty',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdPropertiesPostAsync
     *
     * Create property for an order
     *
     * @param  int $order_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject194 $_rest_orders_order_id_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdPropertiesPostAsync($order_id, $_rest_orders_order_id_properties = null)
    {
        return $this->restOrdersOrderIdPropertiesPostAsyncWithHttpInfo($order_id, $_rest_orders_order_id_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdPropertiesPostAsyncWithHttpInfo
     *
     * Create property for an order
     *
     * @param  int $order_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject194 $_rest_orders_order_id_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdPropertiesPostAsyncWithHttpInfo($order_id, $_rest_orders_order_id_properties = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderProperty';
        $request = $this->restOrdersOrderIdPropertiesPostRequest($order_id, $_rest_orders_order_id_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdPropertiesPost'
     *
     * @param  int $order_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject194 $_rest_orders_order_id_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdPropertiesPostRequest($order_id, $_rest_orders_order_id_properties = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdPropertiesPost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/properties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_orders_order_id_properties)) {
            $_tempBody = $_rest_orders_order_id_properties;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdPropertiesTypeIdDelete
     *
     * Delete property of an order by order ID and property type ID
     *
     * @param  int $order_id order_id (required)
     * @param  int $type_id type_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject196 $_rest_orders_order_id_properties_type_id _rest_orders_order_id_properties_type_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdPropertiesTypeIdDelete($order_id, $type_id, $_rest_orders_order_id_properties_type_id = null)
    {
        list($response) = $this->restOrdersOrderIdPropertiesTypeIdDeleteWithHttpInfo($order_id, $type_id, $_rest_orders_order_id_properties_type_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdPropertiesTypeIdDeleteWithHttpInfo
     *
     * Delete property of an order by order ID and property type ID
     *
     * @param  int $order_id (required)
     * @param  int $type_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject196 $_rest_orders_order_id_properties_type_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdPropertiesTypeIdDeleteWithHttpInfo($order_id, $type_id, $_rest_orders_order_id_properties_type_id = null)
    {
        $request = $this->restOrdersOrderIdPropertiesTypeIdDeleteRequest($order_id, $type_id, $_rest_orders_order_id_properties_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdPropertiesTypeIdDeleteAsync
     *
     * Delete property of an order by order ID and property type ID
     *
     * @param  int $order_id (required)
     * @param  int $type_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject196 $_rest_orders_order_id_properties_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdPropertiesTypeIdDeleteAsync($order_id, $type_id, $_rest_orders_order_id_properties_type_id = null)
    {
        return $this->restOrdersOrderIdPropertiesTypeIdDeleteAsyncWithHttpInfo($order_id, $type_id, $_rest_orders_order_id_properties_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdPropertiesTypeIdDeleteAsyncWithHttpInfo
     *
     * Delete property of an order by order ID and property type ID
     *
     * @param  int $order_id (required)
     * @param  int $type_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject196 $_rest_orders_order_id_properties_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdPropertiesTypeIdDeleteAsyncWithHttpInfo($order_id, $type_id, $_rest_orders_order_id_properties_type_id = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdPropertiesTypeIdDeleteRequest($order_id, $type_id, $_rest_orders_order_id_properties_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdPropertiesTypeIdDelete'
     *
     * @param  int $order_id (required)
     * @param  int $type_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject196 $_rest_orders_order_id_properties_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdPropertiesTypeIdDeleteRequest($order_id, $type_id, $_rest_orders_order_id_properties_type_id = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdPropertiesTypeIdDelete'
            );
        }
        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersOrderIdPropertiesTypeIdDelete'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/properties/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_orders_order_id_properties_type_id)) {
            $_tempBody = $_rest_orders_order_id_properties_type_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdPropertiesTypeIdPut
     *
     * Update property of an order by order ID and property ID
     *
     * @param  int $order_id order_id (required)
     * @param  int $type_id type_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject195 $_rest_orders_order_id_properties_type_id _rest_orders_order_id_properties_type_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderProperty
     */
    public function restOrdersOrderIdPropertiesTypeIdPut($order_id, $type_id, $_rest_orders_order_id_properties_type_id = null)
    {
        list($response) = $this->restOrdersOrderIdPropertiesTypeIdPutWithHttpInfo($order_id, $type_id, $_rest_orders_order_id_properties_type_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdPropertiesTypeIdPutWithHttpInfo
     *
     * Update property of an order by order ID and property ID
     *
     * @param  int $order_id (required)
     * @param  int $type_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject195 $_rest_orders_order_id_properties_type_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderProperty, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdPropertiesTypeIdPutWithHttpInfo($order_id, $type_id, $_rest_orders_order_id_properties_type_id = null)
    {
        $request = $this->restOrdersOrderIdPropertiesTypeIdPutRequest($order_id, $type_id, $_rest_orders_order_id_properties_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderProperty' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderProperty', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderProperty';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderProperty',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdPropertiesTypeIdPutAsync
     *
     * Update property of an order by order ID and property ID
     *
     * @param  int $order_id (required)
     * @param  int $type_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject195 $_rest_orders_order_id_properties_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdPropertiesTypeIdPutAsync($order_id, $type_id, $_rest_orders_order_id_properties_type_id = null)
    {
        return $this->restOrdersOrderIdPropertiesTypeIdPutAsyncWithHttpInfo($order_id, $type_id, $_rest_orders_order_id_properties_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdPropertiesTypeIdPutAsyncWithHttpInfo
     *
     * Update property of an order by order ID and property ID
     *
     * @param  int $order_id (required)
     * @param  int $type_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject195 $_rest_orders_order_id_properties_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdPropertiesTypeIdPutAsyncWithHttpInfo($order_id, $type_id, $_rest_orders_order_id_properties_type_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderProperty';
        $request = $this->restOrdersOrderIdPropertiesTypeIdPutRequest($order_id, $type_id, $_rest_orders_order_id_properties_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdPropertiesTypeIdPut'
     *
     * @param  int $order_id (required)
     * @param  int $type_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject195 $_rest_orders_order_id_properties_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdPropertiesTypeIdPutRequest($order_id, $type_id, $_rest_orders_order_id_properties_type_id = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdPropertiesTypeIdPut'
            );
        }
        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersOrderIdPropertiesTypeIdPut'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/properties/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_orders_order_id_properties_type_id)) {
            $_tempBody = $_rest_orders_order_id_properties_type_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdPut
     *
     * Update an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \OpenAPI\Client\Model\InlineObject191 $_rest_orders_order_id _rest_orders_order_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Order
     */
    public function restOrdersOrderIdPut($order_id, $_rest_orders_order_id = null)
    {
        list($response) = $this->restOrdersOrderIdPutWithHttpInfo($order_id, $_rest_orders_order_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdPutWithHttpInfo
     *
     * Update an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \OpenAPI\Client\Model\InlineObject191 $_rest_orders_order_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdPutWithHttpInfo($order_id, $_rest_orders_order_id = null)
    {
        $request = $this->restOrdersOrderIdPutRequest($order_id, $_rest_orders_order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Order' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Order';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdPutAsync
     *
     * Update an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \OpenAPI\Client\Model\InlineObject191 $_rest_orders_order_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdPutAsync($order_id, $_rest_orders_order_id = null)
    {
        return $this->restOrdersOrderIdPutAsyncWithHttpInfo($order_id, $_rest_orders_order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdPutAsyncWithHttpInfo
     *
     * Update an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \OpenAPI\Client\Model\InlineObject191 $_rest_orders_order_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdPutAsyncWithHttpInfo($order_id, $_rest_orders_order_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\Order';
        $request = $this->restOrdersOrderIdPutRequest($order_id, $_rest_orders_order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdPut'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \OpenAPI\Client\Model\InlineObject191 $_rest_orders_order_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdPutRequest($order_id, $_rest_orders_order_id = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdPut'
            );
        }

        $resourcePath = '/rest/orders/{orderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_orders_order_id)) {
            $_tempBody = $_rest_orders_order_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingCancelShipmentDelete
     *
     * Cancel a shipment
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdShippingCancelShipmentDelete($order_id)
    {
        list($response) = $this->restOrdersOrderIdShippingCancelShipmentDeleteWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingCancelShipmentDeleteWithHttpInfo
     *
     * Cancel a shipment
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingCancelShipmentDeleteWithHttpInfo($order_id)
    {
        $request = $this->restOrdersOrderIdShippingCancelShipmentDeleteRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingCancelShipmentDeleteAsync
     *
     * Cancel a shipment
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingCancelShipmentDeleteAsync($order_id)
    {
        return $this->restOrdersOrderIdShippingCancelShipmentDeleteAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingCancelShipmentDeleteAsyncWithHttpInfo
     *
     * Cancel a shipment
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingCancelShipmentDeleteAsyncWithHttpInfo($order_id)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdShippingCancelShipmentDeleteRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingCancelShipmentDelete'
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdShippingCancelShipmentDeleteRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingCancelShipmentDelete'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/shipping/cancel_shipment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesDelete
     *
     * Delete all order shipping packages for an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restOrdersOrderIdShippingPackagesDelete($order_id)
    {
        $this->restOrdersOrderIdShippingPackagesDeleteWithHttpInfo($order_id);
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesDeleteWithHttpInfo
     *
     * Delete all order shipping packages for an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPackagesDeleteWithHttpInfo($order_id)
    {
        $request = $this->restOrdersOrderIdShippingPackagesDeleteRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesDeleteAsync
     *
     * Delete all order shipping packages for an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesDeleteAsync($order_id)
    {
        return $this->restOrdersOrderIdShippingPackagesDeleteAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesDeleteAsyncWithHttpInfo
     *
     * Delete all order shipping packages for an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesDeleteAsyncWithHttpInfo($order_id)
    {
        $returnType = '';
        $request = $this->restOrdersOrderIdShippingPackagesDeleteRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPackagesDelete'
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdShippingPackagesDeleteRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPackagesDelete'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/shipping/packages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesGet
     *
     * List order shipping packages
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $columns The properties to be loaded (optional)
     * @param  string $with Possible value is &#39;labelBase64&#39; (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderShippingPackage[]
     */
    public function restOrdersOrderIdShippingPackagesGet($order_id, $columns = null, $with = null)
    {
        list($response) = $this->restOrdersOrderIdShippingPackagesGetWithHttpInfo($order_id, $columns, $with);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesGetWithHttpInfo
     *
     * List order shipping packages
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $columns The properties to be loaded (optional)
     * @param  string $with Possible value is &#39;labelBase64&#39; (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderShippingPackage[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPackagesGetWithHttpInfo($order_id, $columns = null, $with = null)
    {
        $request = $this->restOrdersOrderIdShippingPackagesGetRequest($order_id, $columns, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderShippingPackage[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderShippingPackage[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderShippingPackage[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderShippingPackage[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesGetAsync
     *
     * List order shipping packages
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $columns The properties to be loaded (optional)
     * @param  string $with Possible value is &#39;labelBase64&#39; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesGetAsync($order_id, $columns = null, $with = null)
    {
        return $this->restOrdersOrderIdShippingPackagesGetAsyncWithHttpInfo($order_id, $columns, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesGetAsyncWithHttpInfo
     *
     * List order shipping packages
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $columns The properties to be loaded (optional)
     * @param  string $with Possible value is &#39;labelBase64&#39; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesGetAsyncWithHttpInfo($order_id, $columns = null, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderShippingPackage[]';
        $request = $this->restOrdersOrderIdShippingPackagesGetRequest($order_id, $columns, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPackagesGet'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $columns The properties to be loaded (optional)
     * @param  string $with Possible value is &#39;labelBase64&#39; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdShippingPackagesGetRequest($order_id, $columns = null, $with = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPackagesGet'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/shipping/packages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($columns)) {
            $columns = ObjectSerializer::serializeCollection($columns, '', true);
        }
        if ($columns !== null) {
            $queryParams['columns'] = $columns;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesItemsGet
     *
     * List items contained in packages of an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderShippingPackageItems
     */
    public function restOrdersOrderIdShippingPackagesItemsGet($order_id)
    {
        list($response) = $this->restOrdersOrderIdShippingPackagesItemsGetWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesItemsGetWithHttpInfo
     *
     * List items contained in packages of an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderShippingPackageItems, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPackagesItemsGetWithHttpInfo($order_id)
    {
        $request = $this->restOrdersOrderIdShippingPackagesItemsGetRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderShippingPackageItems' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderShippingPackageItems', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderShippingPackageItems';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderShippingPackageItems',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesItemsGetAsync
     *
     * List items contained in packages of an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesItemsGetAsync($order_id)
    {
        return $this->restOrdersOrderIdShippingPackagesItemsGetAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesItemsGetAsyncWithHttpInfo
     *
     * List items contained in packages of an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesItemsGetAsyncWithHttpInfo($order_id)
    {
        $returnType = '\OpenAPI\Client\Model\OrderShippingPackageItems';
        $request = $this->restOrdersOrderIdShippingPackagesItemsGetRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPackagesItemsGet'
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdShippingPackagesItemsGetRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPackagesItemsGet'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/shipping/packages/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesOrderShippingPackageIdDelete
     *
     * Delete an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdDelete($order_id, $order_shipping_package_id)
    {
        $this->restOrdersOrderIdShippingPackagesOrderShippingPackageIdDeleteWithHttpInfo($order_id, $order_shipping_package_id);
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesOrderShippingPackageIdDeleteWithHttpInfo
     *
     * Delete an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdDeleteWithHttpInfo($order_id, $order_shipping_package_id)
    {
        $request = $this->restOrdersOrderIdShippingPackagesOrderShippingPackageIdDeleteRequest($order_id, $order_shipping_package_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesOrderShippingPackageIdDeleteAsync
     *
     * Delete an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdDeleteAsync($order_id, $order_shipping_package_id)
    {
        return $this->restOrdersOrderIdShippingPackagesOrderShippingPackageIdDeleteAsyncWithHttpInfo($order_id, $order_shipping_package_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesOrderShippingPackageIdDeleteAsyncWithHttpInfo
     *
     * Delete an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdDeleteAsyncWithHttpInfo($order_id, $order_shipping_package_id)
    {
        $returnType = '';
        $request = $this->restOrdersOrderIdShippingPackagesOrderShippingPackageIdDeleteRequest($order_id, $order_shipping_package_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPackagesOrderShippingPackageIdDelete'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdShippingPackagesOrderShippingPackageIdDeleteRequest($order_id, $order_shipping_package_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPackagesOrderShippingPackageIdDelete'
            );
        }
        // verify the required parameter 'order_shipping_package_id' is set
        if ($order_shipping_package_id === null || (is_array($order_shipping_package_id) && count($order_shipping_package_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_shipping_package_id when calling restOrdersOrderIdShippingPackagesOrderShippingPackageIdDelete'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/shipping/packages/{orderShippingPackageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($order_shipping_package_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderShippingPackageId' . '}',
                ObjectSerializer::toPathValue($order_shipping_package_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesOrderShippingPackageIdGet
     *
     * Get an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  int $columns The properties to be loaded (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderShippingPackage
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdGet($order_id, $order_shipping_package_id, $columns = null)
    {
        list($response) = $this->restOrdersOrderIdShippingPackagesOrderShippingPackageIdGetWithHttpInfo($order_id, $order_shipping_package_id, $columns);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesOrderShippingPackageIdGetWithHttpInfo
     *
     * Get an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  int $columns The properties to be loaded (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderShippingPackage, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdGetWithHttpInfo($order_id, $order_shipping_package_id, $columns = null)
    {
        $request = $this->restOrdersOrderIdShippingPackagesOrderShippingPackageIdGetRequest($order_id, $order_shipping_package_id, $columns);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderShippingPackage' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderShippingPackage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderShippingPackage';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderShippingPackage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesOrderShippingPackageIdGetAsync
     *
     * Get an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  int $columns The properties to be loaded (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdGetAsync($order_id, $order_shipping_package_id, $columns = null)
    {
        return $this->restOrdersOrderIdShippingPackagesOrderShippingPackageIdGetAsyncWithHttpInfo($order_id, $order_shipping_package_id, $columns)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesOrderShippingPackageIdGetAsyncWithHttpInfo
     *
     * Get an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  int $columns The properties to be loaded (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdGetAsyncWithHttpInfo($order_id, $order_shipping_package_id, $columns = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderShippingPackage';
        $request = $this->restOrdersOrderIdShippingPackagesOrderShippingPackageIdGetRequest($order_id, $order_shipping_package_id, $columns);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPackagesOrderShippingPackageIdGet'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  int $columns The properties to be loaded (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdShippingPackagesOrderShippingPackageIdGetRequest($order_id, $order_shipping_package_id, $columns = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPackagesOrderShippingPackageIdGet'
            );
        }
        // verify the required parameter 'order_shipping_package_id' is set
        if ($order_shipping_package_id === null || (is_array($order_shipping_package_id) && count($order_shipping_package_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_shipping_package_id when calling restOrdersOrderIdShippingPackagesOrderShippingPackageIdGet'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/shipping/packages/{orderShippingPackageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($columns)) {
            $columns = ObjectSerializer::serializeCollection($columns, '', true);
        }
        if ($columns !== null) {
            $queryParams['columns'] = $columns;
        }


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($order_shipping_package_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderShippingPackageId' . '}',
                ObjectSerializer::toPathValue($order_shipping_package_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesOrderShippingPackageIdPut
     *
     * Update an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  \OpenAPI\Client\Model\InlineObject198 $_rest_orders_order_id_shipping_packages_order_shipping_package_id _rest_orders_order_id_shipping_packages_order_shipping_package_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderShippingPackage
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdPut($order_id, $order_shipping_package_id, $_rest_orders_order_id_shipping_packages_order_shipping_package_id = null)
    {
        list($response) = $this->restOrdersOrderIdShippingPackagesOrderShippingPackageIdPutWithHttpInfo($order_id, $order_shipping_package_id, $_rest_orders_order_id_shipping_packages_order_shipping_package_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesOrderShippingPackageIdPutWithHttpInfo
     *
     * Update an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  \OpenAPI\Client\Model\InlineObject198 $_rest_orders_order_id_shipping_packages_order_shipping_package_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderShippingPackage, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdPutWithHttpInfo($order_id, $order_shipping_package_id, $_rest_orders_order_id_shipping_packages_order_shipping_package_id = null)
    {
        $request = $this->restOrdersOrderIdShippingPackagesOrderShippingPackageIdPutRequest($order_id, $order_shipping_package_id, $_rest_orders_order_id_shipping_packages_order_shipping_package_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderShippingPackage' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderShippingPackage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderShippingPackage';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderShippingPackage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesOrderShippingPackageIdPutAsync
     *
     * Update an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  \OpenAPI\Client\Model\InlineObject198 $_rest_orders_order_id_shipping_packages_order_shipping_package_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdPutAsync($order_id, $order_shipping_package_id, $_rest_orders_order_id_shipping_packages_order_shipping_package_id = null)
    {
        return $this->restOrdersOrderIdShippingPackagesOrderShippingPackageIdPutAsyncWithHttpInfo($order_id, $order_shipping_package_id, $_rest_orders_order_id_shipping_packages_order_shipping_package_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesOrderShippingPackageIdPutAsyncWithHttpInfo
     *
     * Update an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  \OpenAPI\Client\Model\InlineObject198 $_rest_orders_order_id_shipping_packages_order_shipping_package_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdPutAsyncWithHttpInfo($order_id, $order_shipping_package_id, $_rest_orders_order_id_shipping_packages_order_shipping_package_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderShippingPackage';
        $request = $this->restOrdersOrderIdShippingPackagesOrderShippingPackageIdPutRequest($order_id, $order_shipping_package_id, $_rest_orders_order_id_shipping_packages_order_shipping_package_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPackagesOrderShippingPackageIdPut'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  \OpenAPI\Client\Model\InlineObject198 $_rest_orders_order_id_shipping_packages_order_shipping_package_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdShippingPackagesOrderShippingPackageIdPutRequest($order_id, $order_shipping_package_id, $_rest_orders_order_id_shipping_packages_order_shipping_package_id = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPackagesOrderShippingPackageIdPut'
            );
        }
        // verify the required parameter 'order_shipping_package_id' is set
        if ($order_shipping_package_id === null || (is_array($order_shipping_package_id) && count($order_shipping_package_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_shipping_package_id when calling restOrdersOrderIdShippingPackagesOrderShippingPackageIdPut'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/shipping/packages/{orderShippingPackageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($order_shipping_package_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderShippingPackageId' . '}',
                ObjectSerializer::toPathValue($order_shipping_package_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_orders_order_id_shipping_packages_order_shipping_package_id)) {
            $_tempBody = $_rest_orders_order_id_shipping_packages_order_shipping_package_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesPackedItemsGet
     *
     * List packed items of a shipping package by the order ID
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function restOrdersOrderIdShippingPackagesPackedItemsGet($order_id)
    {
        list($response) = $this->restOrdersOrderIdShippingPackagesPackedItemsGetWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesPackedItemsGetWithHttpInfo
     *
     * List packed items of a shipping package by the order ID
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPackagesPackedItemsGetWithHttpInfo($order_id)
    {
        $request = $this->restOrdersOrderIdShippingPackagesPackedItemsGetRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesPackedItemsGetAsync
     *
     * List packed items of a shipping package by the order ID
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesPackedItemsGetAsync($order_id)
    {
        return $this->restOrdersOrderIdShippingPackagesPackedItemsGetAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesPackedItemsGetAsyncWithHttpInfo
     *
     * List packed items of a shipping package by the order ID
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesPackedItemsGetAsyncWithHttpInfo($order_id)
    {
        $returnType = 'object[]';
        $request = $this->restOrdersOrderIdShippingPackagesPackedItemsGetRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPackagesPackedItemsGet'
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdShippingPackagesPackedItemsGetRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPackagesPackedItemsGet'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/shipping/packages/packed_items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesPost
     *
     * Create an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \OpenAPI\Client\Model\InlineObject197 $_rest_orders_order_id_shipping_packages _rest_orders_order_id_shipping_packages (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderShippingPackage
     */
    public function restOrdersOrderIdShippingPackagesPost($order_id, $_rest_orders_order_id_shipping_packages = null)
    {
        list($response) = $this->restOrdersOrderIdShippingPackagesPostWithHttpInfo($order_id, $_rest_orders_order_id_shipping_packages);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesPostWithHttpInfo
     *
     * Create an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \OpenAPI\Client\Model\InlineObject197 $_rest_orders_order_id_shipping_packages (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderShippingPackage, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPackagesPostWithHttpInfo($order_id, $_rest_orders_order_id_shipping_packages = null)
    {
        $request = $this->restOrdersOrderIdShippingPackagesPostRequest($order_id, $_rest_orders_order_id_shipping_packages);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderShippingPackage' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderShippingPackage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderShippingPackage';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderShippingPackage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesPostAsync
     *
     * Create an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \OpenAPI\Client\Model\InlineObject197 $_rest_orders_order_id_shipping_packages (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesPostAsync($order_id, $_rest_orders_order_id_shipping_packages = null)
    {
        return $this->restOrdersOrderIdShippingPackagesPostAsyncWithHttpInfo($order_id, $_rest_orders_order_id_shipping_packages)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesPostAsyncWithHttpInfo
     *
     * Create an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \OpenAPI\Client\Model\InlineObject197 $_rest_orders_order_id_shipping_packages (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesPostAsyncWithHttpInfo($order_id, $_rest_orders_order_id_shipping_packages = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderShippingPackage';
        $request = $this->restOrdersOrderIdShippingPackagesPostRequest($order_id, $_rest_orders_order_id_shipping_packages);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPackagesPost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \OpenAPI\Client\Model\InlineObject197 $_rest_orders_order_id_shipping_packages (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdShippingPackagesPostRequest($order_id, $_rest_orders_order_id_shipping_packages = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPackagesPost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/shipping/packages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_orders_order_id_shipping_packages)) {
            $_tempBody = $_rest_orders_order_id_shipping_packages;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesUnpackedItemsGet
     *
     * List unpacked items of a shipping package by the order ID
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function restOrdersOrderIdShippingPackagesUnpackedItemsGet($order_id)
    {
        list($response) = $this->restOrdersOrderIdShippingPackagesUnpackedItemsGetWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesUnpackedItemsGetWithHttpInfo
     *
     * List unpacked items of a shipping package by the order ID
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPackagesUnpackedItemsGetWithHttpInfo($order_id)
    {
        $request = $this->restOrdersOrderIdShippingPackagesUnpackedItemsGetRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesUnpackedItemsGetAsync
     *
     * List unpacked items of a shipping package by the order ID
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesUnpackedItemsGetAsync($order_id)
    {
        return $this->restOrdersOrderIdShippingPackagesUnpackedItemsGetAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesUnpackedItemsGetAsyncWithHttpInfo
     *
     * List unpacked items of a shipping package by the order ID
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesUnpackedItemsGetAsyncWithHttpInfo($order_id)
    {
        $returnType = 'object[]';
        $request = $this->restOrdersOrderIdShippingPackagesUnpackedItemsGetRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPackagesUnpackedItemsGet'
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdShippingPackagesUnpackedItemsGetRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPackagesUnpackedItemsGet'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/shipping/packages/unpacked_items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPackagesItemsGet
     *
     * List items contained in package pallets of an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderShippingPackageItems
     */
    public function restOrdersOrderIdShippingPalletsPackagesItemsGet($order_id)
    {
        list($response) = $this->restOrdersOrderIdShippingPalletsPackagesItemsGetWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPackagesItemsGetWithHttpInfo
     *
     * List items contained in package pallets of an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderShippingPackageItems, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPalletsPackagesItemsGetWithHttpInfo($order_id)
    {
        $request = $this->restOrdersOrderIdShippingPalletsPackagesItemsGetRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderShippingPackageItems' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderShippingPackageItems', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderShippingPackageItems';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderShippingPackageItems',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPackagesItemsGetAsync
     *
     * List items contained in package pallets of an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPalletsPackagesItemsGetAsync($order_id)
    {
        return $this->restOrdersOrderIdShippingPalletsPackagesItemsGetAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPackagesItemsGetAsyncWithHttpInfo
     *
     * List items contained in package pallets of an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPalletsPackagesItemsGetAsyncWithHttpInfo($order_id)
    {
        $returnType = '\OpenAPI\Client\Model\OrderShippingPackageItems';
        $request = $this->restOrdersOrderIdShippingPalletsPackagesItemsGetRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPalletsPackagesItemsGet'
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdShippingPalletsPackagesItemsGetRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPalletsPackagesItemsGet'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/shipping/pallets/packages/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPalletIdPackagesDelete
     *
     * Delete all order shipping packages in a pallet
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesDelete($order_id, $pallet_id)
    {
        list($response) = $this->restOrdersOrderIdShippingPalletsPalletIdPackagesDeleteWithHttpInfo($order_id, $pallet_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPalletIdPackagesDeleteWithHttpInfo
     *
     * Delete all order shipping packages in a pallet
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesDeleteWithHttpInfo($order_id, $pallet_id)
    {
        $request = $this->restOrdersOrderIdShippingPalletsPalletIdPackagesDeleteRequest($order_id, $pallet_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPalletIdPackagesDeleteAsync
     *
     * Delete all order shipping packages in a pallet
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesDeleteAsync($order_id, $pallet_id)
    {
        return $this->restOrdersOrderIdShippingPalletsPalletIdPackagesDeleteAsyncWithHttpInfo($order_id, $pallet_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPalletIdPackagesDeleteAsyncWithHttpInfo
     *
     * Delete all order shipping packages in a pallet
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesDeleteAsyncWithHttpInfo($order_id, $pallet_id)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdShippingPalletsPalletIdPackagesDeleteRequest($order_id, $pallet_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPalletsPalletIdPackagesDelete'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdShippingPalletsPalletIdPackagesDeleteRequest($order_id, $pallet_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPalletsPalletIdPackagesDelete'
            );
        }
        // verify the required parameter 'pallet_id' is set
        if ($pallet_id === null || (is_array($pallet_id) && count($pallet_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pallet_id when calling restOrdersOrderIdShippingPalletsPalletIdPackagesDelete'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/shipping/pallets/{palletId}/packages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($pallet_id !== null) {
            $resourcePath = str_replace(
                '{' . 'palletId' . '}',
                ObjectSerializer::toPathValue($pallet_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPalletIdPackagesGet
     *
     * List all packages contained in pallets of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderShippingPackage[]
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesGet($order_id, $pallet_id)
    {
        list($response) = $this->restOrdersOrderIdShippingPalletsPalletIdPackagesGetWithHttpInfo($order_id, $pallet_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPalletIdPackagesGetWithHttpInfo
     *
     * List all packages contained in pallets of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderShippingPackage[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesGetWithHttpInfo($order_id, $pallet_id)
    {
        $request = $this->restOrdersOrderIdShippingPalletsPalletIdPackagesGetRequest($order_id, $pallet_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderShippingPackage[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderShippingPackage[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderShippingPackage[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderShippingPackage[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPalletIdPackagesGetAsync
     *
     * List all packages contained in pallets of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesGetAsync($order_id, $pallet_id)
    {
        return $this->restOrdersOrderIdShippingPalletsPalletIdPackagesGetAsyncWithHttpInfo($order_id, $pallet_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPalletIdPackagesGetAsyncWithHttpInfo
     *
     * List all packages contained in pallets of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesGetAsyncWithHttpInfo($order_id, $pallet_id)
    {
        $returnType = '\OpenAPI\Client\Model\OrderShippingPackage[]';
        $request = $this->restOrdersOrderIdShippingPalletsPalletIdPackagesGetRequest($order_id, $pallet_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPalletsPalletIdPackagesGet'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdShippingPalletsPalletIdPackagesGetRequest($order_id, $pallet_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPalletsPalletIdPackagesGet'
            );
        }
        // verify the required parameter 'pallet_id' is set
        if ($pallet_id === null || (is_array($pallet_id) && count($pallet_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pallet_id when calling restOrdersOrderIdShippingPalletsPalletIdPackagesGet'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/shipping/pallets/{palletId}/packages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($pallet_id !== null) {
            $resourcePath = str_replace(
                '{' . 'palletId' . '}',
                ObjectSerializer::toPathValue($pallet_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPalletIdPackagesPut
     *
     * Update all packages in a pallet
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesPut($order_id, $pallet_id)
    {
        list($response) = $this->restOrdersOrderIdShippingPalletsPalletIdPackagesPutWithHttpInfo($order_id, $pallet_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPalletIdPackagesPutWithHttpInfo
     *
     * Update all packages in a pallet
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesPutWithHttpInfo($order_id, $pallet_id)
    {
        $request = $this->restOrdersOrderIdShippingPalletsPalletIdPackagesPutRequest($order_id, $pallet_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPalletIdPackagesPutAsync
     *
     * Update all packages in a pallet
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesPutAsync($order_id, $pallet_id)
    {
        return $this->restOrdersOrderIdShippingPalletsPalletIdPackagesPutAsyncWithHttpInfo($order_id, $pallet_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPalletIdPackagesPutAsyncWithHttpInfo
     *
     * Update all packages in a pallet
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesPutAsyncWithHttpInfo($order_id, $pallet_id)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdShippingPalletsPalletIdPackagesPutRequest($order_id, $pallet_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPalletsPalletIdPackagesPut'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdShippingPalletsPalletIdPackagesPutRequest($order_id, $pallet_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPalletsPalletIdPackagesPut'
            );
        }
        // verify the required parameter 'pallet_id' is set
        if ($pallet_id === null || (is_array($pallet_id) && count($pallet_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pallet_id when calling restOrdersOrderIdShippingPalletsPalletIdPackagesPut'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/shipping/pallets/{palletId}/packages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($pallet_id !== null) {
            $resourcePath = str_replace(
                '{' . 'palletId' . '}',
                ObjectSerializer::toPathValue($pallet_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingRegisterShipmentPost
     *
     * Register a shipment
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdShippingRegisterShipmentPost($order_id)
    {
        list($response) = $this->restOrdersOrderIdShippingRegisterShipmentPostWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingRegisterShipmentPostWithHttpInfo
     *
     * Register a shipment
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingRegisterShipmentPostWithHttpInfo($order_id)
    {
        $request = $this->restOrdersOrderIdShippingRegisterShipmentPostRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingRegisterShipmentPostAsync
     *
     * Register a shipment
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingRegisterShipmentPostAsync($order_id)
    {
        return $this->restOrdersOrderIdShippingRegisterShipmentPostAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingRegisterShipmentPostAsyncWithHttpInfo
     *
     * Register a shipment
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingRegisterShipmentPostAsyncWithHttpInfo($order_id)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdShippingRegisterShipmentPostRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingRegisterShipmentPost'
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdShippingRegisterShipmentPostRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingRegisterShipmentPost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/shipping/register_shipment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationAdditionalDataPut
     *
     * Update additional data of the shipping information
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ShippingInformation
     */
    public function restOrdersOrderIdShippingShippingInformationAdditionalDataPut($order_id)
    {
        list($response) = $this->restOrdersOrderIdShippingShippingInformationAdditionalDataPutWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationAdditionalDataPutWithHttpInfo
     *
     * Update additional data of the shipping information
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ShippingInformation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingShippingInformationAdditionalDataPutWithHttpInfo($order_id)
    {
        $request = $this->restOrdersOrderIdShippingShippingInformationAdditionalDataPutRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ShippingInformation' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ShippingInformation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ShippingInformation';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ShippingInformation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationAdditionalDataPutAsync
     *
     * Update additional data of the shipping information
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingShippingInformationAdditionalDataPutAsync($order_id)
    {
        return $this->restOrdersOrderIdShippingShippingInformationAdditionalDataPutAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationAdditionalDataPutAsyncWithHttpInfo
     *
     * Update additional data of the shipping information
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingShippingInformationAdditionalDataPutAsyncWithHttpInfo($order_id)
    {
        $returnType = '\OpenAPI\Client\Model\ShippingInformation';
        $request = $this->restOrdersOrderIdShippingShippingInformationAdditionalDataPutRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingShippingInformationAdditionalDataPut'
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdShippingShippingInformationAdditionalDataPutRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingShippingInformationAdditionalDataPut'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/shipping/shipping_information/additional_data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationDelete
     *
     * Delete shipping information
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ShippingInformation
     */
    public function restOrdersOrderIdShippingShippingInformationDelete($order_id)
    {
        list($response) = $this->restOrdersOrderIdShippingShippingInformationDeleteWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationDeleteWithHttpInfo
     *
     * Delete shipping information
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ShippingInformation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingShippingInformationDeleteWithHttpInfo($order_id)
    {
        $request = $this->restOrdersOrderIdShippingShippingInformationDeleteRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ShippingInformation' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ShippingInformation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ShippingInformation';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ShippingInformation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationDeleteAsync
     *
     * Delete shipping information
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingShippingInformationDeleteAsync($order_id)
    {
        return $this->restOrdersOrderIdShippingShippingInformationDeleteAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationDeleteAsyncWithHttpInfo
     *
     * Delete shipping information
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingShippingInformationDeleteAsyncWithHttpInfo($order_id)
    {
        $returnType = '\OpenAPI\Client\Model\ShippingInformation';
        $request = $this->restOrdersOrderIdShippingShippingInformationDeleteRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingShippingInformationDelete'
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdShippingShippingInformationDeleteRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingShippingInformationDelete'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/shipping/shipping_information';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationGet
     *
     * Get shipping information
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ShippingInformation
     */
    public function restOrdersOrderIdShippingShippingInformationGet($order_id)
    {
        list($response) = $this->restOrdersOrderIdShippingShippingInformationGetWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationGetWithHttpInfo
     *
     * Get shipping information
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ShippingInformation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingShippingInformationGetWithHttpInfo($order_id)
    {
        $request = $this->restOrdersOrderIdShippingShippingInformationGetRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ShippingInformation' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ShippingInformation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ShippingInformation';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ShippingInformation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationGetAsync
     *
     * Get shipping information
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingShippingInformationGetAsync($order_id)
    {
        return $this->restOrdersOrderIdShippingShippingInformationGetAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationGetAsyncWithHttpInfo
     *
     * Get shipping information
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingShippingInformationGetAsyncWithHttpInfo($order_id)
    {
        $returnType = '\OpenAPI\Client\Model\ShippingInformation';
        $request = $this->restOrdersOrderIdShippingShippingInformationGetRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingShippingInformationGet'
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdShippingShippingInformationGetRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingShippingInformationGet'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/shipping/shipping_information';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationStatusPut
     *
     * Update the shipping status of the shipping information
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ShippingInformation
     */
    public function restOrdersOrderIdShippingShippingInformationStatusPut($order_id)
    {
        list($response) = $this->restOrdersOrderIdShippingShippingInformationStatusPutWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationStatusPutWithHttpInfo
     *
     * Update the shipping status of the shipping information
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ShippingInformation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingShippingInformationStatusPutWithHttpInfo($order_id)
    {
        $request = $this->restOrdersOrderIdShippingShippingInformationStatusPutRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ShippingInformation' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ShippingInformation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ShippingInformation';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ShippingInformation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationStatusPutAsync
     *
     * Update the shipping status of the shipping information
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingShippingInformationStatusPutAsync($order_id)
    {
        return $this->restOrdersOrderIdShippingShippingInformationStatusPutAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationStatusPutAsyncWithHttpInfo
     *
     * Update the shipping status of the shipping information
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdShippingShippingInformationStatusPutAsyncWithHttpInfo($order_id)
    {
        $returnType = '\OpenAPI\Client\Model\ShippingInformation';
        $request = $this->restOrdersOrderIdShippingShippingInformationStatusPutRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingShippingInformationStatusPut'
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdShippingShippingInformationStatusPutRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingShippingInformationStatusPut'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/shipping/shipping_information/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdStatusHistoryGet
     *
     * Get the status history of an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\StatusHistoryEntry[]
     */
    public function restOrdersOrderIdStatusHistoryGet($order_id)
    {
        list($response) = $this->restOrdersOrderIdStatusHistoryGetWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdStatusHistoryGetWithHttpInfo
     *
     * Get the status history of an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StatusHistoryEntry[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdStatusHistoryGetWithHttpInfo($order_id)
    {
        $request = $this->restOrdersOrderIdStatusHistoryGetRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\StatusHistoryEntry[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\StatusHistoryEntry[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\StatusHistoryEntry[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StatusHistoryEntry[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdStatusHistoryGetAsync
     *
     * Get the status history of an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdStatusHistoryGetAsync($order_id)
    {
        return $this->restOrdersOrderIdStatusHistoryGetAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdStatusHistoryGetAsyncWithHttpInfo
     *
     * Get the status history of an order
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdStatusHistoryGetAsyncWithHttpInfo($order_id)
    {
        $returnType = '\OpenAPI\Client\Model\StatusHistoryEntry[]';
        $request = $this->restOrdersOrderIdStatusHistoryGetRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdStatusHistoryGet'
     *
     * @param  int $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdStatusHistoryGetRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdStatusHistoryGet'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/status-history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdTransactionsPost
     *
     * Create order item transactions for an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \OpenAPI\Client\Model\InlineObject199 $_rest_orders_order_id_transactions _rest_orders_order_id_transactions (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderItemTransaction[]
     */
    public function restOrdersOrderIdTransactionsPost($order_id, $_rest_orders_order_id_transactions = null)
    {
        list($response) = $this->restOrdersOrderIdTransactionsPostWithHttpInfo($order_id, $_rest_orders_order_id_transactions);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdTransactionsPostWithHttpInfo
     *
     * Create order item transactions for an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \OpenAPI\Client\Model\InlineObject199 $_rest_orders_order_id_transactions (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderItemTransaction[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdTransactionsPostWithHttpInfo($order_id, $_rest_orders_order_id_transactions = null)
    {
        $request = $this->restOrdersOrderIdTransactionsPostRequest($order_id, $_rest_orders_order_id_transactions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderItemTransaction[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderItemTransaction[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderItemTransaction[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderItemTransaction[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdTransactionsPostAsync
     *
     * Create order item transactions for an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \OpenAPI\Client\Model\InlineObject199 $_rest_orders_order_id_transactions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdTransactionsPostAsync($order_id, $_rest_orders_order_id_transactions = null)
    {
        return $this->restOrdersOrderIdTransactionsPostAsyncWithHttpInfo($order_id, $_rest_orders_order_id_transactions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdTransactionsPostAsyncWithHttpInfo
     *
     * Create order item transactions for an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \OpenAPI\Client\Model\InlineObject199 $_rest_orders_order_id_transactions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdTransactionsPostAsyncWithHttpInfo($order_id, $_rest_orders_order_id_transactions = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderItemTransaction[]';
        $request = $this->restOrdersOrderIdTransactionsPostRequest($order_id, $_rest_orders_order_id_transactions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdTransactionsPost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \OpenAPI\Client\Model\InlineObject199 $_rest_orders_order_id_transactions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdTransactionsPostRequest($order_id, $_rest_orders_order_id_transactions = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdTransactionsPost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_orders_order_id_transactions)) {
            $_tempBody = $_rest_orders_order_id_transactions;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersPost
     *
     * Create an order
     *
     * @param  int $coupon One or multiple coupon code to be redeemed with order creation (optional)
     * @param  \OpenAPI\Client\Model\InlineObject168 $_rest_orders _rest_orders (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Order
     */
    public function restOrdersPost($coupon = null, $_rest_orders = null)
    {
        list($response) = $this->restOrdersPostWithHttpInfo($coupon, $_rest_orders);
        return $response;
    }

    /**
     * Operation restOrdersPostWithHttpInfo
     *
     * Create an order
     *
     * @param  int $coupon One or multiple coupon code to be redeemed with order creation (optional)
     * @param  \OpenAPI\Client\Model\InlineObject168 $_rest_orders (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersPostWithHttpInfo($coupon = null, $_rest_orders = null)
    {
        $request = $this->restOrdersPostRequest($coupon, $_rest_orders);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Order' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Order';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersPostAsync
     *
     * Create an order
     *
     * @param  int $coupon One or multiple coupon code to be redeemed with order creation (optional)
     * @param  \OpenAPI\Client\Model\InlineObject168 $_rest_orders (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersPostAsync($coupon = null, $_rest_orders = null)
    {
        return $this->restOrdersPostAsyncWithHttpInfo($coupon, $_rest_orders)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersPostAsyncWithHttpInfo
     *
     * Create an order
     *
     * @param  int $coupon One or multiple coupon code to be redeemed with order creation (optional)
     * @param  \OpenAPI\Client\Model\InlineObject168 $_rest_orders (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersPostAsyncWithHttpInfo($coupon = null, $_rest_orders = null)
    {
        $returnType = '\OpenAPI\Client\Model\Order';
        $request = $this->restOrdersPostRequest($coupon, $_rest_orders);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersPost'
     *
     * @param  int $coupon One or multiple coupon code to be redeemed with order creation (optional)
     * @param  \OpenAPI\Client\Model\InlineObject168 $_rest_orders (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersPostRequest($coupon = null, $_rest_orders = null)
    {

        $resourcePath = '/rest/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($coupon)) {
            $coupon = ObjectSerializer::serializeCollection($coupon, '', true);
        }
        if ($coupon !== null) {
            $queryParams['coupon'] = $coupon;
        }



        // body params
        $_tempBody = null;
        if (isset($_rest_orders)) {
            $_tempBody = $_rest_orders;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersPropertiesIdDelete
     *
     * Delete property of an order by property ID
     *
     * @param  int $id The ID of the property to be deleted. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersPropertiesIdDelete($id)
    {
        list($response) = $this->restOrdersPropertiesIdDeleteWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restOrdersPropertiesIdDeleteWithHttpInfo
     *
     * Delete property of an order by property ID
     *
     * @param  int $id The ID of the property to be deleted. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersPropertiesIdDeleteWithHttpInfo($id)
    {
        $request = $this->restOrdersPropertiesIdDeleteRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersPropertiesIdDeleteAsync
     *
     * Delete property of an order by property ID
     *
     * @param  int $id The ID of the property to be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersPropertiesIdDeleteAsync($id)
    {
        return $this->restOrdersPropertiesIdDeleteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersPropertiesIdDeleteAsyncWithHttpInfo
     *
     * Delete property of an order by property ID
     *
     * @param  int $id The ID of the property to be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersPropertiesIdDeleteAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->restOrdersPropertiesIdDeleteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersPropertiesIdDelete'
     *
     * @param  int $id The ID of the property to be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersPropertiesIdDeleteRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restOrdersPropertiesIdDelete'
            );
        }

        $resourcePath = '/rest/orders/properties/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersPropertiesIdPut
     *
     * Update property of an order by property ID
     *
     * @param  int $id id (required)
     * @param  \OpenAPI\Client\Model\InlineObject185 $_rest_orders_properties_id _rest_orders_properties_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderProperty
     */
    public function restOrdersPropertiesIdPut($id, $_rest_orders_properties_id = null)
    {
        list($response) = $this->restOrdersPropertiesIdPutWithHttpInfo($id, $_rest_orders_properties_id);
        return $response;
    }

    /**
     * Operation restOrdersPropertiesIdPutWithHttpInfo
     *
     * Update property of an order by property ID
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\InlineObject185 $_rest_orders_properties_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderProperty, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersPropertiesIdPutWithHttpInfo($id, $_rest_orders_properties_id = null)
    {
        $request = $this->restOrdersPropertiesIdPutRequest($id, $_rest_orders_properties_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderProperty' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderProperty', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderProperty';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderProperty',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersPropertiesIdPutAsync
     *
     * Update property of an order by property ID
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\InlineObject185 $_rest_orders_properties_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersPropertiesIdPutAsync($id, $_rest_orders_properties_id = null)
    {
        return $this->restOrdersPropertiesIdPutAsyncWithHttpInfo($id, $_rest_orders_properties_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersPropertiesIdPutAsyncWithHttpInfo
     *
     * Update property of an order by property ID
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\InlineObject185 $_rest_orders_properties_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersPropertiesIdPutAsyncWithHttpInfo($id, $_rest_orders_properties_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderProperty';
        $request = $this->restOrdersPropertiesIdPutRequest($id, $_rest_orders_properties_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersPropertiesIdPut'
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\InlineObject185 $_rest_orders_properties_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersPropertiesIdPutRequest($id, $_rest_orders_properties_id = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restOrdersPropertiesIdPut'
            );
        }

        $resourcePath = '/rest/orders/properties/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_orders_properties_id)) {
            $_tempBody = $_rest_orders_properties_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersPropertiesTypesGet
     *
     * List order property types
     *
     * @param  int $lang If no parameter is set here, all languages are loaded by default. Optionally, enter an arry containing the ISO codes of the desired languages. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderPropertyType[]
     */
    public function restOrdersPropertiesTypesGet($lang = null)
    {
        list($response) = $this->restOrdersPropertiesTypesGetWithHttpInfo($lang);
        return $response;
    }

    /**
     * Operation restOrdersPropertiesTypesGetWithHttpInfo
     *
     * List order property types
     *
     * @param  int $lang If no parameter is set here, all languages are loaded by default. Optionally, enter an arry containing the ISO codes of the desired languages. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderPropertyType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersPropertiesTypesGetWithHttpInfo($lang = null)
    {
        $request = $this->restOrdersPropertiesTypesGetRequest($lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderPropertyType[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderPropertyType[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderPropertyType[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderPropertyType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersPropertiesTypesGetAsync
     *
     * List order property types
     *
     * @param  int $lang If no parameter is set here, all languages are loaded by default. Optionally, enter an arry containing the ISO codes of the desired languages. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersPropertiesTypesGetAsync($lang = null)
    {
        return $this->restOrdersPropertiesTypesGetAsyncWithHttpInfo($lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersPropertiesTypesGetAsyncWithHttpInfo
     *
     * List order property types
     *
     * @param  int $lang If no parameter is set here, all languages are loaded by default. Optionally, enter an arry containing the ISO codes of the desired languages. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersPropertiesTypesGetAsyncWithHttpInfo($lang = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderPropertyType[]';
        $request = $this->restOrdersPropertiesTypesGetRequest($lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersPropertiesTypesGet'
     *
     * @param  int $lang If no parameter is set here, all languages are loaded by default. Optionally, enter an arry containing the ISO codes of the desired languages. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersPropertiesTypesGetRequest($lang = null)
    {

        $resourcePath = '/rest/orders/properties/types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($lang)) {
            $lang = ObjectSerializer::serializeCollection($lang, '', true);
        }
        if ($lang !== null) {
            $queryParams['lang'] = $lang;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersPropertiesTypesPost
     *
     * Create order property type
     *
     * @param  \OpenAPI\Client\Model\InlineObject183 $_rest_orders_properties_types _rest_orders_properties_types (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderPropertyType
     */
    public function restOrdersPropertiesTypesPost($_rest_orders_properties_types = null)
    {
        list($response) = $this->restOrdersPropertiesTypesPostWithHttpInfo($_rest_orders_properties_types);
        return $response;
    }

    /**
     * Operation restOrdersPropertiesTypesPostWithHttpInfo
     *
     * Create order property type
     *
     * @param  \OpenAPI\Client\Model\InlineObject183 $_rest_orders_properties_types (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderPropertyType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersPropertiesTypesPostWithHttpInfo($_rest_orders_properties_types = null)
    {
        $request = $this->restOrdersPropertiesTypesPostRequest($_rest_orders_properties_types);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderPropertyType' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderPropertyType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderPropertyType';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderPropertyType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersPropertiesTypesPostAsync
     *
     * Create order property type
     *
     * @param  \OpenAPI\Client\Model\InlineObject183 $_rest_orders_properties_types (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersPropertiesTypesPostAsync($_rest_orders_properties_types = null)
    {
        return $this->restOrdersPropertiesTypesPostAsyncWithHttpInfo($_rest_orders_properties_types)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersPropertiesTypesPostAsyncWithHttpInfo
     *
     * Create order property type
     *
     * @param  \OpenAPI\Client\Model\InlineObject183 $_rest_orders_properties_types (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersPropertiesTypesPostAsyncWithHttpInfo($_rest_orders_properties_types = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderPropertyType';
        $request = $this->restOrdersPropertiesTypesPostRequest($_rest_orders_properties_types);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersPropertiesTypesPost'
     *
     * @param  \OpenAPI\Client\Model\InlineObject183 $_rest_orders_properties_types (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersPropertiesTypesPostRequest($_rest_orders_properties_types = null)
    {

        $resourcePath = '/rest/orders/properties/types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_orders_properties_types)) {
            $_tempBody = $_rest_orders_properties_types;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersPropertiesTypesTypeIdDelete
     *
     * Delete property type
     *
     * @param  int $type_id The ID of the property type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restOrdersPropertiesTypesTypeIdDelete($type_id)
    {
        $this->restOrdersPropertiesTypesTypeIdDeleteWithHttpInfo($type_id);
    }

    /**
     * Operation restOrdersPropertiesTypesTypeIdDeleteWithHttpInfo
     *
     * Delete property type
     *
     * @param  int $type_id The ID of the property type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersPropertiesTypesTypeIdDeleteWithHttpInfo($type_id)
    {
        $request = $this->restOrdersPropertiesTypesTypeIdDeleteRequest($type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersPropertiesTypesTypeIdDeleteAsync
     *
     * Delete property type
     *
     * @param  int $type_id The ID of the property type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersPropertiesTypesTypeIdDeleteAsync($type_id)
    {
        return $this->restOrdersPropertiesTypesTypeIdDeleteAsyncWithHttpInfo($type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersPropertiesTypesTypeIdDeleteAsyncWithHttpInfo
     *
     * Delete property type
     *
     * @param  int $type_id The ID of the property type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersPropertiesTypesTypeIdDeleteAsyncWithHttpInfo($type_id)
    {
        $returnType = '';
        $request = $this->restOrdersPropertiesTypesTypeIdDeleteRequest($type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersPropertiesTypesTypeIdDelete'
     *
     * @param  int $type_id The ID of the property type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersPropertiesTypesTypeIdDeleteRequest($type_id)
    {
        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersPropertiesTypesTypeIdDelete'
            );
        }

        $resourcePath = '/rest/orders/properties/types/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersPropertiesTypesTypeIdGet
     *
     * Get property type
     *
     * @param  int $type_id The ID of the type. (required)
     * @param  int $lang If no parameter is set here, all languages for the property are loaded by default. Optionally, enter an arry containing the ISO codes of the desired languages. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderPropertyType
     */
    public function restOrdersPropertiesTypesTypeIdGet($type_id, $lang = null)
    {
        list($response) = $this->restOrdersPropertiesTypesTypeIdGetWithHttpInfo($type_id, $lang);
        return $response;
    }

    /**
     * Operation restOrdersPropertiesTypesTypeIdGetWithHttpInfo
     *
     * Get property type
     *
     * @param  int $type_id The ID of the type. (required)
     * @param  int $lang If no parameter is set here, all languages for the property are loaded by default. Optionally, enter an arry containing the ISO codes of the desired languages. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderPropertyType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersPropertiesTypesTypeIdGetWithHttpInfo($type_id, $lang = null)
    {
        $request = $this->restOrdersPropertiesTypesTypeIdGetRequest($type_id, $lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderPropertyType' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderPropertyType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderPropertyType';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderPropertyType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersPropertiesTypesTypeIdGetAsync
     *
     * Get property type
     *
     * @param  int $type_id The ID of the type. (required)
     * @param  int $lang If no parameter is set here, all languages for the property are loaded by default. Optionally, enter an arry containing the ISO codes of the desired languages. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersPropertiesTypesTypeIdGetAsync($type_id, $lang = null)
    {
        return $this->restOrdersPropertiesTypesTypeIdGetAsyncWithHttpInfo($type_id, $lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersPropertiesTypesTypeIdGetAsyncWithHttpInfo
     *
     * Get property type
     *
     * @param  int $type_id The ID of the type. (required)
     * @param  int $lang If no parameter is set here, all languages for the property are loaded by default. Optionally, enter an arry containing the ISO codes of the desired languages. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersPropertiesTypesTypeIdGetAsyncWithHttpInfo($type_id, $lang = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderPropertyType';
        $request = $this->restOrdersPropertiesTypesTypeIdGetRequest($type_id, $lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersPropertiesTypesTypeIdGet'
     *
     * @param  int $type_id The ID of the type. (required)
     * @param  int $lang If no parameter is set here, all languages for the property are loaded by default. Optionally, enter an arry containing the ISO codes of the desired languages. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersPropertiesTypesTypeIdGetRequest($type_id, $lang = null)
    {
        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersPropertiesTypesTypeIdGet'
            );
        }

        $resourcePath = '/rest/orders/properties/types/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($lang)) {
            $lang = ObjectSerializer::serializeCollection($lang, '', true);
        }
        if ($lang !== null) {
            $queryParams['lang'] = $lang;
        }


        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersPropertiesTypesTypeIdPut
     *
     * Update property type
     *
     * @param  int $type_id type_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject184 $_rest_orders_properties_types_type_id _rest_orders_properties_types_type_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderPropertyType
     */
    public function restOrdersPropertiesTypesTypeIdPut($type_id, $_rest_orders_properties_types_type_id = null)
    {
        list($response) = $this->restOrdersPropertiesTypesTypeIdPutWithHttpInfo($type_id, $_rest_orders_properties_types_type_id);
        return $response;
    }

    /**
     * Operation restOrdersPropertiesTypesTypeIdPutWithHttpInfo
     *
     * Update property type
     *
     * @param  int $type_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject184 $_rest_orders_properties_types_type_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderPropertyType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersPropertiesTypesTypeIdPutWithHttpInfo($type_id, $_rest_orders_properties_types_type_id = null)
    {
        $request = $this->restOrdersPropertiesTypesTypeIdPutRequest($type_id, $_rest_orders_properties_types_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderPropertyType' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderPropertyType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderPropertyType';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderPropertyType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersPropertiesTypesTypeIdPutAsync
     *
     * Update property type
     *
     * @param  int $type_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject184 $_rest_orders_properties_types_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersPropertiesTypesTypeIdPutAsync($type_id, $_rest_orders_properties_types_type_id = null)
    {
        return $this->restOrdersPropertiesTypesTypeIdPutAsyncWithHttpInfo($type_id, $_rest_orders_properties_types_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersPropertiesTypesTypeIdPutAsyncWithHttpInfo
     *
     * Update property type
     *
     * @param  int $type_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject184 $_rest_orders_properties_types_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersPropertiesTypesTypeIdPutAsyncWithHttpInfo($type_id, $_rest_orders_properties_types_type_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderPropertyType';
        $request = $this->restOrdersPropertiesTypesTypeIdPutRequest($type_id, $_rest_orders_properties_types_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersPropertiesTypesTypeIdPut'
     *
     * @param  int $type_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject184 $_rest_orders_properties_types_type_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersPropertiesTypesTypeIdPutRequest($type_id, $_rest_orders_properties_types_type_id = null)
    {
        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersPropertiesTypesTypeIdPut'
            );
        }

        $resourcePath = '/rest/orders/properties/types/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_orders_properties_types_type_id)) {
            $_tempBody = $_rest_orders_properties_types_type_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersReferrersGet
     *
     * List referrers
     *
     * @param  int $columns The desired columns/attributes of the order referrer to be loaded. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderReferrer[]
     */
    public function restOrdersReferrersGet($columns = null)
    {
        list($response) = $this->restOrdersReferrersGetWithHttpInfo($columns);
        return $response;
    }

    /**
     * Operation restOrdersReferrersGetWithHttpInfo
     *
     * List referrers
     *
     * @param  int $columns The desired columns/attributes of the order referrer to be loaded. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderReferrer[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersReferrersGetWithHttpInfo($columns = null)
    {
        $request = $this->restOrdersReferrersGetRequest($columns);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderReferrer[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderReferrer[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderReferrer[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderReferrer[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersReferrersGetAsync
     *
     * List referrers
     *
     * @param  int $columns The desired columns/attributes of the order referrer to be loaded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersReferrersGetAsync($columns = null)
    {
        return $this->restOrdersReferrersGetAsyncWithHttpInfo($columns)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersReferrersGetAsyncWithHttpInfo
     *
     * List referrers
     *
     * @param  int $columns The desired columns/attributes of the order referrer to be loaded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersReferrersGetAsyncWithHttpInfo($columns = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderReferrer[]';
        $request = $this->restOrdersReferrersGetRequest($columns);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersReferrersGet'
     *
     * @param  int $columns The desired columns/attributes of the order referrer to be loaded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersReferrersGetRequest($columns = null)
    {

        $resourcePath = '/rest/orders/referrers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($columns)) {
            $columns = ObjectSerializer::serializeCollection($columns, '', true);
        }
        if ($columns !== null) {
            $queryParams['columns'] = $columns;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingCountriesGet
     *
     * List shipping countries
     *
     * @param  int $active Returns only the active shipping countries. (optional)
     * @param  int $with The relations to be loaded. Possible values are &#39;states&#39; and &#39;names&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersShippingCountriesGet($active = null, $with = null)
    {
        list($response) = $this->restOrdersShippingCountriesGetWithHttpInfo($active, $with);
        return $response;
    }

    /**
     * Operation restOrdersShippingCountriesGetWithHttpInfo
     *
     * List shipping countries
     *
     * @param  int $active Returns only the active shipping countries. (optional)
     * @param  int $with The relations to be loaded. Possible values are &#39;states&#39; and &#39;names&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingCountriesGetWithHttpInfo($active = null, $with = null)
    {
        $request = $this->restOrdersShippingCountriesGetRequest($active, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingCountriesGetAsync
     *
     * List shipping countries
     *
     * @param  int $active Returns only the active shipping countries. (optional)
     * @param  int $with The relations to be loaded. Possible values are &#39;states&#39; and &#39;names&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingCountriesGetAsync($active = null, $with = null)
    {
        return $this->restOrdersShippingCountriesGetAsyncWithHttpInfo($active, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingCountriesGetAsyncWithHttpInfo
     *
     * List shipping countries
     *
     * @param  int $active Returns only the active shipping countries. (optional)
     * @param  int $with The relations to be loaded. Possible values are &#39;states&#39; and &#39;names&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingCountriesGetAsyncWithHttpInfo($active = null, $with = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersShippingCountriesGetRequest($active, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingCountriesGet'
     *
     * @param  int $active Returns only the active shipping countries. (optional)
     * @param  int $with The relations to be loaded. Possible values are &#39;states&#39; and &#39;names&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingCountriesGetRequest($active = null, $with = null)
    {

        $resourcePath = '/rest/orders/shipping/countries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($active)) {
            $active = ObjectSerializer::serializeCollection($active, '', true);
        }
        if ($active !== null) {
            $queryParams['active'] = $active;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPackageTypesGet
     *
     * List shipping package types
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ShippingPackageType[]
     */
    public function restOrdersShippingPackageTypesGet()
    {
        list($response) = $this->restOrdersShippingPackageTypesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restOrdersShippingPackageTypesGetWithHttpInfo
     *
     * List shipping package types
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ShippingPackageType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPackageTypesGetWithHttpInfo()
    {
        $request = $this->restOrdersShippingPackageTypesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ShippingPackageType[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ShippingPackageType[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ShippingPackageType[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ShippingPackageType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPackageTypesGetAsync
     *
     * List shipping package types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPackageTypesGetAsync()
    {
        return $this->restOrdersShippingPackageTypesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPackageTypesGetAsyncWithHttpInfo
     *
     * List shipping package types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPackageTypesGetAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\ShippingPackageType[]';
        $request = $this->restOrdersShippingPackageTypesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPackageTypesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingPackageTypesGetRequest()
    {

        $resourcePath = '/rest/orders/shipping/package_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPackageTypesShippingPackageTypeIdGet
     *
     * Get a shipping package type
     *
     * @param  int $shipping_package_type_id The ID of the shipping package type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ShippingPackageType
     */
    public function restOrdersShippingPackageTypesShippingPackageTypeIdGet($shipping_package_type_id)
    {
        list($response) = $this->restOrdersShippingPackageTypesShippingPackageTypeIdGetWithHttpInfo($shipping_package_type_id);
        return $response;
    }

    /**
     * Operation restOrdersShippingPackageTypesShippingPackageTypeIdGetWithHttpInfo
     *
     * Get a shipping package type
     *
     * @param  int $shipping_package_type_id The ID of the shipping package type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ShippingPackageType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPackageTypesShippingPackageTypeIdGetWithHttpInfo($shipping_package_type_id)
    {
        $request = $this->restOrdersShippingPackageTypesShippingPackageTypeIdGetRequest($shipping_package_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ShippingPackageType' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ShippingPackageType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ShippingPackageType';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ShippingPackageType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPackageTypesShippingPackageTypeIdGetAsync
     *
     * Get a shipping package type
     *
     * @param  int $shipping_package_type_id The ID of the shipping package type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPackageTypesShippingPackageTypeIdGetAsync($shipping_package_type_id)
    {
        return $this->restOrdersShippingPackageTypesShippingPackageTypeIdGetAsyncWithHttpInfo($shipping_package_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPackageTypesShippingPackageTypeIdGetAsyncWithHttpInfo
     *
     * Get a shipping package type
     *
     * @param  int $shipping_package_type_id The ID of the shipping package type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPackageTypesShippingPackageTypeIdGetAsyncWithHttpInfo($shipping_package_type_id)
    {
        $returnType = '\OpenAPI\Client\Model\ShippingPackageType';
        $request = $this->restOrdersShippingPackageTypesShippingPackageTypeIdGetRequest($shipping_package_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPackageTypesShippingPackageTypeIdGet'
     *
     * @param  int $shipping_package_type_id The ID of the shipping package type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingPackageTypesShippingPackageTypeIdGetRequest($shipping_package_type_id)
    {
        // verify the required parameter 'shipping_package_type_id' is set
        if ($shipping_package_type_id === null || (is_array($shipping_package_type_id) && count($shipping_package_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipping_package_type_id when calling restOrdersShippingPackageTypesShippingPackageTypeIdGet'
            );
        }

        $resourcePath = '/rest/orders/shipping/package_types/{shippingPackageTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($shipping_package_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'shippingPackageTypeId' . '}',
                ObjectSerializer::toPathValue($shipping_package_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPackagesItemsIdDelete
     *
     * Delete package, variation or quantity for an order
     *
     * @param  int $id The ID of the order package item variation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersShippingPackagesItemsIdDelete($id)
    {
        list($response) = $this->restOrdersShippingPackagesItemsIdDeleteWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restOrdersShippingPackagesItemsIdDeleteWithHttpInfo
     *
     * Delete package, variation or quantity for an order
     *
     * @param  int $id The ID of the order package item variation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPackagesItemsIdDeleteWithHttpInfo($id)
    {
        $request = $this->restOrdersShippingPackagesItemsIdDeleteRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPackagesItemsIdDeleteAsync
     *
     * Delete package, variation or quantity for an order
     *
     * @param  int $id The ID of the order package item variation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPackagesItemsIdDeleteAsync($id)
    {
        return $this->restOrdersShippingPackagesItemsIdDeleteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPackagesItemsIdDeleteAsyncWithHttpInfo
     *
     * Delete package, variation or quantity for an order
     *
     * @param  int $id The ID of the order package item variation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPackagesItemsIdDeleteAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->restOrdersShippingPackagesItemsIdDeleteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPackagesItemsIdDelete'
     *
     * @param  int $id The ID of the order package item variation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingPackagesItemsIdDeleteRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restOrdersShippingPackagesItemsIdDelete'
            );
        }

        $resourcePath = '/rest/orders/shipping/packages/items/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPackagesItemsIdPut
     *
     * Update package, variation or quantity for an order
     *
     * @param  int $id The ID of the order package item variation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersShippingPackagesItemsIdPut($id)
    {
        list($response) = $this->restOrdersShippingPackagesItemsIdPutWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restOrdersShippingPackagesItemsIdPutWithHttpInfo
     *
     * Update package, variation or quantity for an order
     *
     * @param  int $id The ID of the order package item variation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPackagesItemsIdPutWithHttpInfo($id)
    {
        $request = $this->restOrdersShippingPackagesItemsIdPutRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPackagesItemsIdPutAsync
     *
     * Update package, variation or quantity for an order
     *
     * @param  int $id The ID of the order package item variation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPackagesItemsIdPutAsync($id)
    {
        return $this->restOrdersShippingPackagesItemsIdPutAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPackagesItemsIdPutAsyncWithHttpInfo
     *
     * Update package, variation or quantity for an order
     *
     * @param  int $id The ID of the order package item variation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPackagesItemsIdPutAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->restOrdersShippingPackagesItemsIdPutRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPackagesItemsIdPut'
     *
     * @param  int $id The ID of the order package item variation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingPackagesItemsIdPutRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restOrdersShippingPackagesItemsIdPut'
            );
        }

        $resourcePath = '/rest/orders/shipping/packages/items/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDelete
     *
     * Delete items of an order package
     *
     * @param  int $package_id The ID of the package (required)
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDelete($package_id, $item_id, $variation_id)
    {
        list($response) = $this->restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDeleteWithHttpInfo($package_id, $item_id, $variation_id);
        return $response;
    }

    /**
     * Operation restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDeleteWithHttpInfo
     *
     * Delete items of an order package
     *
     * @param  int $package_id The ID of the package (required)
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDeleteWithHttpInfo($package_id, $item_id, $variation_id)
    {
        $request = $this->restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDeleteRequest($package_id, $item_id, $variation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDeleteAsync
     *
     * Delete items of an order package
     *
     * @param  int $package_id The ID of the package (required)
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDeleteAsync($package_id, $item_id, $variation_id)
    {
        return $this->restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDeleteAsyncWithHttpInfo($package_id, $item_id, $variation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDeleteAsyncWithHttpInfo
     *
     * Delete items of an order package
     *
     * @param  int $package_id The ID of the package (required)
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDeleteAsyncWithHttpInfo($package_id, $item_id, $variation_id)
    {
        $returnType = 'object';
        $request = $this->restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDeleteRequest($package_id, $item_id, $variation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDelete'
     *
     * @param  int $package_id The ID of the package (required)
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDeleteRequest($package_id, $item_id, $variation_id)
    {
        // verify the required parameter 'package_id' is set
        if ($package_id === null || (is_array($package_id) && count($package_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $package_id when calling restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDelete'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDelete'
            );
        }
        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDelete'
            );
        }

        $resourcePath = '/rest/orders/shipping/packages/items/{packageId}/{itemId}/{variationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($package_id !== null) {
            $resourcePath = str_replace(
                '{' . 'packageId' . '}',
                ObjectSerializer::toPathValue($package_id),
                $resourcePath
            );
        }
        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPut
     *
     * Update items of an order package
     *
     * @param  int $package_id The ID of the package (required)
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPut($package_id, $item_id, $variation_id)
    {
        list($response) = $this->restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPutWithHttpInfo($package_id, $item_id, $variation_id);
        return $response;
    }

    /**
     * Operation restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPutWithHttpInfo
     *
     * Update items of an order package
     *
     * @param  int $package_id The ID of the package (required)
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPutWithHttpInfo($package_id, $item_id, $variation_id)
    {
        $request = $this->restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPutRequest($package_id, $item_id, $variation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPutAsync
     *
     * Update items of an order package
     *
     * @param  int $package_id The ID of the package (required)
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPutAsync($package_id, $item_id, $variation_id)
    {
        return $this->restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPutAsyncWithHttpInfo($package_id, $item_id, $variation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPutAsyncWithHttpInfo
     *
     * Update items of an order package
     *
     * @param  int $package_id The ID of the package (required)
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPutAsyncWithHttpInfo($package_id, $item_id, $variation_id)
    {
        $returnType = 'object';
        $request = $this->restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPutRequest($package_id, $item_id, $variation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPut'
     *
     * @param  int $package_id The ID of the package (required)
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPutRequest($package_id, $item_id, $variation_id)
    {
        // verify the required parameter 'package_id' is set
        if ($package_id === null || (is_array($package_id) && count($package_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $package_id when calling restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPut'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPut'
            );
        }
        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPut'
            );
        }

        $resourcePath = '/rest/orders/shipping/packages/items/{packageId}/{itemId}/{variationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($package_id !== null) {
            $resourcePath = str_replace(
                '{' . 'packageId' . '}',
                ObjectSerializer::toPathValue($package_id),
                $resourcePath
            );
        }
        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPackagesPackageIdItemsGet
     *
     * List items of an order package
     *
     * @param  int $package_id The ID of the order package (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderShippingPackageItems
     */
    public function restOrdersShippingPackagesPackageIdItemsGet($package_id)
    {
        list($response) = $this->restOrdersShippingPackagesPackageIdItemsGetWithHttpInfo($package_id);
        return $response;
    }

    /**
     * Operation restOrdersShippingPackagesPackageIdItemsGetWithHttpInfo
     *
     * List items of an order package
     *
     * @param  int $package_id The ID of the order package (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderShippingPackageItems, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPackagesPackageIdItemsGetWithHttpInfo($package_id)
    {
        $request = $this->restOrdersShippingPackagesPackageIdItemsGetRequest($package_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderShippingPackageItems' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderShippingPackageItems', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderShippingPackageItems';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderShippingPackageItems',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPackagesPackageIdItemsGetAsync
     *
     * List items of an order package
     *
     * @param  int $package_id The ID of the order package (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPackagesPackageIdItemsGetAsync($package_id)
    {
        return $this->restOrdersShippingPackagesPackageIdItemsGetAsyncWithHttpInfo($package_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPackagesPackageIdItemsGetAsyncWithHttpInfo
     *
     * List items of an order package
     *
     * @param  int $package_id The ID of the order package (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPackagesPackageIdItemsGetAsyncWithHttpInfo($package_id)
    {
        $returnType = '\OpenAPI\Client\Model\OrderShippingPackageItems';
        $request = $this->restOrdersShippingPackagesPackageIdItemsGetRequest($package_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPackagesPackageIdItemsGet'
     *
     * @param  int $package_id The ID of the order package (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingPackagesPackageIdItemsGetRequest($package_id)
    {
        // verify the required parameter 'package_id' is set
        if ($package_id === null || (is_array($package_id) && count($package_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $package_id when calling restOrdersShippingPackagesPackageIdItemsGet'
            );
        }

        $resourcePath = '/rest/orders/shipping/packages/{packageId}/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($package_id !== null) {
            $resourcePath = str_replace(
                '{' . 'packageId' . '}',
                ObjectSerializer::toPathValue($package_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPackagesPackageIdItemsPost
     *
     * Create package, variation or quantity for an order
     *
     * @param  int $package_id The ID of the order package (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function restOrdersShippingPackagesPackageIdItemsPost($package_id)
    {
        list($response) = $this->restOrdersShippingPackagesPackageIdItemsPostWithHttpInfo($package_id);
        return $response;
    }

    /**
     * Operation restOrdersShippingPackagesPackageIdItemsPostWithHttpInfo
     *
     * Create package, variation or quantity for an order
     *
     * @param  int $package_id The ID of the order package (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPackagesPackageIdItemsPostWithHttpInfo($package_id)
    {
        $request = $this->restOrdersShippingPackagesPackageIdItemsPostRequest($package_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPackagesPackageIdItemsPostAsync
     *
     * Create package, variation or quantity for an order
     *
     * @param  int $package_id The ID of the order package (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPackagesPackageIdItemsPostAsync($package_id)
    {
        return $this->restOrdersShippingPackagesPackageIdItemsPostAsyncWithHttpInfo($package_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPackagesPackageIdItemsPostAsyncWithHttpInfo
     *
     * Create package, variation or quantity for an order
     *
     * @param  int $package_id The ID of the order package (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPackagesPackageIdItemsPostAsyncWithHttpInfo($package_id)
    {
        $returnType = 'object[]';
        $request = $this->restOrdersShippingPackagesPackageIdItemsPostRequest($package_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPackagesPackageIdItemsPost'
     *
     * @param  int $package_id The ID of the order package (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingPackagesPackageIdItemsPostRequest($package_id)
    {
        // verify the required parameter 'package_id' is set
        if ($package_id === null || (is_array($package_id) && count($package_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $package_id when calling restOrdersShippingPackagesPackageIdItemsPost'
            );
        }

        $resourcePath = '/rest/orders/shipping/packages/{packageId}/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($package_id !== null) {
            $resourcePath = str_replace(
                '{' . 'packageId' . '}',
                ObjectSerializer::toPathValue($package_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPalletsGet
     *
     * List order shipping pallets
     *
     * @param  string $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderShippingPallet[]
     */
    public function restOrdersShippingPalletsGet($order_id)
    {
        list($response) = $this->restOrdersShippingPalletsGetWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restOrdersShippingPalletsGetWithHttpInfo
     *
     * List order shipping pallets
     *
     * @param  string $order_id The ID of the order (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderShippingPallet[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPalletsGetWithHttpInfo($order_id)
    {
        $request = $this->restOrdersShippingPalletsGetRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderShippingPallet[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderShippingPallet[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderShippingPallet[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderShippingPallet[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPalletsGetAsync
     *
     * List order shipping pallets
     *
     * @param  string $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPalletsGetAsync($order_id)
    {
        return $this->restOrdersShippingPalletsGetAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPalletsGetAsyncWithHttpInfo
     *
     * List order shipping pallets
     *
     * @param  string $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPalletsGetAsyncWithHttpInfo($order_id)
    {
        $returnType = '\OpenAPI\Client\Model\OrderShippingPallet[]';
        $request = $this->restOrdersShippingPalletsGetRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPalletsGet'
     *
     * @param  string $order_id The ID of the order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingPalletsGetRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersShippingPalletsGet'
            );
        }

        $resourcePath = '/rest/orders/shipping/pallets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($order_id)) {
            $order_id = ObjectSerializer::serializeCollection($order_id, '', true);
        }
        if ($order_id !== null) {
            $queryParams['orderId'] = $order_id;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPalletsPalletIdDelete
     *
     * Delete all pallets of an order
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  \OpenAPI\Client\Model\InlineObject188 $_rest_orders_shipping_pallets_pallet_id _rest_orders_shipping_pallets_pallet_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderShippingPallet
     */
    public function restOrdersShippingPalletsPalletIdDelete($pallet_id, $_rest_orders_shipping_pallets_pallet_id = null)
    {
        list($response) = $this->restOrdersShippingPalletsPalletIdDeleteWithHttpInfo($pallet_id, $_rest_orders_shipping_pallets_pallet_id);
        return $response;
    }

    /**
     * Operation restOrdersShippingPalletsPalletIdDeleteWithHttpInfo
     *
     * Delete all pallets of an order
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  \OpenAPI\Client\Model\InlineObject188 $_rest_orders_shipping_pallets_pallet_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderShippingPallet, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPalletsPalletIdDeleteWithHttpInfo($pallet_id, $_rest_orders_shipping_pallets_pallet_id = null)
    {
        $request = $this->restOrdersShippingPalletsPalletIdDeleteRequest($pallet_id, $_rest_orders_shipping_pallets_pallet_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderShippingPallet' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderShippingPallet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderShippingPallet';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderShippingPallet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPalletsPalletIdDeleteAsync
     *
     * Delete all pallets of an order
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  \OpenAPI\Client\Model\InlineObject188 $_rest_orders_shipping_pallets_pallet_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPalletsPalletIdDeleteAsync($pallet_id, $_rest_orders_shipping_pallets_pallet_id = null)
    {
        return $this->restOrdersShippingPalletsPalletIdDeleteAsyncWithHttpInfo($pallet_id, $_rest_orders_shipping_pallets_pallet_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPalletsPalletIdDeleteAsyncWithHttpInfo
     *
     * Delete all pallets of an order
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  \OpenAPI\Client\Model\InlineObject188 $_rest_orders_shipping_pallets_pallet_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPalletsPalletIdDeleteAsyncWithHttpInfo($pallet_id, $_rest_orders_shipping_pallets_pallet_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderShippingPallet';
        $request = $this->restOrdersShippingPalletsPalletIdDeleteRequest($pallet_id, $_rest_orders_shipping_pallets_pallet_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPalletsPalletIdDelete'
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  \OpenAPI\Client\Model\InlineObject188 $_rest_orders_shipping_pallets_pallet_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingPalletsPalletIdDeleteRequest($pallet_id, $_rest_orders_shipping_pallets_pallet_id = null)
    {
        // verify the required parameter 'pallet_id' is set
        if ($pallet_id === null || (is_array($pallet_id) && count($pallet_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pallet_id when calling restOrdersShippingPalletsPalletIdDelete'
            );
        }

        $resourcePath = '/rest/orders/shipping/pallets/{palletId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pallet_id !== null) {
            $resourcePath = str_replace(
                '{' . 'palletId' . '}',
                ObjectSerializer::toPathValue($pallet_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_orders_shipping_pallets_pallet_id)) {
            $_tempBody = $_rest_orders_shipping_pallets_pallet_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPalletsPalletIdGet
     *
     * List all pallets of an order
     *
     * @param  int $pallet_id The ID of the pallet (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderShippingPallet
     */
    public function restOrdersShippingPalletsPalletIdGet($pallet_id)
    {
        list($response) = $this->restOrdersShippingPalletsPalletIdGetWithHttpInfo($pallet_id);
        return $response;
    }

    /**
     * Operation restOrdersShippingPalletsPalletIdGetWithHttpInfo
     *
     * List all pallets of an order
     *
     * @param  int $pallet_id The ID of the pallet (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderShippingPallet, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPalletsPalletIdGetWithHttpInfo($pallet_id)
    {
        $request = $this->restOrdersShippingPalletsPalletIdGetRequest($pallet_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderShippingPallet' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderShippingPallet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderShippingPallet';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderShippingPallet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPalletsPalletIdGetAsync
     *
     * List all pallets of an order
     *
     * @param  int $pallet_id The ID of the pallet (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPalletsPalletIdGetAsync($pallet_id)
    {
        return $this->restOrdersShippingPalletsPalletIdGetAsyncWithHttpInfo($pallet_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPalletsPalletIdGetAsyncWithHttpInfo
     *
     * List all pallets of an order
     *
     * @param  int $pallet_id The ID of the pallet (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPalletsPalletIdGetAsyncWithHttpInfo($pallet_id)
    {
        $returnType = '\OpenAPI\Client\Model\OrderShippingPallet';
        $request = $this->restOrdersShippingPalletsPalletIdGetRequest($pallet_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPalletsPalletIdGet'
     *
     * @param  int $pallet_id The ID of the pallet (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingPalletsPalletIdGetRequest($pallet_id)
    {
        // verify the required parameter 'pallet_id' is set
        if ($pallet_id === null || (is_array($pallet_id) && count($pallet_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pallet_id when calling restOrdersShippingPalletsPalletIdGet'
            );
        }

        $resourcePath = '/rest/orders/shipping/pallets/{palletId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pallet_id !== null) {
            $resourcePath = str_replace(
                '{' . 'palletId' . '}',
                ObjectSerializer::toPathValue($pallet_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPalletsPalletIdPut
     *
     * Update all pallets of an order
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  \OpenAPI\Client\Model\InlineObject187 $_rest_orders_shipping_pallets_pallet_id _rest_orders_shipping_pallets_pallet_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderShippingPallet
     */
    public function restOrdersShippingPalletsPalletIdPut($pallet_id, $_rest_orders_shipping_pallets_pallet_id = null)
    {
        list($response) = $this->restOrdersShippingPalletsPalletIdPutWithHttpInfo($pallet_id, $_rest_orders_shipping_pallets_pallet_id);
        return $response;
    }

    /**
     * Operation restOrdersShippingPalletsPalletIdPutWithHttpInfo
     *
     * Update all pallets of an order
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  \OpenAPI\Client\Model\InlineObject187 $_rest_orders_shipping_pallets_pallet_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderShippingPallet, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPalletsPalletIdPutWithHttpInfo($pallet_id, $_rest_orders_shipping_pallets_pallet_id = null)
    {
        $request = $this->restOrdersShippingPalletsPalletIdPutRequest($pallet_id, $_rest_orders_shipping_pallets_pallet_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderShippingPallet' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderShippingPallet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderShippingPallet';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderShippingPallet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPalletsPalletIdPutAsync
     *
     * Update all pallets of an order
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  \OpenAPI\Client\Model\InlineObject187 $_rest_orders_shipping_pallets_pallet_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPalletsPalletIdPutAsync($pallet_id, $_rest_orders_shipping_pallets_pallet_id = null)
    {
        return $this->restOrdersShippingPalletsPalletIdPutAsyncWithHttpInfo($pallet_id, $_rest_orders_shipping_pallets_pallet_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPalletsPalletIdPutAsyncWithHttpInfo
     *
     * Update all pallets of an order
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  \OpenAPI\Client\Model\InlineObject187 $_rest_orders_shipping_pallets_pallet_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPalletsPalletIdPutAsyncWithHttpInfo($pallet_id, $_rest_orders_shipping_pallets_pallet_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderShippingPallet';
        $request = $this->restOrdersShippingPalletsPalletIdPutRequest($pallet_id, $_rest_orders_shipping_pallets_pallet_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPalletsPalletIdPut'
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  \OpenAPI\Client\Model\InlineObject187 $_rest_orders_shipping_pallets_pallet_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingPalletsPalletIdPutRequest($pallet_id, $_rest_orders_shipping_pallets_pallet_id = null)
    {
        // verify the required parameter 'pallet_id' is set
        if ($pallet_id === null || (is_array($pallet_id) && count($pallet_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pallet_id when calling restOrdersShippingPalletsPalletIdPut'
            );
        }

        $resourcePath = '/rest/orders/shipping/pallets/{palletId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pallet_id !== null) {
            $resourcePath = str_replace(
                '{' . 'palletId' . '}',
                ObjectSerializer::toPathValue($pallet_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_orders_shipping_pallets_pallet_id)) {
            $_tempBody = $_rest_orders_shipping_pallets_pallet_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPalletsPost
     *
     * Create order shipping pallets
     *
     * @param  \OpenAPI\Client\Model\InlineObject186 $_rest_orders_shipping_pallets _rest_orders_shipping_pallets (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderShippingPallet
     */
    public function restOrdersShippingPalletsPost($_rest_orders_shipping_pallets = null)
    {
        list($response) = $this->restOrdersShippingPalletsPostWithHttpInfo($_rest_orders_shipping_pallets);
        return $response;
    }

    /**
     * Operation restOrdersShippingPalletsPostWithHttpInfo
     *
     * Create order shipping pallets
     *
     * @param  \OpenAPI\Client\Model\InlineObject186 $_rest_orders_shipping_pallets (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderShippingPallet, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPalletsPostWithHttpInfo($_rest_orders_shipping_pallets = null)
    {
        $request = $this->restOrdersShippingPalletsPostRequest($_rest_orders_shipping_pallets);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderShippingPallet' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderShippingPallet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderShippingPallet';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderShippingPallet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPalletsPostAsync
     *
     * Create order shipping pallets
     *
     * @param  \OpenAPI\Client\Model\InlineObject186 $_rest_orders_shipping_pallets (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPalletsPostAsync($_rest_orders_shipping_pallets = null)
    {
        return $this->restOrdersShippingPalletsPostAsyncWithHttpInfo($_rest_orders_shipping_pallets)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPalletsPostAsyncWithHttpInfo
     *
     * Create order shipping pallets
     *
     * @param  \OpenAPI\Client\Model\InlineObject186 $_rest_orders_shipping_pallets (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPalletsPostAsyncWithHttpInfo($_rest_orders_shipping_pallets = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderShippingPallet';
        $request = $this->restOrdersShippingPalletsPostRequest($_rest_orders_shipping_pallets);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPalletsPost'
     *
     * @param  \OpenAPI\Client\Model\InlineObject186 $_rest_orders_shipping_pallets (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingPalletsPostRequest($_rest_orders_shipping_pallets = null)
    {

        $resourcePath = '/rest/orders/shipping/pallets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_orders_shipping_pallets)) {
            $_tempBody = $_rest_orders_shipping_pallets;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGet
     *
     * Get an  order parcel service region
     *
     * @param  int $parcel_service_region_id The ID of the parcel service region (required)
     * @param  int $columns The properties to be loaded (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ParcelServiceRegion
     */
    public function restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGet($parcel_service_region_id, $columns = null)
    {
        list($response) = $this->restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGetWithHttpInfo($parcel_service_region_id, $columns);
        return $response;
    }

    /**
     * Operation restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGetWithHttpInfo
     *
     * Get an  order parcel service region
     *
     * @param  int $parcel_service_region_id The ID of the parcel service region (required)
     * @param  int $columns The properties to be loaded (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ParcelServiceRegion, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGetWithHttpInfo($parcel_service_region_id, $columns = null)
    {
        $request = $this->restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGetRequest($parcel_service_region_id, $columns);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ParcelServiceRegion' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ParcelServiceRegion', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ParcelServiceRegion';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ParcelServiceRegion',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGetAsync
     *
     * Get an  order parcel service region
     *
     * @param  int $parcel_service_region_id The ID of the parcel service region (required)
     * @param  int $columns The properties to be loaded (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGetAsync($parcel_service_region_id, $columns = null)
    {
        return $this->restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGetAsyncWithHttpInfo($parcel_service_region_id, $columns)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGetAsyncWithHttpInfo
     *
     * Get an  order parcel service region
     *
     * @param  int $parcel_service_region_id The ID of the parcel service region (required)
     * @param  int $columns The properties to be loaded (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGetAsyncWithHttpInfo($parcel_service_region_id, $columns = null)
    {
        $returnType = '\OpenAPI\Client\Model\ParcelServiceRegion';
        $request = $this->restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGetRequest($parcel_service_region_id, $columns);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGet'
     *
     * @param  int $parcel_service_region_id The ID of the parcel service region (required)
     * @param  int $columns The properties to be loaded (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGetRequest($parcel_service_region_id, $columns = null)
    {
        // verify the required parameter 'parcel_service_region_id' is set
        if ($parcel_service_region_id === null || (is_array($parcel_service_region_id) && count($parcel_service_region_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parcel_service_region_id when calling restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGet'
            );
        }

        $resourcePath = '/rest/orders/shipping/parcel_service_regions/{parcelServiceRegionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($columns)) {
            $columns = ObjectSerializer::serializeCollection($columns, '', true);
        }
        if ($columns !== null) {
            $queryParams['columns'] = $columns;
        }


        // path params
        if ($parcel_service_region_id !== null) {
            $resourcePath = str_replace(
                '{' . 'parcelServiceRegionId' . '}',
                ObjectSerializer::toPathValue($parcel_service_region_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPresetsGet
     *
     * List shipping profiles
     *
     * @param  int $columns The attributes to be loaded in the shipping profile (optional)
     * @param  string $parcel_service_name Filter that restricts the search result to parcel service presets with a specified service name (e.g. &#39;DHL&#39; for DHL) (optional)
     * @param  string $shipping_service_provider Filter that restricts the search result to a shipping service provider (optional)
     * @param  string $with The name of an relation to the preset. The following parameter is available: parcelServiceRegion, parcelServiceRegionConstraint, parcelServicePresetNames and parcelServiceNames. (optional)
     * @param  string $updated_at_before Filter that restricts the search result to presets that were updated before a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string $updated_at_after Filter that restricts the search result to presets that were updated after a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ParcelServicePreset[]
     */
    public function restOrdersShippingPresetsGet($columns = null, $parcel_service_name = null, $shipping_service_provider = null, $with = null, $updated_at_before = null, $updated_at_after = null)
    {
        list($response) = $this->restOrdersShippingPresetsGetWithHttpInfo($columns, $parcel_service_name, $shipping_service_provider, $with, $updated_at_before, $updated_at_after);
        return $response;
    }

    /**
     * Operation restOrdersShippingPresetsGetWithHttpInfo
     *
     * List shipping profiles
     *
     * @param  int $columns The attributes to be loaded in the shipping profile (optional)
     * @param  string $parcel_service_name Filter that restricts the search result to parcel service presets with a specified service name (e.g. &#39;DHL&#39; for DHL) (optional)
     * @param  string $shipping_service_provider Filter that restricts the search result to a shipping service provider (optional)
     * @param  string $with The name of an relation to the preset. The following parameter is available: parcelServiceRegion, parcelServiceRegionConstraint, parcelServicePresetNames and parcelServiceNames. (optional)
     * @param  string $updated_at_before Filter that restricts the search result to presets that were updated before a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string $updated_at_after Filter that restricts the search result to presets that were updated after a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ParcelServicePreset[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPresetsGetWithHttpInfo($columns = null, $parcel_service_name = null, $shipping_service_provider = null, $with = null, $updated_at_before = null, $updated_at_after = null)
    {
        $request = $this->restOrdersShippingPresetsGetRequest($columns, $parcel_service_name, $shipping_service_provider, $with, $updated_at_before, $updated_at_after);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ParcelServicePreset[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ParcelServicePreset[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ParcelServicePreset[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ParcelServicePreset[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPresetsGetAsync
     *
     * List shipping profiles
     *
     * @param  int $columns The attributes to be loaded in the shipping profile (optional)
     * @param  string $parcel_service_name Filter that restricts the search result to parcel service presets with a specified service name (e.g. &#39;DHL&#39; for DHL) (optional)
     * @param  string $shipping_service_provider Filter that restricts the search result to a shipping service provider (optional)
     * @param  string $with The name of an relation to the preset. The following parameter is available: parcelServiceRegion, parcelServiceRegionConstraint, parcelServicePresetNames and parcelServiceNames. (optional)
     * @param  string $updated_at_before Filter that restricts the search result to presets that were updated before a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string $updated_at_after Filter that restricts the search result to presets that were updated after a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPresetsGetAsync($columns = null, $parcel_service_name = null, $shipping_service_provider = null, $with = null, $updated_at_before = null, $updated_at_after = null)
    {
        return $this->restOrdersShippingPresetsGetAsyncWithHttpInfo($columns, $parcel_service_name, $shipping_service_provider, $with, $updated_at_before, $updated_at_after)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPresetsGetAsyncWithHttpInfo
     *
     * List shipping profiles
     *
     * @param  int $columns The attributes to be loaded in the shipping profile (optional)
     * @param  string $parcel_service_name Filter that restricts the search result to parcel service presets with a specified service name (e.g. &#39;DHL&#39; for DHL) (optional)
     * @param  string $shipping_service_provider Filter that restricts the search result to a shipping service provider (optional)
     * @param  string $with The name of an relation to the preset. The following parameter is available: parcelServiceRegion, parcelServiceRegionConstraint, parcelServicePresetNames and parcelServiceNames. (optional)
     * @param  string $updated_at_before Filter that restricts the search result to presets that were updated before a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string $updated_at_after Filter that restricts the search result to presets that were updated after a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPresetsGetAsyncWithHttpInfo($columns = null, $parcel_service_name = null, $shipping_service_provider = null, $with = null, $updated_at_before = null, $updated_at_after = null)
    {
        $returnType = '\OpenAPI\Client\Model\ParcelServicePreset[]';
        $request = $this->restOrdersShippingPresetsGetRequest($columns, $parcel_service_name, $shipping_service_provider, $with, $updated_at_before, $updated_at_after);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPresetsGet'
     *
     * @param  int $columns The attributes to be loaded in the shipping profile (optional)
     * @param  string $parcel_service_name Filter that restricts the search result to parcel service presets with a specified service name (e.g. &#39;DHL&#39; for DHL) (optional)
     * @param  string $shipping_service_provider Filter that restricts the search result to a shipping service provider (optional)
     * @param  string $with The name of an relation to the preset. The following parameter is available: parcelServiceRegion, parcelServiceRegionConstraint, parcelServicePresetNames and parcelServiceNames. (optional)
     * @param  string $updated_at_before Filter that restricts the search result to presets that were updated before a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string $updated_at_after Filter that restricts the search result to presets that were updated after a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingPresetsGetRequest($columns = null, $parcel_service_name = null, $shipping_service_provider = null, $with = null, $updated_at_before = null, $updated_at_after = null)
    {

        $resourcePath = '/rest/orders/shipping/presets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($columns)) {
            $columns = ObjectSerializer::serializeCollection($columns, '', true);
        }
        if ($columns !== null) {
            $queryParams['columns'] = $columns;
        }
        // query params
        if (is_array($parcel_service_name)) {
            $parcel_service_name = ObjectSerializer::serializeCollection($parcel_service_name, '', true);
        }
        if ($parcel_service_name !== null) {
            $queryParams['parcelServiceName'] = $parcel_service_name;
        }
        // query params
        if (is_array($shipping_service_provider)) {
            $shipping_service_provider = ObjectSerializer::serializeCollection($shipping_service_provider, '', true);
        }
        if ($shipping_service_provider !== null) {
            $queryParams['shippingServiceProvider'] = $shipping_service_provider;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }
        // query params
        if (is_array($updated_at_before)) {
            $updated_at_before = ObjectSerializer::serializeCollection($updated_at_before, '', true);
        }
        if ($updated_at_before !== null) {
            $queryParams['updatedAtBefore'] = $updated_at_before;
        }
        // query params
        if (is_array($updated_at_after)) {
            $updated_at_after = ObjectSerializer::serializeCollection($updated_at_after, '', true);
        }
        if ($updated_at_after !== null) {
            $queryParams['updatedAtAfter'] = $updated_at_after;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPresetsPresetIdGet
     *
     * Get a shipping profile
     *
     * @param  int $preset_id The ID of the shipping profile (required)
     * @param  int $columns The attributes to be loaded in the shipping profile (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ParcelServicePreset
     */
    public function restOrdersShippingPresetsPresetIdGet($preset_id, $columns = null)
    {
        list($response) = $this->restOrdersShippingPresetsPresetIdGetWithHttpInfo($preset_id, $columns);
        return $response;
    }

    /**
     * Operation restOrdersShippingPresetsPresetIdGetWithHttpInfo
     *
     * Get a shipping profile
     *
     * @param  int $preset_id The ID of the shipping profile (required)
     * @param  int $columns The attributes to be loaded in the shipping profile (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ParcelServicePreset, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPresetsPresetIdGetWithHttpInfo($preset_id, $columns = null)
    {
        $request = $this->restOrdersShippingPresetsPresetIdGetRequest($preset_id, $columns);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ParcelServicePreset' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ParcelServicePreset', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ParcelServicePreset';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ParcelServicePreset',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPresetsPresetIdGetAsync
     *
     * Get a shipping profile
     *
     * @param  int $preset_id The ID of the shipping profile (required)
     * @param  int $columns The attributes to be loaded in the shipping profile (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPresetsPresetIdGetAsync($preset_id, $columns = null)
    {
        return $this->restOrdersShippingPresetsPresetIdGetAsyncWithHttpInfo($preset_id, $columns)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPresetsPresetIdGetAsyncWithHttpInfo
     *
     * Get a shipping profile
     *
     * @param  int $preset_id The ID of the shipping profile (required)
     * @param  int $columns The attributes to be loaded in the shipping profile (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPresetsPresetIdGetAsyncWithHttpInfo($preset_id, $columns = null)
    {
        $returnType = '\OpenAPI\Client\Model\ParcelServicePreset';
        $request = $this->restOrdersShippingPresetsPresetIdGetRequest($preset_id, $columns);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPresetsPresetIdGet'
     *
     * @param  int $preset_id The ID of the shipping profile (required)
     * @param  int $columns The attributes to be loaded in the shipping profile (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingPresetsPresetIdGetRequest($preset_id, $columns = null)
    {
        // verify the required parameter 'preset_id' is set
        if ($preset_id === null || (is_array($preset_id) && count($preset_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $preset_id when calling restOrdersShippingPresetsPresetIdGet'
            );
        }

        $resourcePath = '/rest/orders/shipping/presets/{presetId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($columns)) {
            $columns = ObjectSerializer::serializeCollection($columns, '', true);
        }
        if ($columns !== null) {
            $queryParams['columns'] = $columns;
        }


        // path params
        if ($preset_id !== null) {
            $resourcePath = str_replace(
                '{' . 'presetId' . '}',
                ObjectSerializer::toPathValue($preset_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPresetsPresetIdParcelServiceRegionsGet
     *
     * List parcel service regions by parcel service preset ID
     *
     * @param  int $preset_id The ID of the preset (required)
     * @param  int $columns The properties to be loaded (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ParcelServiceRegion[]
     */
    public function restOrdersShippingPresetsPresetIdParcelServiceRegionsGet($preset_id, $columns = null)
    {
        list($response) = $this->restOrdersShippingPresetsPresetIdParcelServiceRegionsGetWithHttpInfo($preset_id, $columns);
        return $response;
    }

    /**
     * Operation restOrdersShippingPresetsPresetIdParcelServiceRegionsGetWithHttpInfo
     *
     * List parcel service regions by parcel service preset ID
     *
     * @param  int $preset_id The ID of the preset (required)
     * @param  int $columns The properties to be loaded (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ParcelServiceRegion[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPresetsPresetIdParcelServiceRegionsGetWithHttpInfo($preset_id, $columns = null)
    {
        $request = $this->restOrdersShippingPresetsPresetIdParcelServiceRegionsGetRequest($preset_id, $columns);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ParcelServiceRegion[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ParcelServiceRegion[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ParcelServiceRegion[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ParcelServiceRegion[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPresetsPresetIdParcelServiceRegionsGetAsync
     *
     * List parcel service regions by parcel service preset ID
     *
     * @param  int $preset_id The ID of the preset (required)
     * @param  int $columns The properties to be loaded (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPresetsPresetIdParcelServiceRegionsGetAsync($preset_id, $columns = null)
    {
        return $this->restOrdersShippingPresetsPresetIdParcelServiceRegionsGetAsyncWithHttpInfo($preset_id, $columns)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPresetsPresetIdParcelServiceRegionsGetAsyncWithHttpInfo
     *
     * List parcel service regions by parcel service preset ID
     *
     * @param  int $preset_id The ID of the preset (required)
     * @param  int $columns The properties to be loaded (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingPresetsPresetIdParcelServiceRegionsGetAsyncWithHttpInfo($preset_id, $columns = null)
    {
        $returnType = '\OpenAPI\Client\Model\ParcelServiceRegion[]';
        $request = $this->restOrdersShippingPresetsPresetIdParcelServiceRegionsGetRequest($preset_id, $columns);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPresetsPresetIdParcelServiceRegionsGet'
     *
     * @param  int $preset_id The ID of the preset (required)
     * @param  int $columns The properties to be loaded (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingPresetsPresetIdParcelServiceRegionsGetRequest($preset_id, $columns = null)
    {
        // verify the required parameter 'preset_id' is set
        if ($preset_id === null || (is_array($preset_id) && count($preset_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $preset_id when calling restOrdersShippingPresetsPresetIdParcelServiceRegionsGet'
            );
        }

        $resourcePath = '/rest/orders/shipping/presets/{presetId}/parcel_service_regions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($columns)) {
            $columns = ObjectSerializer::serializeCollection($columns, '', true);
        }
        if ($columns !== null) {
            $queryParams['columns'] = $columns;
        }


        // path params
        if ($preset_id !== null) {
            $resourcePath = str_replace(
                '{' . 'presetId' . '}',
                ObjectSerializer::toPathValue($preset_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingReturnsReturnsServiceProvidersGet
     *
     * List returns service providers
     *
     * @param  int $is_plugin Possible values are 1 (true) and 0 (false). (optional)
     * @param  int $plugin_id The ID of the plugin (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20039
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersGet($is_plugin = null, $plugin_id = null)
    {
        list($response) = $this->restOrdersShippingReturnsReturnsServiceProvidersGetWithHttpInfo($is_plugin, $plugin_id);
        return $response;
    }

    /**
     * Operation restOrdersShippingReturnsReturnsServiceProvidersGetWithHttpInfo
     *
     * List returns service providers
     *
     * @param  int $is_plugin Possible values are 1 (true) and 0 (false). (optional)
     * @param  int $plugin_id The ID of the plugin (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20039, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersGetWithHttpInfo($is_plugin = null, $plugin_id = null)
    {
        $request = $this->restOrdersShippingReturnsReturnsServiceProvidersGetRequest($is_plugin, $plugin_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20039' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20039', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20039';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20039',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingReturnsReturnsServiceProvidersGetAsync
     *
     * List returns service providers
     *
     * @param  int $is_plugin Possible values are 1 (true) and 0 (false). (optional)
     * @param  int $plugin_id The ID of the plugin (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersGetAsync($is_plugin = null, $plugin_id = null)
    {
        return $this->restOrdersShippingReturnsReturnsServiceProvidersGetAsyncWithHttpInfo($is_plugin, $plugin_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingReturnsReturnsServiceProvidersGetAsyncWithHttpInfo
     *
     * List returns service providers
     *
     * @param  int $is_plugin Possible values are 1 (true) and 0 (false). (optional)
     * @param  int $plugin_id The ID of the plugin (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersGetAsyncWithHttpInfo($is_plugin = null, $plugin_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20039';
        $request = $this->restOrdersShippingReturnsReturnsServiceProvidersGetRequest($is_plugin, $plugin_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingReturnsReturnsServiceProvidersGet'
     *
     * @param  int $is_plugin Possible values are 1 (true) and 0 (false). (optional)
     * @param  int $plugin_id The ID of the plugin (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingReturnsReturnsServiceProvidersGetRequest($is_plugin = null, $plugin_id = null)
    {

        $resourcePath = '/rest/orders/shipping/returns/returns_service_providers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($is_plugin)) {
            $is_plugin = ObjectSerializer::serializeCollection($is_plugin, '', true);
        }
        if ($is_plugin !== null) {
            $queryParams['isPlugin'] = $is_plugin;
        }
        // query params
        if (is_array($plugin_id)) {
            $plugin_id = ObjectSerializer::serializeCollection($plugin_id, '', true);
        }
        if ($plugin_id !== null) {
            $queryParams['pluginId'] = $plugin_id;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingReturnsReturnsServiceProvidersPluginsGet
     *
     * List returns service provider plugins
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersPluginsGet()
    {
        list($response) = $this->restOrdersShippingReturnsReturnsServiceProvidersPluginsGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restOrdersShippingReturnsReturnsServiceProvidersPluginsGetWithHttpInfo
     *
     * List returns service provider plugins
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersPluginsGetWithHttpInfo()
    {
        $request = $this->restOrdersShippingReturnsReturnsServiceProvidersPluginsGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingReturnsReturnsServiceProvidersPluginsGetAsync
     *
     * List returns service provider plugins
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersPluginsGetAsync()
    {
        return $this->restOrdersShippingReturnsReturnsServiceProvidersPluginsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingReturnsReturnsServiceProvidersPluginsGetAsyncWithHttpInfo
     *
     * List returns service provider plugins
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersPluginsGetAsyncWithHttpInfo()
    {
        $returnType = 'object[]';
        $request = $this->restOrdersShippingReturnsReturnsServiceProvidersPluginsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingReturnsReturnsServiceProvidersPluginsGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingReturnsReturnsServiceProvidersPluginsGetRequest()
    {

        $resourcePath = '/rest/orders/shipping/returns/returns_service_providers/plugins';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingReturnsReturnsServiceProvidersProviderIdGet
     *
     * Get returns service provider by the ID
     *
     * @param  int $provider_id The ID of the returns service provider (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ReturnsServiceProvider
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersProviderIdGet($provider_id)
    {
        list($response) = $this->restOrdersShippingReturnsReturnsServiceProvidersProviderIdGetWithHttpInfo($provider_id);
        return $response;
    }

    /**
     * Operation restOrdersShippingReturnsReturnsServiceProvidersProviderIdGetWithHttpInfo
     *
     * Get returns service provider by the ID
     *
     * @param  int $provider_id The ID of the returns service provider (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ReturnsServiceProvider, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersProviderIdGetWithHttpInfo($provider_id)
    {
        $request = $this->restOrdersShippingReturnsReturnsServiceProvidersProviderIdGetRequest($provider_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ReturnsServiceProvider' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ReturnsServiceProvider', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ReturnsServiceProvider';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ReturnsServiceProvider',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingReturnsReturnsServiceProvidersProviderIdGetAsync
     *
     * Get returns service provider by the ID
     *
     * @param  int $provider_id The ID of the returns service provider (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersProviderIdGetAsync($provider_id)
    {
        return $this->restOrdersShippingReturnsReturnsServiceProvidersProviderIdGetAsyncWithHttpInfo($provider_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingReturnsReturnsServiceProvidersProviderIdGetAsyncWithHttpInfo
     *
     * Get returns service provider by the ID
     *
     * @param  int $provider_id The ID of the returns service provider (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersProviderIdGetAsyncWithHttpInfo($provider_id)
    {
        $returnType = '\OpenAPI\Client\Model\ReturnsServiceProvider';
        $request = $this->restOrdersShippingReturnsReturnsServiceProvidersProviderIdGetRequest($provider_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingReturnsReturnsServiceProvidersProviderIdGet'
     *
     * @param  int $provider_id The ID of the returns service provider (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingReturnsReturnsServiceProvidersProviderIdGetRequest($provider_id)
    {
        // verify the required parameter 'provider_id' is set
        if ($provider_id === null || (is_array($provider_id) && count($provider_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $provider_id when calling restOrdersShippingReturnsReturnsServiceProvidersProviderIdGet'
            );
        }

        $resourcePath = '/rest/orders/shipping/returns/returns_service_providers/{providerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($provider_id !== null) {
            $resourcePath = str_replace(
                '{' . 'providerId' . '}',
                ObjectSerializer::toPathValue($provider_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingShippingInformationGet
     *
     * List orders with shipping information
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function restOrdersShippingShippingInformationGet()
    {
        list($response) = $this->restOrdersShippingShippingInformationGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restOrdersShippingShippingInformationGetWithHttpInfo
     *
     * List orders with shipping information
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingShippingInformationGetWithHttpInfo()
    {
        $request = $this->restOrdersShippingShippingInformationGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingShippingInformationGetAsync
     *
     * List orders with shipping information
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingShippingInformationGetAsync()
    {
        return $this->restOrdersShippingShippingInformationGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingShippingInformationGetAsyncWithHttpInfo
     *
     * List orders with shipping information
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingShippingInformationGetAsyncWithHttpInfo()
    {
        $returnType = 'object[]';
        $request = $this->restOrdersShippingShippingInformationGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingShippingInformationGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingShippingInformationGetRequest()
    {

        $resourcePath = '/rest/orders/shipping/shipping_information';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingShippingInformationPost
     *
     * Create shipping information
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ShippingInformation
     */
    public function restOrdersShippingShippingInformationPost()
    {
        list($response) = $this->restOrdersShippingShippingInformationPostWithHttpInfo();
        return $response;
    }

    /**
     * Operation restOrdersShippingShippingInformationPostWithHttpInfo
     *
     * Create shipping information
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ShippingInformation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingShippingInformationPostWithHttpInfo()
    {
        $request = $this->restOrdersShippingShippingInformationPostRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ShippingInformation' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ShippingInformation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ShippingInformation';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ShippingInformation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingShippingInformationPostAsync
     *
     * Create shipping information
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingShippingInformationPostAsync()
    {
        return $this->restOrdersShippingShippingInformationPostAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingShippingInformationPostAsyncWithHttpInfo
     *
     * Create shipping information
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingShippingInformationPostAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\ShippingInformation';
        $request = $this->restOrdersShippingShippingInformationPostRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingShippingInformationPost'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingShippingInformationPostRequest()
    {

        $resourcePath = '/rest/orders/shipping/shipping_information';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersGet
     *
     * List shipping service providers
     *
     * @param  string $updated_at_before Filter that restricts the search result to shipping providers that were updated before a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string $updated_at_after Filter that restricts the search result to shipping providers that were updated after a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string $with The name of an relation to the shipping provider. The following parameter is available: ownShippingServiceProviders. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20041
     */
    public function restOrdersShippingShippingServiceProvidersGet($updated_at_before = null, $updated_at_after = null, $with = null)
    {
        list($response) = $this->restOrdersShippingShippingServiceProvidersGetWithHttpInfo($updated_at_before, $updated_at_after, $with);
        return $response;
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersGetWithHttpInfo
     *
     * List shipping service providers
     *
     * @param  string $updated_at_before Filter that restricts the search result to shipping providers that were updated before a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string $updated_at_after Filter that restricts the search result to shipping providers that were updated after a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string $with The name of an relation to the shipping provider. The following parameter is available: ownShippingServiceProviders. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20041, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingShippingServiceProvidersGetWithHttpInfo($updated_at_before = null, $updated_at_after = null, $with = null)
    {
        $request = $this->restOrdersShippingShippingServiceProvidersGetRequest($updated_at_before, $updated_at_after, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20041' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20041', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20041';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20041',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersGetAsync
     *
     * List shipping service providers
     *
     * @param  string $updated_at_before Filter that restricts the search result to shipping providers that were updated before a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string $updated_at_after Filter that restricts the search result to shipping providers that were updated after a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string $with The name of an relation to the shipping provider. The following parameter is available: ownShippingServiceProviders. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingShippingServiceProvidersGetAsync($updated_at_before = null, $updated_at_after = null, $with = null)
    {
        return $this->restOrdersShippingShippingServiceProvidersGetAsyncWithHttpInfo($updated_at_before, $updated_at_after, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersGetAsyncWithHttpInfo
     *
     * List shipping service providers
     *
     * @param  string $updated_at_before Filter that restricts the search result to shipping providers that were updated before a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string $updated_at_after Filter that restricts the search result to shipping providers that were updated after a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string $with The name of an relation to the shipping provider. The following parameter is available: ownShippingServiceProviders. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingShippingServiceProvidersGetAsyncWithHttpInfo($updated_at_before = null, $updated_at_after = null, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20041';
        $request = $this->restOrdersShippingShippingServiceProvidersGetRequest($updated_at_before, $updated_at_after, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingShippingServiceProvidersGet'
     *
     * @param  string $updated_at_before Filter that restricts the search result to shipping providers that were updated before a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string $updated_at_after Filter that restricts the search result to shipping providers that were updated after a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string $with The name of an relation to the shipping provider. The following parameter is available: ownShippingServiceProviders. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingShippingServiceProvidersGetRequest($updated_at_before = null, $updated_at_after = null, $with = null)
    {

        $resourcePath = '/rest/orders/shipping/shipping_service_providers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($updated_at_before)) {
            $updated_at_before = ObjectSerializer::serializeCollection($updated_at_before, '', true);
        }
        if ($updated_at_before !== null) {
            $queryParams['updatedAtBefore'] = $updated_at_before;
        }
        // query params
        if (is_array($updated_at_after)) {
            $updated_at_after = ObjectSerializer::serializeCollection($updated_at_after, '', true);
        }
        if ($updated_at_after !== null) {
            $queryParams['updatedAtAfter'] = $updated_at_after;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersPluginsGet
     *
     * List shipping service provider plugins
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function restOrdersShippingShippingServiceProvidersPluginsGet()
    {
        list($response) = $this->restOrdersShippingShippingServiceProvidersPluginsGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersPluginsGetWithHttpInfo
     *
     * List shipping service provider plugins
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingShippingServiceProvidersPluginsGetWithHttpInfo()
    {
        $request = $this->restOrdersShippingShippingServiceProvidersPluginsGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersPluginsGetAsync
     *
     * List shipping service provider plugins
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingShippingServiceProvidersPluginsGetAsync()
    {
        return $this->restOrdersShippingShippingServiceProvidersPluginsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersPluginsGetAsyncWithHttpInfo
     *
     * List shipping service provider plugins
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingShippingServiceProvidersPluginsGetAsyncWithHttpInfo()
    {
        $returnType = 'object[]';
        $request = $this->restOrdersShippingShippingServiceProvidersPluginsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingShippingServiceProvidersPluginsGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingShippingServiceProvidersPluginsGetRequest()
    {

        $resourcePath = '/rest/orders/shipping/shipping_service_providers/plugins';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersPost
     *
     * Save a shipping service provider
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ShippingServiceProvider
     */
    public function restOrdersShippingShippingServiceProvidersPost()
    {
        list($response) = $this->restOrdersShippingShippingServiceProvidersPostWithHttpInfo();
        return $response;
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersPostWithHttpInfo
     *
     * Save a shipping service provider
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ShippingServiceProvider, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingShippingServiceProvidersPostWithHttpInfo()
    {
        $request = $this->restOrdersShippingShippingServiceProvidersPostRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ShippingServiceProvider' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ShippingServiceProvider', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ShippingServiceProvider';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ShippingServiceProvider',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersPostAsync
     *
     * Save a shipping service provider
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingShippingServiceProvidersPostAsync()
    {
        return $this->restOrdersShippingShippingServiceProvidersPostAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersPostAsyncWithHttpInfo
     *
     * Save a shipping service provider
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingShippingServiceProvidersPostAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\ShippingServiceProvider';
        $request = $this->restOrdersShippingShippingServiceProvidersPostRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingShippingServiceProvidersPost'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingShippingServiceProvidersPostRequest()
    {

        $resourcePath = '/rest/orders/shipping/shipping_service_providers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGet
     *
     * Get a shipping service provider
     *
     * @param  int $shipping_service_provider_id The ID of the shipping service provider (required)
     * @param  int $shipping_service_provider_id2 shipping_service_provider_id2 (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ShippingServiceProvider
     */
    public function restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGet($shipping_service_provider_id, $shipping_service_provider_id2)
    {
        list($response) = $this->restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGetWithHttpInfo($shipping_service_provider_id, $shipping_service_provider_id2);
        return $response;
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGetWithHttpInfo
     *
     * Get a shipping service provider
     *
     * @param  int $shipping_service_provider_id The ID of the shipping service provider (required)
     * @param  int $shipping_service_provider_id2 (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ShippingServiceProvider, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGetWithHttpInfo($shipping_service_provider_id, $shipping_service_provider_id2)
    {
        $request = $this->restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGetRequest($shipping_service_provider_id, $shipping_service_provider_id2);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ShippingServiceProvider' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ShippingServiceProvider', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ShippingServiceProvider';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ShippingServiceProvider',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGetAsync
     *
     * Get a shipping service provider
     *
     * @param  int $shipping_service_provider_id The ID of the shipping service provider (required)
     * @param  int $shipping_service_provider_id2 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGetAsync($shipping_service_provider_id, $shipping_service_provider_id2)
    {
        return $this->restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGetAsyncWithHttpInfo($shipping_service_provider_id, $shipping_service_provider_id2)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGetAsyncWithHttpInfo
     *
     * Get a shipping service provider
     *
     * @param  int $shipping_service_provider_id The ID of the shipping service provider (required)
     * @param  int $shipping_service_provider_id2 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGetAsyncWithHttpInfo($shipping_service_provider_id, $shipping_service_provider_id2)
    {
        $returnType = '\OpenAPI\Client\Model\ShippingServiceProvider';
        $request = $this->restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGetRequest($shipping_service_provider_id, $shipping_service_provider_id2);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGet'
     *
     * @param  int $shipping_service_provider_id The ID of the shipping service provider (required)
     * @param  int $shipping_service_provider_id2 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGetRequest($shipping_service_provider_id, $shipping_service_provider_id2)
    {
        // verify the required parameter 'shipping_service_provider_id' is set
        if ($shipping_service_provider_id === null || (is_array($shipping_service_provider_id) && count($shipping_service_provider_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipping_service_provider_id when calling restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGet'
            );
        }
        // verify the required parameter 'shipping_service_provider_id2' is set
        if ($shipping_service_provider_id2 === null || (is_array($shipping_service_provider_id2) && count($shipping_service_provider_id2) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipping_service_provider_id2 when calling restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGet'
            );
        }

        $resourcePath = '/rest/orders/shipping/shipping_service_providers/{shipping_service_provider_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($shipping_service_provider_id)) {
            $shipping_service_provider_id = ObjectSerializer::serializeCollection($shipping_service_provider_id, '', true);
        }
        if ($shipping_service_provider_id !== null) {
            $queryParams['shippingServiceProviderId'] = $shipping_service_provider_id;
        }


        // path params
        if ($shipping_service_provider_id2 !== null) {
            $resourcePath = str_replace(
                '{' . 'shipping_service_provider_id' . '}',
                ObjectSerializer::toPathValue($shipping_service_provider_id2),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersStatusHistoryGet
     *
     * List status histories of orders
     *
     * @param  int $order_id The ID of the order (optional)
     * @param  float $status_id The ID of the status (optional)
     * @param  string $created_at_from Set a start date to get status history entries beginning with this date (optional)
     * @param  string $created_at_to Set an end date to get status history entries up to this date (optional)
     * @param  string $user_id The ID of the user (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20042
     */
    public function restOrdersStatusHistoryGet($order_id = null, $status_id = null, $created_at_from = null, $created_at_to = null, $user_id = null)
    {
        list($response) = $this->restOrdersStatusHistoryGetWithHttpInfo($order_id, $status_id, $created_at_from, $created_at_to, $user_id);
        return $response;
    }

    /**
     * Operation restOrdersStatusHistoryGetWithHttpInfo
     *
     * List status histories of orders
     *
     * @param  int $order_id The ID of the order (optional)
     * @param  float $status_id The ID of the status (optional)
     * @param  string $created_at_from Set a start date to get status history entries beginning with this date (optional)
     * @param  string $created_at_to Set an end date to get status history entries up to this date (optional)
     * @param  string $user_id The ID of the user (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20042, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersStatusHistoryGetWithHttpInfo($order_id = null, $status_id = null, $created_at_from = null, $created_at_to = null, $user_id = null)
    {
        $request = $this->restOrdersStatusHistoryGetRequest($order_id, $status_id, $created_at_from, $created_at_to, $user_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20042' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20042', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20042';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20042',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersStatusHistoryGetAsync
     *
     * List status histories of orders
     *
     * @param  int $order_id The ID of the order (optional)
     * @param  float $status_id The ID of the status (optional)
     * @param  string $created_at_from Set a start date to get status history entries beginning with this date (optional)
     * @param  string $created_at_to Set an end date to get status history entries up to this date (optional)
     * @param  string $user_id The ID of the user (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersStatusHistoryGetAsync($order_id = null, $status_id = null, $created_at_from = null, $created_at_to = null, $user_id = null)
    {
        return $this->restOrdersStatusHistoryGetAsyncWithHttpInfo($order_id, $status_id, $created_at_from, $created_at_to, $user_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersStatusHistoryGetAsyncWithHttpInfo
     *
     * List status histories of orders
     *
     * @param  int $order_id The ID of the order (optional)
     * @param  float $status_id The ID of the status (optional)
     * @param  string $created_at_from Set a start date to get status history entries beginning with this date (optional)
     * @param  string $created_at_to Set an end date to get status history entries up to this date (optional)
     * @param  string $user_id The ID of the user (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersStatusHistoryGetAsyncWithHttpInfo($order_id = null, $status_id = null, $created_at_from = null, $created_at_to = null, $user_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20042';
        $request = $this->restOrdersStatusHistoryGetRequest($order_id, $status_id, $created_at_from, $created_at_to, $user_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersStatusHistoryGet'
     *
     * @param  int $order_id The ID of the order (optional)
     * @param  float $status_id The ID of the status (optional)
     * @param  string $created_at_from Set a start date to get status history entries beginning with this date (optional)
     * @param  string $created_at_to Set an end date to get status history entries up to this date (optional)
     * @param  string $user_id The ID of the user (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersStatusHistoryGetRequest($order_id = null, $status_id = null, $created_at_from = null, $created_at_to = null, $user_id = null)
    {

        $resourcePath = '/rest/orders/status-history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($order_id)) {
            $order_id = ObjectSerializer::serializeCollection($order_id, '', true);
        }
        if ($order_id !== null) {
            $queryParams['orderId'] = $order_id;
        }
        // query params
        if (is_array($status_id)) {
            $status_id = ObjectSerializer::serializeCollection($status_id, '', true);
        }
        if ($status_id !== null) {
            $queryParams['statusId'] = $status_id;
        }
        // query params
        if (is_array($created_at_from)) {
            $created_at_from = ObjectSerializer::serializeCollection($created_at_from, '', true);
        }
        if ($created_at_from !== null) {
            $queryParams['createdAtFrom'] = $created_at_from;
        }
        // query params
        if (is_array($created_at_to)) {
            $created_at_to = ObjectSerializer::serializeCollection($created_at_to, '', true);
        }
        if ($created_at_to !== null) {
            $queryParams['createdAtTo'] = $created_at_to;
        }
        // query params
        if (is_array($user_id)) {
            $user_id = ObjectSerializer::serializeCollection($user_id, '', true);
        }
        if ($user_id !== null) {
            $queryParams['userId'] = $user_id;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersStatusesAllGet
     *
     * Get all order statuses
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersStatusesAllGet()
    {
        list($response) = $this->restOrdersStatusesAllGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restOrdersStatusesAllGetWithHttpInfo
     *
     * Get all order statuses
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersStatusesAllGetWithHttpInfo()
    {
        $request = $this->restOrdersStatusesAllGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersStatusesAllGetAsync
     *
     * Get all order statuses
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersStatusesAllGetAsync()
    {
        return $this->restOrdersStatusesAllGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersStatusesAllGetAsyncWithHttpInfo
     *
     * Get all order statuses
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersStatusesAllGetAsyncWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->restOrdersStatusesAllGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersStatusesAllGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersStatusesAllGetRequest()
    {

        $resourcePath = '/rest/orders/statuses/all';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersStatusesGet
     *
     * Searches for order statuses
     *
     * @param  float $status_id_from Define an ID as a start value for the filter. Filter that restricts the search for order statuses to IDs from a defined value. (optional)
     * @param  float $status_id_to Define an ID as an end value for the filter. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20043
     */
    public function restOrdersStatusesGet($status_id_from = null, $status_id_to = null)
    {
        list($response) = $this->restOrdersStatusesGetWithHttpInfo($status_id_from, $status_id_to);
        return $response;
    }

    /**
     * Operation restOrdersStatusesGetWithHttpInfo
     *
     * Searches for order statuses
     *
     * @param  float $status_id_from Define an ID as a start value for the filter. Filter that restricts the search for order statuses to IDs from a defined value. (optional)
     * @param  float $status_id_to Define an ID as an end value for the filter. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20043, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersStatusesGetWithHttpInfo($status_id_from = null, $status_id_to = null)
    {
        $request = $this->restOrdersStatusesGetRequest($status_id_from, $status_id_to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20043' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20043', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20043';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20043',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersStatusesGetAsync
     *
     * Searches for order statuses
     *
     * @param  float $status_id_from Define an ID as a start value for the filter. Filter that restricts the search for order statuses to IDs from a defined value. (optional)
     * @param  float $status_id_to Define an ID as an end value for the filter. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersStatusesGetAsync($status_id_from = null, $status_id_to = null)
    {
        return $this->restOrdersStatusesGetAsyncWithHttpInfo($status_id_from, $status_id_to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersStatusesGetAsyncWithHttpInfo
     *
     * Searches for order statuses
     *
     * @param  float $status_id_from Define an ID as a start value for the filter. Filter that restricts the search for order statuses to IDs from a defined value. (optional)
     * @param  float $status_id_to Define an ID as an end value for the filter. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersStatusesGetAsyncWithHttpInfo($status_id_from = null, $status_id_to = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20043';
        $request = $this->restOrdersStatusesGetRequest($status_id_from, $status_id_to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersStatusesGet'
     *
     * @param  float $status_id_from Define an ID as a start value for the filter. Filter that restricts the search for order statuses to IDs from a defined value. (optional)
     * @param  float $status_id_to Define an ID as an end value for the filter. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersStatusesGetRequest($status_id_from = null, $status_id_to = null)
    {

        $resourcePath = '/rest/orders/statuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($status_id_from)) {
            $status_id_from = ObjectSerializer::serializeCollection($status_id_from, '', true);
        }
        if ($status_id_from !== null) {
            $queryParams['statusIdFrom'] = $status_id_from;
        }
        // query params
        if (is_array($status_id_to)) {
            $status_id_to = ObjectSerializer::serializeCollection($status_id_to, '', true);
        }
        if ($status_id_to !== null) {
            $queryParams['statusIdTo'] = $status_id_to;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersStatusesGroupFunctionsPost
     *
     * Change order status properties
     *
     * @param  int $new_status_values Set an array of new order status properties consisting of one key and one value for each property. The status colour must be set as a hexadecimal code. All other properties must be specified either by value 0 (inactive) or 1 (active). (required)
     * @param  int $selected_status_list Set a list with the IDs of the order statuses that should be changed. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restOrdersStatusesGroupFunctionsPost($new_status_values, $selected_status_list)
    {
        $this->restOrdersStatusesGroupFunctionsPostWithHttpInfo($new_status_values, $selected_status_list);
    }

    /**
     * Operation restOrdersStatusesGroupFunctionsPostWithHttpInfo
     *
     * Change order status properties
     *
     * @param  int $new_status_values Set an array of new order status properties consisting of one key and one value for each property. The status colour must be set as a hexadecimal code. All other properties must be specified either by value 0 (inactive) or 1 (active). (required)
     * @param  int $selected_status_list Set a list with the IDs of the order statuses that should be changed. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersStatusesGroupFunctionsPostWithHttpInfo($new_status_values, $selected_status_list)
    {
        $request = $this->restOrdersStatusesGroupFunctionsPostRequest($new_status_values, $selected_status_list);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersStatusesGroupFunctionsPostAsync
     *
     * Change order status properties
     *
     * @param  int $new_status_values Set an array of new order status properties consisting of one key and one value for each property. The status colour must be set as a hexadecimal code. All other properties must be specified either by value 0 (inactive) or 1 (active). (required)
     * @param  int $selected_status_list Set a list with the IDs of the order statuses that should be changed. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersStatusesGroupFunctionsPostAsync($new_status_values, $selected_status_list)
    {
        return $this->restOrdersStatusesGroupFunctionsPostAsyncWithHttpInfo($new_status_values, $selected_status_list)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersStatusesGroupFunctionsPostAsyncWithHttpInfo
     *
     * Change order status properties
     *
     * @param  int $new_status_values Set an array of new order status properties consisting of one key and one value for each property. The status colour must be set as a hexadecimal code. All other properties must be specified either by value 0 (inactive) or 1 (active). (required)
     * @param  int $selected_status_list Set a list with the IDs of the order statuses that should be changed. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersStatusesGroupFunctionsPostAsyncWithHttpInfo($new_status_values, $selected_status_list)
    {
        $returnType = '';
        $request = $this->restOrdersStatusesGroupFunctionsPostRequest($new_status_values, $selected_status_list);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersStatusesGroupFunctionsPost'
     *
     * @param  int $new_status_values Set an array of new order status properties consisting of one key and one value for each property. The status colour must be set as a hexadecimal code. All other properties must be specified either by value 0 (inactive) or 1 (active). (required)
     * @param  int $selected_status_list Set a list with the IDs of the order statuses that should be changed. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersStatusesGroupFunctionsPostRequest($new_status_values, $selected_status_list)
    {
        // verify the required parameter 'new_status_values' is set
        if ($new_status_values === null || (is_array($new_status_values) && count($new_status_values) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_status_values when calling restOrdersStatusesGroupFunctionsPost'
            );
        }
        // verify the required parameter 'selected_status_list' is set
        if ($selected_status_list === null || (is_array($selected_status_list) && count($selected_status_list) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $selected_status_list when calling restOrdersStatusesGroupFunctionsPost'
            );
        }

        $resourcePath = '/rest/orders/statuses/group_functions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($new_status_values)) {
            $new_status_values = ObjectSerializer::serializeCollection($new_status_values, '', true);
        }
        if ($new_status_values !== null) {
            $queryParams['newStatusValues'] = $new_status_values;
        }
        // query params
        if (is_array($selected_status_list)) {
            $selected_status_list = ObjectSerializer::serializeCollection($selected_status_list, '', true);
        }
        if ($selected_status_list !== null) {
            $queryParams['selectedStatusList'] = $selected_status_list;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersStatusesPost
     *
     * Creates an order status.
     *
     * @param  \OpenAPI\Client\Model\InlineObject189 $_rest_orders_statuses _rest_orders_statuses (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderStatus
     */
    public function restOrdersStatusesPost($_rest_orders_statuses = null)
    {
        list($response) = $this->restOrdersStatusesPostWithHttpInfo($_rest_orders_statuses);
        return $response;
    }

    /**
     * Operation restOrdersStatusesPostWithHttpInfo
     *
     * Creates an order status.
     *
     * @param  \OpenAPI\Client\Model\InlineObject189 $_rest_orders_statuses (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersStatusesPostWithHttpInfo($_rest_orders_statuses = null)
    {
        $request = $this->restOrdersStatusesPostRequest($_rest_orders_statuses);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderStatus' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderStatus';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersStatusesPostAsync
     *
     * Creates an order status.
     *
     * @param  \OpenAPI\Client\Model\InlineObject189 $_rest_orders_statuses (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersStatusesPostAsync($_rest_orders_statuses = null)
    {
        return $this->restOrdersStatusesPostAsyncWithHttpInfo($_rest_orders_statuses)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersStatusesPostAsyncWithHttpInfo
     *
     * Creates an order status.
     *
     * @param  \OpenAPI\Client\Model\InlineObject189 $_rest_orders_statuses (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersStatusesPostAsyncWithHttpInfo($_rest_orders_statuses = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderStatus';
        $request = $this->restOrdersStatusesPostRequest($_rest_orders_statuses);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersStatusesPost'
     *
     * @param  \OpenAPI\Client\Model\InlineObject189 $_rest_orders_statuses (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersStatusesPostRequest($_rest_orders_statuses = null)
    {

        $resourcePath = '/rest/orders/statuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_orders_statuses)) {
            $_tempBody = $_rest_orders_statuses;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersStatusesStatusIdDelete
     *
     * Delete an order status
     *
     * @param  float $status_id The ID of the status, which shall be deleted. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restOrdersStatusesStatusIdDelete($status_id)
    {
        $this->restOrdersStatusesStatusIdDeleteWithHttpInfo($status_id);
    }

    /**
     * Operation restOrdersStatusesStatusIdDeleteWithHttpInfo
     *
     * Delete an order status
     *
     * @param  float $status_id The ID of the status, which shall be deleted. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersStatusesStatusIdDeleteWithHttpInfo($status_id)
    {
        $request = $this->restOrdersStatusesStatusIdDeleteRequest($status_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersStatusesStatusIdDeleteAsync
     *
     * Delete an order status
     *
     * @param  float $status_id The ID of the status, which shall be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersStatusesStatusIdDeleteAsync($status_id)
    {
        return $this->restOrdersStatusesStatusIdDeleteAsyncWithHttpInfo($status_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersStatusesStatusIdDeleteAsyncWithHttpInfo
     *
     * Delete an order status
     *
     * @param  float $status_id The ID of the status, which shall be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersStatusesStatusIdDeleteAsyncWithHttpInfo($status_id)
    {
        $returnType = '';
        $request = $this->restOrdersStatusesStatusIdDeleteRequest($status_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersStatusesStatusIdDelete'
     *
     * @param  float $status_id The ID of the status, which shall be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersStatusesStatusIdDeleteRequest($status_id)
    {
        // verify the required parameter 'status_id' is set
        if ($status_id === null || (is_array($status_id) && count($status_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $status_id when calling restOrdersStatusesStatusIdDelete'
            );
        }

        $resourcePath = '/rest/orders/statuses/{statusId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($status_id !== null) {
            $resourcePath = str_replace(
                '{' . 'statusId' . '}',
                ObjectSerializer::toPathValue($status_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersStatusesStatusIdGet
     *
     * Get an order status
     *
     * @param  float $status_id The ID of the order status. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderStatus
     */
    public function restOrdersStatusesStatusIdGet($status_id)
    {
        list($response) = $this->restOrdersStatusesStatusIdGetWithHttpInfo($status_id);
        return $response;
    }

    /**
     * Operation restOrdersStatusesStatusIdGetWithHttpInfo
     *
     * Get an order status
     *
     * @param  float $status_id The ID of the order status. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersStatusesStatusIdGetWithHttpInfo($status_id)
    {
        $request = $this->restOrdersStatusesStatusIdGetRequest($status_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderStatus' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderStatus';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersStatusesStatusIdGetAsync
     *
     * Get an order status
     *
     * @param  float $status_id The ID of the order status. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersStatusesStatusIdGetAsync($status_id)
    {
        return $this->restOrdersStatusesStatusIdGetAsyncWithHttpInfo($status_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersStatusesStatusIdGetAsyncWithHttpInfo
     *
     * Get an order status
     *
     * @param  float $status_id The ID of the order status. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersStatusesStatusIdGetAsyncWithHttpInfo($status_id)
    {
        $returnType = '\OpenAPI\Client\Model\OrderStatus';
        $request = $this->restOrdersStatusesStatusIdGetRequest($status_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersStatusesStatusIdGet'
     *
     * @param  float $status_id The ID of the order status. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersStatusesStatusIdGetRequest($status_id)
    {
        // verify the required parameter 'status_id' is set
        if ($status_id === null || (is_array($status_id) && count($status_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $status_id when calling restOrdersStatusesStatusIdGet'
            );
        }

        $resourcePath = '/rest/orders/statuses/{statusId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($status_id !== null) {
            $resourcePath = str_replace(
                '{' . 'statusId' . '}',
                ObjectSerializer::toPathValue($status_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersStatusesStatusIdPut
     *
     * Update an order status
     *
     * @param  float $status_id The ID of the order status that should be updated. (required)
     * @param  \OpenAPI\Client\Model\InlineObject190 $_rest_orders_statuses_status_id _rest_orders_statuses_status_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderStatus
     */
    public function restOrdersStatusesStatusIdPut($status_id, $_rest_orders_statuses_status_id = null)
    {
        list($response) = $this->restOrdersStatusesStatusIdPutWithHttpInfo($status_id, $_rest_orders_statuses_status_id);
        return $response;
    }

    /**
     * Operation restOrdersStatusesStatusIdPutWithHttpInfo
     *
     * Update an order status
     *
     * @param  float $status_id The ID of the order status that should be updated. (required)
     * @param  \OpenAPI\Client\Model\InlineObject190 $_rest_orders_statuses_status_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersStatusesStatusIdPutWithHttpInfo($status_id, $_rest_orders_statuses_status_id = null)
    {
        $request = $this->restOrdersStatusesStatusIdPutRequest($status_id, $_rest_orders_statuses_status_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderStatus' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderStatus';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersStatusesStatusIdPutAsync
     *
     * Update an order status
     *
     * @param  float $status_id The ID of the order status that should be updated. (required)
     * @param  \OpenAPI\Client\Model\InlineObject190 $_rest_orders_statuses_status_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersStatusesStatusIdPutAsync($status_id, $_rest_orders_statuses_status_id = null)
    {
        return $this->restOrdersStatusesStatusIdPutAsyncWithHttpInfo($status_id, $_rest_orders_statuses_status_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersStatusesStatusIdPutAsyncWithHttpInfo
     *
     * Update an order status
     *
     * @param  float $status_id The ID of the order status that should be updated. (required)
     * @param  \OpenAPI\Client\Model\InlineObject190 $_rest_orders_statuses_status_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersStatusesStatusIdPutAsyncWithHttpInfo($status_id, $_rest_orders_statuses_status_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\OrderStatus';
        $request = $this->restOrdersStatusesStatusIdPutRequest($status_id, $_rest_orders_statuses_status_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersStatusesStatusIdPut'
     *
     * @param  float $status_id The ID of the order status that should be updated. (required)
     * @param  \OpenAPI\Client\Model\InlineObject190 $_rest_orders_statuses_status_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersStatusesStatusIdPutRequest($status_id, $_rest_orders_statuses_status_id = null)
    {
        // verify the required parameter 'status_id' is set
        if ($status_id === null || (is_array($status_id) && count($status_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $status_id when calling restOrdersStatusesStatusIdPut'
            );
        }

        $resourcePath = '/rest/orders/statuses/{statusId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($status_id !== null) {
            $resourcePath = str_replace(
                '{' . 'statusId' . '}',
                ObjectSerializer::toPathValue($status_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_orders_statuses_status_id)) {
            $_tempBody = $_rest_orders_statuses_status_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restRedistributionsOrderIdDelete
     *
     * Delete a redistribution
     *
     * @param  int $order_id order_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restRedistributionsOrderIdDelete($order_id)
    {
        list($response) = $this->restRedistributionsOrderIdDeleteWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restRedistributionsOrderIdDeleteWithHttpInfo
     *
     * Delete a redistribution
     *
     * @param  int $order_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restRedistributionsOrderIdDeleteWithHttpInfo($order_id)
    {
        $request = $this->restRedistributionsOrderIdDeleteRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restRedistributionsOrderIdDeleteAsync
     *
     * Delete a redistribution
     *
     * @param  int $order_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restRedistributionsOrderIdDeleteAsync($order_id)
    {
        return $this->restRedistributionsOrderIdDeleteAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restRedistributionsOrderIdDeleteAsyncWithHttpInfo
     *
     * Delete a redistribution
     *
     * @param  int $order_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restRedistributionsOrderIdDeleteAsyncWithHttpInfo($order_id)
    {
        $returnType = 'object';
        $request = $this->restRedistributionsOrderIdDeleteRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restRedistributionsOrderIdDelete'
     *
     * @param  int $order_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restRedistributionsOrderIdDeleteRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restRedistributionsOrderIdDelete'
            );
        }

        $resourcePath = '/rest/redistributions/{orderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restRedistributionsOrderIdPut
     *
     * Update a redistribution
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  \OpenAPI\Client\Model\InlineObject228 $_rest_redistributions_order_id _rest_redistributions_order_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Order
     */
    public function restRedistributionsOrderIdPut($order_id, $_rest_redistributions_order_id = null)
    {
        list($response) = $this->restRedistributionsOrderIdPutWithHttpInfo($order_id, $_rest_redistributions_order_id);
        return $response;
    }

    /**
     * Operation restRedistributionsOrderIdPutWithHttpInfo
     *
     * Update a redistribution
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  \OpenAPI\Client\Model\InlineObject228 $_rest_redistributions_order_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restRedistributionsOrderIdPutWithHttpInfo($order_id, $_rest_redistributions_order_id = null)
    {
        $request = $this->restRedistributionsOrderIdPutRequest($order_id, $_rest_redistributions_order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Order' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Order';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restRedistributionsOrderIdPutAsync
     *
     * Update a redistribution
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  \OpenAPI\Client\Model\InlineObject228 $_rest_redistributions_order_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restRedistributionsOrderIdPutAsync($order_id, $_rest_redistributions_order_id = null)
    {
        return $this->restRedistributionsOrderIdPutAsyncWithHttpInfo($order_id, $_rest_redistributions_order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restRedistributionsOrderIdPutAsyncWithHttpInfo
     *
     * Update a redistribution
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  \OpenAPI\Client\Model\InlineObject228 $_rest_redistributions_order_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restRedistributionsOrderIdPutAsyncWithHttpInfo($order_id, $_rest_redistributions_order_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\Order';
        $request = $this->restRedistributionsOrderIdPutRequest($order_id, $_rest_redistributions_order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restRedistributionsOrderIdPut'
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  \OpenAPI\Client\Model\InlineObject228 $_rest_redistributions_order_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restRedistributionsOrderIdPutRequest($order_id, $_rest_redistributions_order_id = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restRedistributionsOrderIdPut'
            );
        }

        $resourcePath = '/rest/redistributions/{orderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_redistributions_order_id)) {
            $_tempBody = $_rest_redistributions_order_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restRedistributionsPost
     *
     * Create a redistribution
     *
     * @param  \OpenAPI\Client\Model\InlineObject227 $_rest_redistributions _rest_redistributions (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Order
     */
    public function restRedistributionsPost($_rest_redistributions = null)
    {
        list($response) = $this->restRedistributionsPostWithHttpInfo($_rest_redistributions);
        return $response;
    }

    /**
     * Operation restRedistributionsPostWithHttpInfo
     *
     * Create a redistribution
     *
     * @param  \OpenAPI\Client\Model\InlineObject227 $_rest_redistributions (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restRedistributionsPostWithHttpInfo($_rest_redistributions = null)
    {
        $request = $this->restRedistributionsPostRequest($_rest_redistributions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Order' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Order';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restRedistributionsPostAsync
     *
     * Create a redistribution
     *
     * @param  \OpenAPI\Client\Model\InlineObject227 $_rest_redistributions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restRedistributionsPostAsync($_rest_redistributions = null)
    {
        return $this->restRedistributionsPostAsyncWithHttpInfo($_rest_redistributions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restRedistributionsPostAsyncWithHttpInfo
     *
     * Create a redistribution
     *
     * @param  \OpenAPI\Client\Model\InlineObject227 $_rest_redistributions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restRedistributionsPostAsyncWithHttpInfo($_rest_redistributions = null)
    {
        $returnType = '\OpenAPI\Client\Model\Order';
        $request = $this->restRedistributionsPostRequest($_rest_redistributions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restRedistributionsPost'
     *
     * @param  \OpenAPI\Client\Model\InlineObject227 $_rest_redistributions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restRedistributionsPostRequest($_rest_redistributions = null)
    {

        $resourcePath = '/rest/redistributions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_redistributions)) {
            $_tempBody = $_rest_redistributions;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restReordersOrderIdCurrencyPut
     *
     * Update the currency
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Order
     */
    public function restReordersOrderIdCurrencyPut($order_id)
    {
        list($response) = $this->restReordersOrderIdCurrencyPutWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restReordersOrderIdCurrencyPutWithHttpInfo
     *
     * Update the currency
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restReordersOrderIdCurrencyPutWithHttpInfo($order_id)
    {
        $request = $this->restReordersOrderIdCurrencyPutRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Order' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Order';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restReordersOrderIdCurrencyPutAsync
     *
     * Update the currency
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restReordersOrderIdCurrencyPutAsync($order_id)
    {
        return $this->restReordersOrderIdCurrencyPutAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restReordersOrderIdCurrencyPutAsyncWithHttpInfo
     *
     * Update the currency
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restReordersOrderIdCurrencyPutAsyncWithHttpInfo($order_id)
    {
        $returnType = '\OpenAPI\Client\Model\Order';
        $request = $this->restReordersOrderIdCurrencyPutRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restReordersOrderIdCurrencyPut'
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restReordersOrderIdCurrencyPutRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restReordersOrderIdCurrencyPut'
            );
        }

        $resourcePath = '/rest/reorders/{orderId}/currency';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restReordersOrderIdDelete
     *
     * Delete a reorder
     *
     * @param  int $order_id order_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restReordersOrderIdDelete($order_id)
    {
        list($response) = $this->restReordersOrderIdDeleteWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restReordersOrderIdDeleteWithHttpInfo
     *
     * Delete a reorder
     *
     * @param  int $order_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restReordersOrderIdDeleteWithHttpInfo($order_id)
    {
        $request = $this->restReordersOrderIdDeleteRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restReordersOrderIdDeleteAsync
     *
     * Delete a reorder
     *
     * @param  int $order_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restReordersOrderIdDeleteAsync($order_id)
    {
        return $this->restReordersOrderIdDeleteAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restReordersOrderIdDeleteAsyncWithHttpInfo
     *
     * Delete a reorder
     *
     * @param  int $order_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restReordersOrderIdDeleteAsyncWithHttpInfo($order_id)
    {
        $returnType = 'object';
        $request = $this->restReordersOrderIdDeleteRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restReordersOrderIdDelete'
     *
     * @param  int $order_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restReordersOrderIdDeleteRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restReordersOrderIdDelete'
            );
        }

        $resourcePath = '/rest/reorders/{orderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restReordersOrderIdDeliveryDateGet
     *
     * Get the delivery date
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restReordersOrderIdDeliveryDateGet($order_id)
    {
        list($response) = $this->restReordersOrderIdDeliveryDateGetWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restReordersOrderIdDeliveryDateGetWithHttpInfo
     *
     * Get the delivery date
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restReordersOrderIdDeliveryDateGetWithHttpInfo($order_id)
    {
        $request = $this->restReordersOrderIdDeliveryDateGetRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restReordersOrderIdDeliveryDateGetAsync
     *
     * Get the delivery date
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restReordersOrderIdDeliveryDateGetAsync($order_id)
    {
        return $this->restReordersOrderIdDeliveryDateGetAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restReordersOrderIdDeliveryDateGetAsyncWithHttpInfo
     *
     * Get the delivery date
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restReordersOrderIdDeliveryDateGetAsyncWithHttpInfo($order_id)
    {
        $returnType = 'object';
        $request = $this->restReordersOrderIdDeliveryDateGetRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restReordersOrderIdDeliveryDateGet'
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restReordersOrderIdDeliveryDateGetRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restReordersOrderIdDeliveryDateGet'
            );
        }

        $resourcePath = '/rest/reorders/{orderId}/delivery_date';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restReordersOrderIdDeliveryDatesPut
     *
     * Calculate and save the delivery dates
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Order
     */
    public function restReordersOrderIdDeliveryDatesPut($order_id)
    {
        list($response) = $this->restReordersOrderIdDeliveryDatesPutWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation restReordersOrderIdDeliveryDatesPutWithHttpInfo
     *
     * Calculate and save the delivery dates
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restReordersOrderIdDeliveryDatesPutWithHttpInfo($order_id)
    {
        $request = $this->restReordersOrderIdDeliveryDatesPutRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Order' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Order';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restReordersOrderIdDeliveryDatesPutAsync
     *
     * Calculate and save the delivery dates
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restReordersOrderIdDeliveryDatesPutAsync($order_id)
    {
        return $this->restReordersOrderIdDeliveryDatesPutAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restReordersOrderIdDeliveryDatesPutAsyncWithHttpInfo
     *
     * Calculate and save the delivery dates
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restReordersOrderIdDeliveryDatesPutAsyncWithHttpInfo($order_id)
    {
        $returnType = '\OpenAPI\Client\Model\Order';
        $request = $this->restReordersOrderIdDeliveryDatesPutRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restReordersOrderIdDeliveryDatesPut'
     *
     * @param  int $order_id The ID of the order. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restReordersOrderIdDeliveryDatesPutRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restReordersOrderIdDeliveryDatesPut'
            );
        }

        $resourcePath = '/rest/reorders/{orderId}/delivery_dates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restReordersOrderIdPut
     *
     * Update a reorder
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  \OpenAPI\Client\Model\InlineObject230 $_rest_reorders_order_id _rest_reorders_order_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Order
     */
    public function restReordersOrderIdPut($order_id, $_rest_reorders_order_id = null)
    {
        list($response) = $this->restReordersOrderIdPutWithHttpInfo($order_id, $_rest_reorders_order_id);
        return $response;
    }

    /**
     * Operation restReordersOrderIdPutWithHttpInfo
     *
     * Update a reorder
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  \OpenAPI\Client\Model\InlineObject230 $_rest_reorders_order_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restReordersOrderIdPutWithHttpInfo($order_id, $_rest_reorders_order_id = null)
    {
        $request = $this->restReordersOrderIdPutRequest($order_id, $_rest_reorders_order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Order' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Order';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restReordersOrderIdPutAsync
     *
     * Update a reorder
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  \OpenAPI\Client\Model\InlineObject230 $_rest_reorders_order_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restReordersOrderIdPutAsync($order_id, $_rest_reorders_order_id = null)
    {
        return $this->restReordersOrderIdPutAsyncWithHttpInfo($order_id, $_rest_reorders_order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restReordersOrderIdPutAsyncWithHttpInfo
     *
     * Update a reorder
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  \OpenAPI\Client\Model\InlineObject230 $_rest_reorders_order_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restReordersOrderIdPutAsyncWithHttpInfo($order_id, $_rest_reorders_order_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\Order';
        $request = $this->restReordersOrderIdPutRequest($order_id, $_rest_reorders_order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restReordersOrderIdPut'
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  \OpenAPI\Client\Model\InlineObject230 $_rest_reorders_order_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restReordersOrderIdPutRequest($order_id, $_rest_reorders_order_id = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restReordersOrderIdPut'
            );
        }

        $resourcePath = '/rest/reorders/{orderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_reorders_order_id)) {
            $_tempBody = $_rest_reorders_order_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restReordersPost
     *
     * Create a reorder
     *
     * @param  \OpenAPI\Client\Model\InlineObject229 $_rest_reorders _rest_reorders (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Order
     */
    public function restReordersPost($_rest_reorders = null)
    {
        list($response) = $this->restReordersPostWithHttpInfo($_rest_reorders);
        return $response;
    }

    /**
     * Operation restReordersPostWithHttpInfo
     *
     * Create a reorder
     *
     * @param  \OpenAPI\Client\Model\InlineObject229 $_rest_reorders (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restReordersPostWithHttpInfo($_rest_reorders = null)
    {
        $request = $this->restReordersPostRequest($_rest_reorders);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Order' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Order';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restReordersPostAsync
     *
     * Create a reorder
     *
     * @param  \OpenAPI\Client\Model\InlineObject229 $_rest_reorders (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restReordersPostAsync($_rest_reorders = null)
    {
        return $this->restReordersPostAsyncWithHttpInfo($_rest_reorders)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restReordersPostAsyncWithHttpInfo
     *
     * Create a reorder
     *
     * @param  \OpenAPI\Client\Model\InlineObject229 $_rest_reorders (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restReordersPostAsyncWithHttpInfo($_rest_reorders = null)
    {
        $returnType = '\OpenAPI\Client\Model\Order';
        $request = $this->restReordersPostRequest($_rest_reorders);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restReordersPost'
     *
     * @param  \OpenAPI\Client\Model\InlineObject229 $_rest_reorders (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restReordersPostRequest($_rest_reorders = null)
    {

        $resourcePath = '/rest/reorders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_reorders)) {
            $_tempBody = $_rest_reorders;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentGet
     *
     * List taric vat assignments
     *
     * @param  int $page The requested page of results (optional)
     * @param  int $items_per_page The number of results per page (optional)
     * @param  int $country_id The country ID of the taric vat assignments (optional)
     * @param  int $taric_code The taric code of the taric vat assignments (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20056
     */
    public function restSystemSettingsTaricVatAssignmentGet($page = null, $items_per_page = null, $country_id = null, $taric_code = null)
    {
        list($response) = $this->restSystemSettingsTaricVatAssignmentGetWithHttpInfo($page, $items_per_page, $country_id, $taric_code);
        return $response;
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentGetWithHttpInfo
     *
     * List taric vat assignments
     *
     * @param  int $page The requested page of results (optional)
     * @param  int $items_per_page The number of results per page (optional)
     * @param  int $country_id The country ID of the taric vat assignments (optional)
     * @param  int $taric_code The taric code of the taric vat assignments (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20056, HTTP status code, HTTP response headers (array of strings)
     */
    public function restSystemSettingsTaricVatAssignmentGetWithHttpInfo($page = null, $items_per_page = null, $country_id = null, $taric_code = null)
    {
        $request = $this->restSystemSettingsTaricVatAssignmentGetRequest($page, $items_per_page, $country_id, $taric_code);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20056' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20056', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20056';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20056',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentGetAsync
     *
     * List taric vat assignments
     *
     * @param  int $page The requested page of results (optional)
     * @param  int $items_per_page The number of results per page (optional)
     * @param  int $country_id The country ID of the taric vat assignments (optional)
     * @param  int $taric_code The taric code of the taric vat assignments (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restSystemSettingsTaricVatAssignmentGetAsync($page = null, $items_per_page = null, $country_id = null, $taric_code = null)
    {
        return $this->restSystemSettingsTaricVatAssignmentGetAsyncWithHttpInfo($page, $items_per_page, $country_id, $taric_code)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentGetAsyncWithHttpInfo
     *
     * List taric vat assignments
     *
     * @param  int $page The requested page of results (optional)
     * @param  int $items_per_page The number of results per page (optional)
     * @param  int $country_id The country ID of the taric vat assignments (optional)
     * @param  int $taric_code The taric code of the taric vat assignments (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restSystemSettingsTaricVatAssignmentGetAsyncWithHttpInfo($page = null, $items_per_page = null, $country_id = null, $taric_code = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20056';
        $request = $this->restSystemSettingsTaricVatAssignmentGetRequest($page, $items_per_page, $country_id, $taric_code);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restSystemSettingsTaricVatAssignmentGet'
     *
     * @param  int $page The requested page of results (optional)
     * @param  int $items_per_page The number of results per page (optional)
     * @param  int $country_id The country ID of the taric vat assignments (optional)
     * @param  int $taric_code The taric code of the taric vat assignments (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restSystemSettingsTaricVatAssignmentGetRequest($page = null, $items_per_page = null, $country_id = null, $taric_code = null)
    {

        $resourcePath = '/rest/system/settings/taric_vat_assignment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }
        // query params
        if (is_array($country_id)) {
            $country_id = ObjectSerializer::serializeCollection($country_id, '', true);
        }
        if ($country_id !== null) {
            $queryParams['countryId'] = $country_id;
        }
        // query params
        if (is_array($taric_code)) {
            $taric_code = ObjectSerializer::serializeCollection($taric_code, '', true);
        }
        if ($taric_code !== null) {
            $queryParams['taricCode'] = $taric_code;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDelete
     *
     * Delete taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \OpenAPI\Client\Model\InlineObject242 $_rest_system_settings_taric_vat_assignment_taric_code_country_id _rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDelete($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null)
    {
        list($response) = $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteWithHttpInfo($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id);
        return $response;
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteWithHttpInfo
     *
     * Delete taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \OpenAPI\Client\Model\InlineObject242 $_rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteWithHttpInfo($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null)
    {
        $request = $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteRequest($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteAsync
     *
     * Delete taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \OpenAPI\Client\Model\InlineObject242 $_rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteAsync($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null)
    {
        return $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteAsyncWithHttpInfo($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteAsyncWithHttpInfo
     *
     * Delete taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \OpenAPI\Client\Model\InlineObject242 $_rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteAsyncWithHttpInfo($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null)
    {
        $returnType = 'object';
        $request = $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteRequest($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDelete'
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \OpenAPI\Client\Model\InlineObject242 $_rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteRequest($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null)
    {
        // verify the required parameter 'taric_code' is set
        if ($taric_code === null || (is_array($taric_code) && count($taric_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taric_code when calling restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDelete'
            );
        }
        // verify the required parameter 'country_id' is set
        if ($country_id === null || (is_array($country_id) && count($country_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_id when calling restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDelete'
            );
        }

        $resourcePath = '/rest/system/settings/taric_vat_assignment/{taricCode}/{countryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($taric_code !== null) {
            $resourcePath = str_replace(
                '{' . 'taricCode' . '}',
                ObjectSerializer::toPathValue($taric_code),
                $resourcePath
            );
        }
        // path params
        if ($country_id !== null) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_system_settings_taric_vat_assignment_taric_code_country_id)) {
            $_tempBody = $_rest_system_settings_taric_vat_assignment_taric_code_country_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGet
     *
     * Get taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TaricVatAssignment
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGet($taric_code, $country_id)
    {
        list($response) = $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGetWithHttpInfo($taric_code, $country_id);
        return $response;
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGetWithHttpInfo
     *
     * Get taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TaricVatAssignment, HTTP status code, HTTP response headers (array of strings)
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGetWithHttpInfo($taric_code, $country_id)
    {
        $request = $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGetRequest($taric_code, $country_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TaricVatAssignment' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TaricVatAssignment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TaricVatAssignment';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TaricVatAssignment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGetAsync
     *
     * Get taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGetAsync($taric_code, $country_id)
    {
        return $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGetAsyncWithHttpInfo($taric_code, $country_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGetAsyncWithHttpInfo
     *
     * Get taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGetAsyncWithHttpInfo($taric_code, $country_id)
    {
        $returnType = '\OpenAPI\Client\Model\TaricVatAssignment';
        $request = $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGetRequest($taric_code, $country_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGet'
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGetRequest($taric_code, $country_id)
    {
        // verify the required parameter 'taric_code' is set
        if ($taric_code === null || (is_array($taric_code) && count($taric_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taric_code when calling restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGet'
            );
        }
        // verify the required parameter 'country_id' is set
        if ($country_id === null || (is_array($country_id) && count($country_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_id when calling restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGet'
            );
        }

        $resourcePath = '/rest/system/settings/taric_vat_assignment/{taricCode}/{countryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($taric_code !== null) {
            $resourcePath = str_replace(
                '{' . 'taricCode' . '}',
                ObjectSerializer::toPathValue($taric_code),
                $resourcePath
            );
        }
        // path params
        if ($country_id !== null) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPost
     *
     * Create taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \OpenAPI\Client\Model\InlineObject241 $_rest_system_settings_taric_vat_assignment_taric_code_country_id _rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TaricVatAssignment
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPost($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null)
    {
        list($response) = $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPostWithHttpInfo($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id);
        return $response;
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPostWithHttpInfo
     *
     * Create taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \OpenAPI\Client\Model\InlineObject241 $_rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TaricVatAssignment, HTTP status code, HTTP response headers (array of strings)
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPostWithHttpInfo($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null)
    {
        $request = $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPostRequest($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TaricVatAssignment' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TaricVatAssignment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TaricVatAssignment';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TaricVatAssignment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPostAsync
     *
     * Create taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \OpenAPI\Client\Model\InlineObject241 $_rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPostAsync($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null)
    {
        return $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPostAsyncWithHttpInfo($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPostAsyncWithHttpInfo
     *
     * Create taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \OpenAPI\Client\Model\InlineObject241 $_rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPostAsyncWithHttpInfo($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\TaricVatAssignment';
        $request = $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPostRequest($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPost'
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \OpenAPI\Client\Model\InlineObject241 $_rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPostRequest($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null)
    {
        // verify the required parameter 'taric_code' is set
        if ($taric_code === null || (is_array($taric_code) && count($taric_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taric_code when calling restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPost'
            );
        }
        // verify the required parameter 'country_id' is set
        if ($country_id === null || (is_array($country_id) && count($country_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_id when calling restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPost'
            );
        }

        $resourcePath = '/rest/system/settings/taric_vat_assignment/{taricCode}/{countryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($taric_code !== null) {
            $resourcePath = str_replace(
                '{' . 'taricCode' . '}',
                ObjectSerializer::toPathValue($taric_code),
                $resourcePath
            );
        }
        // path params
        if ($country_id !== null) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_system_settings_taric_vat_assignment_taric_code_country_id)) {
            $_tempBody = $_rest_system_settings_taric_vat_assignment_taric_code_country_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPut
     *
     * Update taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \OpenAPI\Client\Model\InlineObject240 $_rest_system_settings_taric_vat_assignment_taric_code_country_id _rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TaricVatAssignment
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPut($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null)
    {
        list($response) = $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutWithHttpInfo($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id);
        return $response;
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutWithHttpInfo
     *
     * Update taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \OpenAPI\Client\Model\InlineObject240 $_rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TaricVatAssignment, HTTP status code, HTTP response headers (array of strings)
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutWithHttpInfo($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null)
    {
        $request = $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutRequest($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TaricVatAssignment' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TaricVatAssignment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TaricVatAssignment';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TaricVatAssignment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutAsync
     *
     * Update taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \OpenAPI\Client\Model\InlineObject240 $_rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutAsync($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null)
    {
        return $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutAsyncWithHttpInfo($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutAsyncWithHttpInfo
     *
     * Update taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \OpenAPI\Client\Model\InlineObject240 $_rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutAsyncWithHttpInfo($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\TaricVatAssignment';
        $request = $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutRequest($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPut'
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \OpenAPI\Client\Model\InlineObject240 $_rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutRequest($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null)
    {
        // verify the required parameter 'taric_code' is set
        if ($taric_code === null || (is_array($taric_code) && count($taric_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taric_code when calling restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPut'
            );
        }
        // verify the required parameter 'country_id' is set
        if ($country_id === null || (is_array($country_id) && count($country_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_id when calling restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPut'
            );
        }

        $resourcePath = '/rest/system/settings/taric_vat_assignment/{taricCode}/{countryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($taric_code !== null) {
            $resourcePath = str_replace(
                '{' . 'taricCode' . '}',
                ObjectSerializer::toPathValue($taric_code),
                $resourcePath
            );
        }
        // path params
        if ($country_id !== null) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_system_settings_taric_vat_assignment_taric_code_country_id)) {
            $_tempBody = $_rest_system_settings_taric_vat_assignment_taric_code_country_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
