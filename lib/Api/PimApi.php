<?php
/**
 * PimApi
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0-beta2
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * PimApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class PimApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation restPimAttributesDelete
     *
     * Delete attributes
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restPimAttributesDelete()
    {
        list($response) = $this->restPimAttributesDeleteWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPimAttributesDeleteWithHttpInfo
     *
     * Delete attributes
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesDeleteWithHttpInfo()
    {
        $request = $this->restPimAttributesDeleteRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesDeleteAsync
     *
     * Delete attributes
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesDeleteAsync()
    {
        return $this->restPimAttributesDeleteAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesDeleteAsyncWithHttpInfo
     *
     * Delete attributes
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesDeleteAsyncWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->restPimAttributesDeleteRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesDelete'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimAttributesDeleteRequest()
    {

        $resourcePath = '/rest/pim/attributes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesGet
     *
     * Search attributes
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attributeNames&#39; &#x3D; The attribute names of the attribute.&lt;/li&gt;&lt;li&gt; &#39;values&#39; &#x3D; The attribute values of the attribute.&lt;/li&gt;&lt;li&gt; &#39;maps&#39; &#x3D; The attribute maps of the attribute.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $ids Filter restricts the result to attributes with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $backend_name Filter restricts the result to attributes with the specified backend name. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string $name Filter restricts the result to attributes with the specified name. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  int $position Filter restricts the result to attributes with the specified position. Allowed comparator: &#39;eq&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $updated_at Filter restricts the result to attributes which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20011
     */
    public function restPimAttributesGet($with = null, $ids = null, $backend_name = null, $name = null, $position = null, $updated_at = null)
    {
        list($response) = $this->restPimAttributesGetWithHttpInfo($with, $ids, $backend_name, $name, $position, $updated_at);
        return $response;
    }

    /**
     * Operation restPimAttributesGetWithHttpInfo
     *
     * Search attributes
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attributeNames&#39; &#x3D; The attribute names of the attribute.&lt;/li&gt;&lt;li&gt; &#39;values&#39; &#x3D; The attribute values of the attribute.&lt;/li&gt;&lt;li&gt; &#39;maps&#39; &#x3D; The attribute maps of the attribute.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $ids Filter restricts the result to attributes with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $backend_name Filter restricts the result to attributes with the specified backend name. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string $name Filter restricts the result to attributes with the specified name. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  int $position Filter restricts the result to attributes with the specified position. Allowed comparator: &#39;eq&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $updated_at Filter restricts the result to attributes which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20011, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesGetWithHttpInfo($with = null, $ids = null, $backend_name = null, $name = null, $position = null, $updated_at = null)
    {
        $request = $this->restPimAttributesGetRequest($with, $ids, $backend_name, $name, $position, $updated_at);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20011' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20011', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20011';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20011',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesGetAsync
     *
     * Search attributes
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attributeNames&#39; &#x3D; The attribute names of the attribute.&lt;/li&gt;&lt;li&gt; &#39;values&#39; &#x3D; The attribute values of the attribute.&lt;/li&gt;&lt;li&gt; &#39;maps&#39; &#x3D; The attribute maps of the attribute.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $ids Filter restricts the result to attributes with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $backend_name Filter restricts the result to attributes with the specified backend name. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string $name Filter restricts the result to attributes with the specified name. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  int $position Filter restricts the result to attributes with the specified position. Allowed comparator: &#39;eq&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $updated_at Filter restricts the result to attributes which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesGetAsync($with = null, $ids = null, $backend_name = null, $name = null, $position = null, $updated_at = null)
    {
        return $this->restPimAttributesGetAsyncWithHttpInfo($with, $ids, $backend_name, $name, $position, $updated_at)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesGetAsyncWithHttpInfo
     *
     * Search attributes
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attributeNames&#39; &#x3D; The attribute names of the attribute.&lt;/li&gt;&lt;li&gt; &#39;values&#39; &#x3D; The attribute values of the attribute.&lt;/li&gt;&lt;li&gt; &#39;maps&#39; &#x3D; The attribute maps of the attribute.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $ids Filter restricts the result to attributes with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $backend_name Filter restricts the result to attributes with the specified backend name. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string $name Filter restricts the result to attributes with the specified name. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  int $position Filter restricts the result to attributes with the specified position. Allowed comparator: &#39;eq&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $updated_at Filter restricts the result to attributes which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesGetAsyncWithHttpInfo($with = null, $ids = null, $backend_name = null, $name = null, $position = null, $updated_at = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20011';
        $request = $this->restPimAttributesGetRequest($with, $ids, $backend_name, $name, $position, $updated_at);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesGet'
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attributeNames&#39; &#x3D; The attribute names of the attribute.&lt;/li&gt;&lt;li&gt; &#39;values&#39; &#x3D; The attribute values of the attribute.&lt;/li&gt;&lt;li&gt; &#39;maps&#39; &#x3D; The attribute maps of the attribute.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $ids Filter restricts the result to attributes with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $backend_name Filter restricts the result to attributes with the specified backend name. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string $name Filter restricts the result to attributes with the specified name. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  int $position Filter restricts the result to attributes with the specified position. Allowed comparator: &#39;eq&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $updated_at Filter restricts the result to attributes which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimAttributesGetRequest($with = null, $ids = null, $backend_name = null, $name = null, $position = null, $updated_at = null)
    {

        $resourcePath = '/rest/pim/attributes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }
        // query params
        if (is_array($ids)) {
            $ids = ObjectSerializer::serializeCollection($ids, '', true);
        }
        if ($ids !== null) {
            $queryParams['ids'] = $ids;
        }
        // query params
        if (is_array($backend_name)) {
            $backend_name = ObjectSerializer::serializeCollection($backend_name, '', true);
        }
        if ($backend_name !== null) {
            $queryParams['backendName'] = $backend_name;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($position)) {
            $position = ObjectSerializer::serializeCollection($position, '', true);
        }
        if ($position !== null) {
            $queryParams['position'] = $position;
        }
        // query params
        if (is_array($updated_at)) {
            $updated_at = ObjectSerializer::serializeCollection($updated_at, '', true);
        }
        if ($updated_at !== null) {
            $queryParams['updatedAt'] = $updated_at;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesIdGet
     *
     * Get one attribute
     *
     * @param  int $id id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Attribute
     */
    public function restPimAttributesIdGet($id)
    {
        list($response) = $this->restPimAttributesIdGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restPimAttributesIdGetWithHttpInfo
     *
     * Get one attribute
     *
     * @param  int $id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Attribute, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesIdGetWithHttpInfo($id)
    {
        $request = $this->restPimAttributesIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Attribute' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Attribute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Attribute';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Attribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesIdGetAsync
     *
     * Get one attribute
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesIdGetAsync($id)
    {
        return $this->restPimAttributesIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesIdGetAsyncWithHttpInfo
     *
     * Get one attribute
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\OpenAPI\Client\Model\Attribute';
        $request = $this->restPimAttributesIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesIdGet'
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimAttributesIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restPimAttributesIdGet'
            );
        }

        $resourcePath = '/rest/pim/attributes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesNamesDelete
     *
     * Delete attribute names
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restPimAttributesNamesDelete()
    {
        list($response) = $this->restPimAttributesNamesDeleteWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPimAttributesNamesDeleteWithHttpInfo
     *
     * Delete attribute names
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesNamesDeleteWithHttpInfo()
    {
        $request = $this->restPimAttributesNamesDeleteRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesNamesDeleteAsync
     *
     * Delete attribute names
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesNamesDeleteAsync()
    {
        return $this->restPimAttributesNamesDeleteAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesNamesDeleteAsyncWithHttpInfo
     *
     * Delete attribute names
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesNamesDeleteAsyncWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->restPimAttributesNamesDeleteRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesNamesDelete'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimAttributesNamesDeleteRequest()
    {

        $resourcePath = '/rest/pim/attributes/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesNamesGet
     *
     * Search attribute names
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attribute&#39; &#x3D; The attribute to the attribute name.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $attribute_id Filter restricts the result to attributes with the specified attribute ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39; (optional)
     * @param  string $lang Filter restricts the result to attributes with the specified language. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string $name Filter restricts the result to attributes with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20045
     */
    public function restPimAttributesNamesGet($with = null, $attribute_id = null, $lang = null, $name = null)
    {
        list($response) = $this->restPimAttributesNamesGetWithHttpInfo($with, $attribute_id, $lang, $name);
        return $response;
    }

    /**
     * Operation restPimAttributesNamesGetWithHttpInfo
     *
     * Search attribute names
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attribute&#39; &#x3D; The attribute to the attribute name.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $attribute_id Filter restricts the result to attributes with the specified attribute ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39; (optional)
     * @param  string $lang Filter restricts the result to attributes with the specified language. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string $name Filter restricts the result to attributes with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20045, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesNamesGetWithHttpInfo($with = null, $attribute_id = null, $lang = null, $name = null)
    {
        $request = $this->restPimAttributesNamesGetRequest($with, $attribute_id, $lang, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20045' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20045', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20045';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20045',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesNamesGetAsync
     *
     * Search attribute names
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attribute&#39; &#x3D; The attribute to the attribute name.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $attribute_id Filter restricts the result to attributes with the specified attribute ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39; (optional)
     * @param  string $lang Filter restricts the result to attributes with the specified language. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string $name Filter restricts the result to attributes with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesNamesGetAsync($with = null, $attribute_id = null, $lang = null, $name = null)
    {
        return $this->restPimAttributesNamesGetAsyncWithHttpInfo($with, $attribute_id, $lang, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesNamesGetAsyncWithHttpInfo
     *
     * Search attribute names
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attribute&#39; &#x3D; The attribute to the attribute name.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $attribute_id Filter restricts the result to attributes with the specified attribute ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39; (optional)
     * @param  string $lang Filter restricts the result to attributes with the specified language. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string $name Filter restricts the result to attributes with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesNamesGetAsyncWithHttpInfo($with = null, $attribute_id = null, $lang = null, $name = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20045';
        $request = $this->restPimAttributesNamesGetRequest($with, $attribute_id, $lang, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesNamesGet'
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attribute&#39; &#x3D; The attribute to the attribute name.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $attribute_id Filter restricts the result to attributes with the specified attribute ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39; (optional)
     * @param  string $lang Filter restricts the result to attributes with the specified language. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string $name Filter restricts the result to attributes with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimAttributesNamesGetRequest($with = null, $attribute_id = null, $lang = null, $name = null)
    {

        $resourcePath = '/rest/pim/attributes/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }
        // query params
        if (is_array($attribute_id)) {
            $attribute_id = ObjectSerializer::serializeCollection($attribute_id, '', true);
        }
        if ($attribute_id !== null) {
            $queryParams['attributeId'] = $attribute_id;
        }
        // query params
        if (is_array($lang)) {
            $lang = ObjectSerializer::serializeCollection($lang, '', true);
        }
        if ($lang !== null) {
            $queryParams['lang'] = $lang;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesNamesPost
     *
     * Create attribute names
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restPimAttributesNamesPost()
    {
        list($response) = $this->restPimAttributesNamesPostWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPimAttributesNamesPostWithHttpInfo
     *
     * Create attribute names
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesNamesPostWithHttpInfo()
    {
        $request = $this->restPimAttributesNamesPostRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesNamesPostAsync
     *
     * Create attribute names
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesNamesPostAsync()
    {
        return $this->restPimAttributesNamesPostAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesNamesPostAsyncWithHttpInfo
     *
     * Create attribute names
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesNamesPostAsyncWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->restPimAttributesNamesPostRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesNamesPost'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimAttributesNamesPostRequest()
    {

        $resourcePath = '/rest/pim/attributes/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesNamesPut
     *
     * Update attribute names
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restPimAttributesNamesPut()
    {
        list($response) = $this->restPimAttributesNamesPutWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPimAttributesNamesPutWithHttpInfo
     *
     * Update attribute names
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesNamesPutWithHttpInfo()
    {
        $request = $this->restPimAttributesNamesPutRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesNamesPutAsync
     *
     * Update attribute names
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesNamesPutAsync()
    {
        return $this->restPimAttributesNamesPutAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesNamesPutAsyncWithHttpInfo
     *
     * Update attribute names
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesNamesPutAsyncWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->restPimAttributesNamesPutRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesNamesPut'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimAttributesNamesPutRequest()
    {

        $resourcePath = '/rest/pim/attributes/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesPost
     *
     * Create attributes
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restPimAttributesPost()
    {
        list($response) = $this->restPimAttributesPostWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPimAttributesPostWithHttpInfo
     *
     * Create attributes
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesPostWithHttpInfo()
    {
        $request = $this->restPimAttributesPostRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesPostAsync
     *
     * Create attributes
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesPostAsync()
    {
        return $this->restPimAttributesPostAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesPostAsyncWithHttpInfo
     *
     * Create attributes
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesPostAsyncWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->restPimAttributesPostRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesPost'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimAttributesPostRequest()
    {

        $resourcePath = '/rest/pim/attributes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesPut
     *
     * Update attributes
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restPimAttributesPut()
    {
        list($response) = $this->restPimAttributesPutWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPimAttributesPutWithHttpInfo
     *
     * Update attributes
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesPutWithHttpInfo()
    {
        $request = $this->restPimAttributesPutRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesPutAsync
     *
     * Update attributes
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesPutAsync()
    {
        return $this->restPimAttributesPutAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesPutAsyncWithHttpInfo
     *
     * Update attributes
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesPutAsyncWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->restPimAttributesPutRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesPut'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimAttributesPutRequest()
    {

        $resourcePath = '/rest/pim/attributes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesValuesDelete
     *
     * Delete attribute values
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restPimAttributesValuesDelete()
    {
        list($response) = $this->restPimAttributesValuesDeleteWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPimAttributesValuesDeleteWithHttpInfo
     *
     * Delete attribute values
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesValuesDeleteWithHttpInfo()
    {
        $request = $this->restPimAttributesValuesDeleteRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesValuesDeleteAsync
     *
     * Delete attribute values
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesValuesDeleteAsync()
    {
        return $this->restPimAttributesValuesDeleteAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesValuesDeleteAsyncWithHttpInfo
     *
     * Delete attribute values
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesValuesDeleteAsyncWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->restPimAttributesValuesDeleteRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesValuesDelete'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimAttributesValuesDeleteRequest()
    {

        $resourcePath = '/rest/pim/attributes/values';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesValuesGet
     *
     * Search attribute values
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;valueNames&#39; &#x3D; The names of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;attribute&#39; &#x3D; The attribute of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;valueMaps&#39; &#x3D; The maps of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;valueMarketNames&#39; &#x3D; The value market names of the attribute value.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $ids Filter restricts the result to attribute values with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $attribute_id Filter restricts the result to attribute values with the specified attribute ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $backend_name Filter restricts the result to attribute values with the specified backend name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string $name Filter restricts the result to attribute values with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $position Filter restricts the result to attribute values with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $updated_at Filter restricts the result to attribute values which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20013
     */
    public function restPimAttributesValuesGet($with = null, $ids = null, $attribute_id = null, $backend_name = null, $name = null, $position = null, $updated_at = null)
    {
        list($response) = $this->restPimAttributesValuesGetWithHttpInfo($with, $ids, $attribute_id, $backend_name, $name, $position, $updated_at);
        return $response;
    }

    /**
     * Operation restPimAttributesValuesGetWithHttpInfo
     *
     * Search attribute values
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;valueNames&#39; &#x3D; The names of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;attribute&#39; &#x3D; The attribute of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;valueMaps&#39; &#x3D; The maps of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;valueMarketNames&#39; &#x3D; The value market names of the attribute value.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $ids Filter restricts the result to attribute values with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $attribute_id Filter restricts the result to attribute values with the specified attribute ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $backend_name Filter restricts the result to attribute values with the specified backend name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string $name Filter restricts the result to attribute values with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $position Filter restricts the result to attribute values with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $updated_at Filter restricts the result to attribute values which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20013, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesValuesGetWithHttpInfo($with = null, $ids = null, $attribute_id = null, $backend_name = null, $name = null, $position = null, $updated_at = null)
    {
        $request = $this->restPimAttributesValuesGetRequest($with, $ids, $attribute_id, $backend_name, $name, $position, $updated_at);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20013' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20013', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20013';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20013',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesValuesGetAsync
     *
     * Search attribute values
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;valueNames&#39; &#x3D; The names of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;attribute&#39; &#x3D; The attribute of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;valueMaps&#39; &#x3D; The maps of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;valueMarketNames&#39; &#x3D; The value market names of the attribute value.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $ids Filter restricts the result to attribute values with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $attribute_id Filter restricts the result to attribute values with the specified attribute ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $backend_name Filter restricts the result to attribute values with the specified backend name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string $name Filter restricts the result to attribute values with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $position Filter restricts the result to attribute values with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $updated_at Filter restricts the result to attribute values which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesValuesGetAsync($with = null, $ids = null, $attribute_id = null, $backend_name = null, $name = null, $position = null, $updated_at = null)
    {
        return $this->restPimAttributesValuesGetAsyncWithHttpInfo($with, $ids, $attribute_id, $backend_name, $name, $position, $updated_at)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesValuesGetAsyncWithHttpInfo
     *
     * Search attribute values
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;valueNames&#39; &#x3D; The names of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;attribute&#39; &#x3D; The attribute of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;valueMaps&#39; &#x3D; The maps of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;valueMarketNames&#39; &#x3D; The value market names of the attribute value.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $ids Filter restricts the result to attribute values with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $attribute_id Filter restricts the result to attribute values with the specified attribute ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $backend_name Filter restricts the result to attribute values with the specified backend name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string $name Filter restricts the result to attribute values with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $position Filter restricts the result to attribute values with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $updated_at Filter restricts the result to attribute values which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesValuesGetAsyncWithHttpInfo($with = null, $ids = null, $attribute_id = null, $backend_name = null, $name = null, $position = null, $updated_at = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20013';
        $request = $this->restPimAttributesValuesGetRequest($with, $ids, $attribute_id, $backend_name, $name, $position, $updated_at);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesValuesGet'
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;valueNames&#39; &#x3D; The names of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;attribute&#39; &#x3D; The attribute of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;valueMaps&#39; &#x3D; The maps of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;valueMarketNames&#39; &#x3D; The value market names of the attribute value.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $ids Filter restricts the result to attribute values with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $attribute_id Filter restricts the result to attribute values with the specified attribute ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $backend_name Filter restricts the result to attribute values with the specified backend name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string $name Filter restricts the result to attribute values with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $position Filter restricts the result to attribute values with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $updated_at Filter restricts the result to attribute values which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimAttributesValuesGetRequest($with = null, $ids = null, $attribute_id = null, $backend_name = null, $name = null, $position = null, $updated_at = null)
    {

        $resourcePath = '/rest/pim/attributes/values';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }
        // query params
        if (is_array($ids)) {
            $ids = ObjectSerializer::serializeCollection($ids, '', true);
        }
        if ($ids !== null) {
            $queryParams['ids'] = $ids;
        }
        // query params
        if (is_array($attribute_id)) {
            $attribute_id = ObjectSerializer::serializeCollection($attribute_id, '', true);
        }
        if ($attribute_id !== null) {
            $queryParams['attributeId'] = $attribute_id;
        }
        // query params
        if (is_array($backend_name)) {
            $backend_name = ObjectSerializer::serializeCollection($backend_name, '', true);
        }
        if ($backend_name !== null) {
            $queryParams['backendName'] = $backend_name;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($position)) {
            $position = ObjectSerializer::serializeCollection($position, '', true);
        }
        if ($position !== null) {
            $queryParams['position'] = $position;
        }
        // query params
        if (is_array($updated_at)) {
            $updated_at = ObjectSerializer::serializeCollection($updated_at, '', true);
        }
        if ($updated_at !== null) {
            $queryParams['updatedAt'] = $updated_at;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesValuesIdGet
     *
     * Get one attribute value
     *
     * @param  int $id id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AttributeValue
     */
    public function restPimAttributesValuesIdGet($id)
    {
        list($response) = $this->restPimAttributesValuesIdGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restPimAttributesValuesIdGetWithHttpInfo
     *
     * Get one attribute value
     *
     * @param  int $id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AttributeValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesValuesIdGetWithHttpInfo($id)
    {
        $request = $this->restPimAttributesValuesIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AttributeValue' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AttributeValue', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AttributeValue';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AttributeValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesValuesIdGetAsync
     *
     * Get one attribute value
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesValuesIdGetAsync($id)
    {
        return $this->restPimAttributesValuesIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesValuesIdGetAsyncWithHttpInfo
     *
     * Get one attribute value
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesValuesIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\OpenAPI\Client\Model\AttributeValue';
        $request = $this->restPimAttributesValuesIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesValuesIdGet'
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimAttributesValuesIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restPimAttributesValuesIdGet'
            );
        }

        $resourcePath = '/rest/pim/attributes/values/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesValuesNamesDelete
     *
     * Delete attribute value names
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restPimAttributesValuesNamesDelete()
    {
        list($response) = $this->restPimAttributesValuesNamesDeleteWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPimAttributesValuesNamesDeleteWithHttpInfo
     *
     * Delete attribute value names
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesValuesNamesDeleteWithHttpInfo()
    {
        $request = $this->restPimAttributesValuesNamesDeleteRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesValuesNamesDeleteAsync
     *
     * Delete attribute value names
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesValuesNamesDeleteAsync()
    {
        return $this->restPimAttributesValuesNamesDeleteAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesValuesNamesDeleteAsyncWithHttpInfo
     *
     * Delete attribute value names
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesValuesNamesDeleteAsyncWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->restPimAttributesValuesNamesDeleteRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesValuesNamesDelete'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimAttributesValuesNamesDeleteRequest()
    {

        $resourcePath = '/rest/pim/attributes/values/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesValuesNamesGet
     *
     * Search attribute value names
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attributeValue&#39; &#x3D; The attribute value to the attribute value name.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $value_id Filter restricts the result to attribute value names with the specified value ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39; (optional)
     * @param  string $lang Filter restricts the result to attribute value names with the specified language. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string $name Filter restricts the result to attribute value names with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20046
     */
    public function restPimAttributesValuesNamesGet($with = null, $value_id = null, $lang = null, $name = null)
    {
        list($response) = $this->restPimAttributesValuesNamesGetWithHttpInfo($with, $value_id, $lang, $name);
        return $response;
    }

    /**
     * Operation restPimAttributesValuesNamesGetWithHttpInfo
     *
     * Search attribute value names
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attributeValue&#39; &#x3D; The attribute value to the attribute value name.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $value_id Filter restricts the result to attribute value names with the specified value ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39; (optional)
     * @param  string $lang Filter restricts the result to attribute value names with the specified language. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string $name Filter restricts the result to attribute value names with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20046, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesValuesNamesGetWithHttpInfo($with = null, $value_id = null, $lang = null, $name = null)
    {
        $request = $this->restPimAttributesValuesNamesGetRequest($with, $value_id, $lang, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20046' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20046', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20046';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20046',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesValuesNamesGetAsync
     *
     * Search attribute value names
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attributeValue&#39; &#x3D; The attribute value to the attribute value name.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $value_id Filter restricts the result to attribute value names with the specified value ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39; (optional)
     * @param  string $lang Filter restricts the result to attribute value names with the specified language. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string $name Filter restricts the result to attribute value names with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesValuesNamesGetAsync($with = null, $value_id = null, $lang = null, $name = null)
    {
        return $this->restPimAttributesValuesNamesGetAsyncWithHttpInfo($with, $value_id, $lang, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesValuesNamesGetAsyncWithHttpInfo
     *
     * Search attribute value names
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attributeValue&#39; &#x3D; The attribute value to the attribute value name.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $value_id Filter restricts the result to attribute value names with the specified value ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39; (optional)
     * @param  string $lang Filter restricts the result to attribute value names with the specified language. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string $name Filter restricts the result to attribute value names with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesValuesNamesGetAsyncWithHttpInfo($with = null, $value_id = null, $lang = null, $name = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20046';
        $request = $this->restPimAttributesValuesNamesGetRequest($with, $value_id, $lang, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesValuesNamesGet'
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attributeValue&#39; &#x3D; The attribute value to the attribute value name.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $value_id Filter restricts the result to attribute value names with the specified value ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39; (optional)
     * @param  string $lang Filter restricts the result to attribute value names with the specified language. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string $name Filter restricts the result to attribute value names with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimAttributesValuesNamesGetRequest($with = null, $value_id = null, $lang = null, $name = null)
    {

        $resourcePath = '/rest/pim/attributes/values/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }
        // query params
        if (is_array($value_id)) {
            $value_id = ObjectSerializer::serializeCollection($value_id, '', true);
        }
        if ($value_id !== null) {
            $queryParams['valueId'] = $value_id;
        }
        // query params
        if (is_array($lang)) {
            $lang = ObjectSerializer::serializeCollection($lang, '', true);
        }
        if ($lang !== null) {
            $queryParams['lang'] = $lang;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesValuesNamesPost
     *
     * Create attribute value names
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restPimAttributesValuesNamesPost()
    {
        list($response) = $this->restPimAttributesValuesNamesPostWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPimAttributesValuesNamesPostWithHttpInfo
     *
     * Create attribute value names
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesValuesNamesPostWithHttpInfo()
    {
        $request = $this->restPimAttributesValuesNamesPostRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesValuesNamesPostAsync
     *
     * Create attribute value names
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesValuesNamesPostAsync()
    {
        return $this->restPimAttributesValuesNamesPostAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesValuesNamesPostAsyncWithHttpInfo
     *
     * Create attribute value names
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesValuesNamesPostAsyncWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->restPimAttributesValuesNamesPostRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesValuesNamesPost'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimAttributesValuesNamesPostRequest()
    {

        $resourcePath = '/rest/pim/attributes/values/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesValuesNamesPut
     *
     * Update attribute value names
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restPimAttributesValuesNamesPut()
    {
        list($response) = $this->restPimAttributesValuesNamesPutWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPimAttributesValuesNamesPutWithHttpInfo
     *
     * Update attribute value names
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesValuesNamesPutWithHttpInfo()
    {
        $request = $this->restPimAttributesValuesNamesPutRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesValuesNamesPutAsync
     *
     * Update attribute value names
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesValuesNamesPutAsync()
    {
        return $this->restPimAttributesValuesNamesPutAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesValuesNamesPutAsyncWithHttpInfo
     *
     * Update attribute value names
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesValuesNamesPutAsyncWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->restPimAttributesValuesNamesPutRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesValuesNamesPut'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimAttributesValuesNamesPutRequest()
    {

        $resourcePath = '/rest/pim/attributes/values/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesValuesPost
     *
     * Create attribute values
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restPimAttributesValuesPost()
    {
        list($response) = $this->restPimAttributesValuesPostWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPimAttributesValuesPostWithHttpInfo
     *
     * Create attribute values
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesValuesPostWithHttpInfo()
    {
        $request = $this->restPimAttributesValuesPostRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesValuesPostAsync
     *
     * Create attribute values
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesValuesPostAsync()
    {
        return $this->restPimAttributesValuesPostAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesValuesPostAsyncWithHttpInfo
     *
     * Create attribute values
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesValuesPostAsyncWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->restPimAttributesValuesPostRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesValuesPost'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimAttributesValuesPostRequest()
    {

        $resourcePath = '/rest/pim/attributes/values';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesValuesPut
     *
     * Update attribute values
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restPimAttributesValuesPut()
    {
        list($response) = $this->restPimAttributesValuesPutWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPimAttributesValuesPutWithHttpInfo
     *
     * Update attribute values
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesValuesPutWithHttpInfo()
    {
        $request = $this->restPimAttributesValuesPutRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesValuesPutAsync
     *
     * Update attribute values
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesValuesPutAsync()
    {
        return $this->restPimAttributesValuesPutAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesValuesPutAsyncWithHttpInfo
     *
     * Update attribute values
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimAttributesValuesPutAsyncWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->restPimAttributesValuesPutRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesValuesPut'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimAttributesValuesPutRequest()
    {

        $resourcePath = '/rest/pim/attributes/values';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimCategoriesBranchesGet
     *
     * Search category branches
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category branch.&lt;/li&gt;&lt;/ub&gt; (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20047
     */
    public function restPimCategoriesBranchesGet($with = null)
    {
        list($response) = $this->restPimCategoriesBranchesGetWithHttpInfo($with);
        return $response;
    }

    /**
     * Operation restPimCategoriesBranchesGetWithHttpInfo
     *
     * Search category branches
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category branch.&lt;/li&gt;&lt;/ub&gt; (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20047, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimCategoriesBranchesGetWithHttpInfo($with = null)
    {
        $request = $this->restPimCategoriesBranchesGetRequest($with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20047' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20047', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20047';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20047',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimCategoriesBranchesGetAsync
     *
     * Search category branches
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category branch.&lt;/li&gt;&lt;/ub&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimCategoriesBranchesGetAsync($with = null)
    {
        return $this->restPimCategoriesBranchesGetAsyncWithHttpInfo($with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimCategoriesBranchesGetAsyncWithHttpInfo
     *
     * Search category branches
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category branch.&lt;/li&gt;&lt;/ub&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimCategoriesBranchesGetAsyncWithHttpInfo($with = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20047';
        $request = $this->restPimCategoriesBranchesGetRequest($with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimCategoriesBranchesGet'
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category branch.&lt;/li&gt;&lt;/ub&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimCategoriesBranchesGetRequest($with = null)
    {

        $resourcePath = '/rest/pim/categories/branches';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimCategoriesClientsGet
     *
     * Search category clients
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category client.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $category_id Filter restricts the result to category clients with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int $plenty_id Filter restricts the result to category clients with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20048
     */
    public function restPimCategoriesClientsGet($with = null, $category_id = null, $plenty_id = null)
    {
        list($response) = $this->restPimCategoriesClientsGetWithHttpInfo($with, $category_id, $plenty_id);
        return $response;
    }

    /**
     * Operation restPimCategoriesClientsGetWithHttpInfo
     *
     * Search category clients
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category client.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $category_id Filter restricts the result to category clients with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int $plenty_id Filter restricts the result to category clients with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20048, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimCategoriesClientsGetWithHttpInfo($with = null, $category_id = null, $plenty_id = null)
    {
        $request = $this->restPimCategoriesClientsGetRequest($with, $category_id, $plenty_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20048' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20048', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20048';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20048',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimCategoriesClientsGetAsync
     *
     * Search category clients
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category client.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $category_id Filter restricts the result to category clients with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int $plenty_id Filter restricts the result to category clients with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimCategoriesClientsGetAsync($with = null, $category_id = null, $plenty_id = null)
    {
        return $this->restPimCategoriesClientsGetAsyncWithHttpInfo($with, $category_id, $plenty_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimCategoriesClientsGetAsyncWithHttpInfo
     *
     * Search category clients
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category client.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $category_id Filter restricts the result to category clients with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int $plenty_id Filter restricts the result to category clients with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimCategoriesClientsGetAsyncWithHttpInfo($with = null, $category_id = null, $plenty_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20048';
        $request = $this->restPimCategoriesClientsGetRequest($with, $category_id, $plenty_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimCategoriesClientsGet'
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category client.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $category_id Filter restricts the result to category clients with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int $plenty_id Filter restricts the result to category clients with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimCategoriesClientsGetRequest($with = null, $category_id = null, $plenty_id = null)
    {

        $resourcePath = '/rest/pim/categories/clients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }
        // query params
        if (is_array($category_id)) {
            $category_id = ObjectSerializer::serializeCollection($category_id, '', true);
        }
        if ($category_id !== null) {
            $queryParams['categoryId'] = $category_id;
        }
        // query params
        if (is_array($plenty_id)) {
            $plenty_id = ObjectSerializer::serializeCollection($plenty_id, '', true);
        }
        if ($plenty_id !== null) {
            $queryParams['plentyId'] = $plenty_id;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimCategoriesDetailsGet
     *
     * Search category details
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category detail.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $category_id Filter restricts the result to category details with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int $plenty_id Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $lang Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  string $name Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;like&#39;. (optional)
     * @param  string $position Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20049
     */
    public function restPimCategoriesDetailsGet($with = null, $category_id = null, $plenty_id = null, $lang = null, $name = null, $position = null)
    {
        list($response) = $this->restPimCategoriesDetailsGetWithHttpInfo($with, $category_id, $plenty_id, $lang, $name, $position);
        return $response;
    }

    /**
     * Operation restPimCategoriesDetailsGetWithHttpInfo
     *
     * Search category details
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category detail.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $category_id Filter restricts the result to category details with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int $plenty_id Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $lang Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  string $name Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;like&#39;. (optional)
     * @param  string $position Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20049, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimCategoriesDetailsGetWithHttpInfo($with = null, $category_id = null, $plenty_id = null, $lang = null, $name = null, $position = null)
    {
        $request = $this->restPimCategoriesDetailsGetRequest($with, $category_id, $plenty_id, $lang, $name, $position);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20049' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20049', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20049';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20049',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimCategoriesDetailsGetAsync
     *
     * Search category details
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category detail.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $category_id Filter restricts the result to category details with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int $plenty_id Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $lang Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  string $name Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;like&#39;. (optional)
     * @param  string $position Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimCategoriesDetailsGetAsync($with = null, $category_id = null, $plenty_id = null, $lang = null, $name = null, $position = null)
    {
        return $this->restPimCategoriesDetailsGetAsyncWithHttpInfo($with, $category_id, $plenty_id, $lang, $name, $position)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimCategoriesDetailsGetAsyncWithHttpInfo
     *
     * Search category details
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category detail.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $category_id Filter restricts the result to category details with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int $plenty_id Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $lang Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  string $name Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;like&#39;. (optional)
     * @param  string $position Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimCategoriesDetailsGetAsyncWithHttpInfo($with = null, $category_id = null, $plenty_id = null, $lang = null, $name = null, $position = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20049';
        $request = $this->restPimCategoriesDetailsGetRequest($with, $category_id, $plenty_id, $lang, $name, $position);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimCategoriesDetailsGet'
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category detail.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $category_id Filter restricts the result to category details with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int $plenty_id Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $lang Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  string $name Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;like&#39;. (optional)
     * @param  string $position Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimCategoriesDetailsGetRequest($with = null, $category_id = null, $plenty_id = null, $lang = null, $name = null, $position = null)
    {

        $resourcePath = '/rest/pim/categories/details';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }
        // query params
        if (is_array($category_id)) {
            $category_id = ObjectSerializer::serializeCollection($category_id, '', true);
        }
        if ($category_id !== null) {
            $queryParams['categoryId'] = $category_id;
        }
        // query params
        if (is_array($plenty_id)) {
            $plenty_id = ObjectSerializer::serializeCollection($plenty_id, '', true);
        }
        if ($plenty_id !== null) {
            $queryParams['plentyId'] = $plenty_id;
        }
        // query params
        if (is_array($lang)) {
            $lang = ObjectSerializer::serializeCollection($lang, '', true);
        }
        if ($lang !== null) {
            $queryParams['lang'] = $lang;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($position)) {
            $position = ObjectSerializer::serializeCollection($position, '', true);
        }
        if ($position !== null) {
            $queryParams['position'] = $position;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimCategoriesGet
     *
     * Search categories
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;details&#39; &#x3D; The names of the category.&lt;/li&gt;&lt;li&gt; &#39;clients&#39; &#x3D; The clients of the category.&lt;/li&gt;&lt;li&gt; &#39;branch&#39; &#x3D; The branch of the category.&lt;/li&gt;&lt;li&gt; &#39;tagRelationship&#39; &#x3D; The tags linked with the category and their data.&lt;/li&gt;&lt;li&gt; &#39;elmarCategories&#39; &#x3D; The elmar categories of the category.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $ids Filter restricts the result to categories with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $type Filter restricts the result to categories with the specified type. Allowed comparators: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  int $level Filter restricts the result to categories with the specified level. Allowed comparators: &#39;eq&#39;, &#39;not&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $name Filter restricts the result to categories with a category detail in the specified name. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $lang Filter restricts the result to categories with a category detail in the specified lang. Allowed comparators: &#39;eq&#39; and &#39;not&#39;. (optional)
     * @param  int $parent_id Filter restricts the result to categories with the specified parent ID. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  int $plenty_id Filter restricts the result to categories with the specified plenty ID. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  bool $linklist Filter restricts the result to categories with the specified linklist value. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  string $tag_id Filter restricts the result to categories with the specified tag id. Allowed comparator: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  string $updated_at Filter restricts the result to categories which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse2006
     */
    public function restPimCategoriesGet($with = null, $ids = null, $type = null, $level = null, $name = null, $lang = null, $parent_id = null, $plenty_id = null, $linklist = null, $tag_id = null, $updated_at = null)
    {
        list($response) = $this->restPimCategoriesGetWithHttpInfo($with, $ids, $type, $level, $name, $lang, $parent_id, $plenty_id, $linklist, $tag_id, $updated_at);
        return $response;
    }

    /**
     * Operation restPimCategoriesGetWithHttpInfo
     *
     * Search categories
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;details&#39; &#x3D; The names of the category.&lt;/li&gt;&lt;li&gt; &#39;clients&#39; &#x3D; The clients of the category.&lt;/li&gt;&lt;li&gt; &#39;branch&#39; &#x3D; The branch of the category.&lt;/li&gt;&lt;li&gt; &#39;tagRelationship&#39; &#x3D; The tags linked with the category and their data.&lt;/li&gt;&lt;li&gt; &#39;elmarCategories&#39; &#x3D; The elmar categories of the category.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $ids Filter restricts the result to categories with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $type Filter restricts the result to categories with the specified type. Allowed comparators: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  int $level Filter restricts the result to categories with the specified level. Allowed comparators: &#39;eq&#39;, &#39;not&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $name Filter restricts the result to categories with a category detail in the specified name. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $lang Filter restricts the result to categories with a category detail in the specified lang. Allowed comparators: &#39;eq&#39; and &#39;not&#39;. (optional)
     * @param  int $parent_id Filter restricts the result to categories with the specified parent ID. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  int $plenty_id Filter restricts the result to categories with the specified plenty ID. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  bool $linklist Filter restricts the result to categories with the specified linklist value. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  string $tag_id Filter restricts the result to categories with the specified tag id. Allowed comparator: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  string $updated_at Filter restricts the result to categories which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse2006, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimCategoriesGetWithHttpInfo($with = null, $ids = null, $type = null, $level = null, $name = null, $lang = null, $parent_id = null, $plenty_id = null, $linklist = null, $tag_id = null, $updated_at = null)
    {
        $request = $this->restPimCategoriesGetRequest($with, $ids, $type, $level, $name, $lang, $parent_id, $plenty_id, $linklist, $tag_id, $updated_at);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse2006' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse2006', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse2006';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse2006',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimCategoriesGetAsync
     *
     * Search categories
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;details&#39; &#x3D; The names of the category.&lt;/li&gt;&lt;li&gt; &#39;clients&#39; &#x3D; The clients of the category.&lt;/li&gt;&lt;li&gt; &#39;branch&#39; &#x3D; The branch of the category.&lt;/li&gt;&lt;li&gt; &#39;tagRelationship&#39; &#x3D; The tags linked with the category and their data.&lt;/li&gt;&lt;li&gt; &#39;elmarCategories&#39; &#x3D; The elmar categories of the category.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $ids Filter restricts the result to categories with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $type Filter restricts the result to categories with the specified type. Allowed comparators: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  int $level Filter restricts the result to categories with the specified level. Allowed comparators: &#39;eq&#39;, &#39;not&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $name Filter restricts the result to categories with a category detail in the specified name. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $lang Filter restricts the result to categories with a category detail in the specified lang. Allowed comparators: &#39;eq&#39; and &#39;not&#39;. (optional)
     * @param  int $parent_id Filter restricts the result to categories with the specified parent ID. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  int $plenty_id Filter restricts the result to categories with the specified plenty ID. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  bool $linklist Filter restricts the result to categories with the specified linklist value. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  string $tag_id Filter restricts the result to categories with the specified tag id. Allowed comparator: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  string $updated_at Filter restricts the result to categories which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimCategoriesGetAsync($with = null, $ids = null, $type = null, $level = null, $name = null, $lang = null, $parent_id = null, $plenty_id = null, $linklist = null, $tag_id = null, $updated_at = null)
    {
        return $this->restPimCategoriesGetAsyncWithHttpInfo($with, $ids, $type, $level, $name, $lang, $parent_id, $plenty_id, $linklist, $tag_id, $updated_at)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimCategoriesGetAsyncWithHttpInfo
     *
     * Search categories
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;details&#39; &#x3D; The names of the category.&lt;/li&gt;&lt;li&gt; &#39;clients&#39; &#x3D; The clients of the category.&lt;/li&gt;&lt;li&gt; &#39;branch&#39; &#x3D; The branch of the category.&lt;/li&gt;&lt;li&gt; &#39;tagRelationship&#39; &#x3D; The tags linked with the category and their data.&lt;/li&gt;&lt;li&gt; &#39;elmarCategories&#39; &#x3D; The elmar categories of the category.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $ids Filter restricts the result to categories with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $type Filter restricts the result to categories with the specified type. Allowed comparators: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  int $level Filter restricts the result to categories with the specified level. Allowed comparators: &#39;eq&#39;, &#39;not&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $name Filter restricts the result to categories with a category detail in the specified name. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $lang Filter restricts the result to categories with a category detail in the specified lang. Allowed comparators: &#39;eq&#39; and &#39;not&#39;. (optional)
     * @param  int $parent_id Filter restricts the result to categories with the specified parent ID. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  int $plenty_id Filter restricts the result to categories with the specified plenty ID. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  bool $linklist Filter restricts the result to categories with the specified linklist value. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  string $tag_id Filter restricts the result to categories with the specified tag id. Allowed comparator: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  string $updated_at Filter restricts the result to categories which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimCategoriesGetAsyncWithHttpInfo($with = null, $ids = null, $type = null, $level = null, $name = null, $lang = null, $parent_id = null, $plenty_id = null, $linklist = null, $tag_id = null, $updated_at = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse2006';
        $request = $this->restPimCategoriesGetRequest($with, $ids, $type, $level, $name, $lang, $parent_id, $plenty_id, $linklist, $tag_id, $updated_at);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimCategoriesGet'
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;details&#39; &#x3D; The names of the category.&lt;/li&gt;&lt;li&gt; &#39;clients&#39; &#x3D; The clients of the category.&lt;/li&gt;&lt;li&gt; &#39;branch&#39; &#x3D; The branch of the category.&lt;/li&gt;&lt;li&gt; &#39;tagRelationship&#39; &#x3D; The tags linked with the category and their data.&lt;/li&gt;&lt;li&gt; &#39;elmarCategories&#39; &#x3D; The elmar categories of the category.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $ids Filter restricts the result to categories with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $type Filter restricts the result to categories with the specified type. Allowed comparators: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  int $level Filter restricts the result to categories with the specified level. Allowed comparators: &#39;eq&#39;, &#39;not&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $name Filter restricts the result to categories with a category detail in the specified name. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $lang Filter restricts the result to categories with a category detail in the specified lang. Allowed comparators: &#39;eq&#39; and &#39;not&#39;. (optional)
     * @param  int $parent_id Filter restricts the result to categories with the specified parent ID. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  int $plenty_id Filter restricts the result to categories with the specified plenty ID. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  bool $linklist Filter restricts the result to categories with the specified linklist value. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  string $tag_id Filter restricts the result to categories with the specified tag id. Allowed comparator: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  string $updated_at Filter restricts the result to categories which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimCategoriesGetRequest($with = null, $ids = null, $type = null, $level = null, $name = null, $lang = null, $parent_id = null, $plenty_id = null, $linklist = null, $tag_id = null, $updated_at = null)
    {

        $resourcePath = '/rest/pim/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }
        // query params
        if (is_array($ids)) {
            $ids = ObjectSerializer::serializeCollection($ids, '', true);
        }
        if ($ids !== null) {
            $queryParams['ids'] = $ids;
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($level)) {
            $level = ObjectSerializer::serializeCollection($level, '', true);
        }
        if ($level !== null) {
            $queryParams['level'] = $level;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($lang)) {
            $lang = ObjectSerializer::serializeCollection($lang, '', true);
        }
        if ($lang !== null) {
            $queryParams['lang'] = $lang;
        }
        // query params
        if (is_array($parent_id)) {
            $parent_id = ObjectSerializer::serializeCollection($parent_id, '', true);
        }
        if ($parent_id !== null) {
            $queryParams['parentId'] = $parent_id;
        }
        // query params
        if (is_array($plenty_id)) {
            $plenty_id = ObjectSerializer::serializeCollection($plenty_id, '', true);
        }
        if ($plenty_id !== null) {
            $queryParams['plentyId'] = $plenty_id;
        }
        // query params
        if (is_array($linklist)) {
            $linklist = ObjectSerializer::serializeCollection($linklist, '', true);
        }
        if ($linklist !== null) {
            $queryParams['linklist'] = $linklist;
        }
        // query params
        if (is_array($tag_id)) {
            $tag_id = ObjectSerializer::serializeCollection($tag_id, '', true);
        }
        if ($tag_id !== null) {
            $queryParams['tagId'] = $tag_id;
        }
        // query params
        if (is_array($updated_at)) {
            $updated_at = ObjectSerializer::serializeCollection($updated_at, '', true);
        }
        if ($updated_at !== null) {
            $queryParams['updatedAt'] = $updated_at;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimCategoriesIdGet
     *
     * Get one category
     *
     * @param  int $id id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Category
     */
    public function restPimCategoriesIdGet($id)
    {
        list($response) = $this->restPimCategoriesIdGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restPimCategoriesIdGetWithHttpInfo
     *
     * Get one category
     *
     * @param  int $id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Category, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimCategoriesIdGetWithHttpInfo($id)
    {
        $request = $this->restPimCategoriesIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Category' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Category', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Category';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Category',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimCategoriesIdGetAsync
     *
     * Get one category
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimCategoriesIdGetAsync($id)
    {
        return $this->restPimCategoriesIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimCategoriesIdGetAsyncWithHttpInfo
     *
     * Get one category
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimCategoriesIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\OpenAPI\Client\Model\Category';
        $request = $this->restPimCategoriesIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimCategoriesIdGet'
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimCategoriesIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restPimCategoriesIdGet'
            );
        }

        $resourcePath = '/rest/pim/categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimCategoriesPropertiesGet
     *
     * Search category properties
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the property.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $category_id Filter restricts the result to category properties with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int $plenty_id Filter restricts the result to category properties with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $value Filter restricts the result to category properties with the specified value. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20050
     */
    public function restPimCategoriesPropertiesGet($with = null, $category_id = null, $plenty_id = null, $value = null)
    {
        list($response) = $this->restPimCategoriesPropertiesGetWithHttpInfo($with, $category_id, $plenty_id, $value);
        return $response;
    }

    /**
     * Operation restPimCategoriesPropertiesGetWithHttpInfo
     *
     * Search category properties
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the property.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $category_id Filter restricts the result to category properties with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int $plenty_id Filter restricts the result to category properties with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $value Filter restricts the result to category properties with the specified value. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20050, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimCategoriesPropertiesGetWithHttpInfo($with = null, $category_id = null, $plenty_id = null, $value = null)
    {
        $request = $this->restPimCategoriesPropertiesGetRequest($with, $category_id, $plenty_id, $value);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20050' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20050', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20050';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20050',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimCategoriesPropertiesGetAsync
     *
     * Search category properties
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the property.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $category_id Filter restricts the result to category properties with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int $plenty_id Filter restricts the result to category properties with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $value Filter restricts the result to category properties with the specified value. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimCategoriesPropertiesGetAsync($with = null, $category_id = null, $plenty_id = null, $value = null)
    {
        return $this->restPimCategoriesPropertiesGetAsyncWithHttpInfo($with, $category_id, $plenty_id, $value)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimCategoriesPropertiesGetAsyncWithHttpInfo
     *
     * Search category properties
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the property.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $category_id Filter restricts the result to category properties with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int $plenty_id Filter restricts the result to category properties with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $value Filter restricts the result to category properties with the specified value. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimCategoriesPropertiesGetAsyncWithHttpInfo($with = null, $category_id = null, $plenty_id = null, $value = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20050';
        $request = $this->restPimCategoriesPropertiesGetRequest($with, $category_id, $plenty_id, $value);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimCategoriesPropertiesGet'
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the property.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $category_id Filter restricts the result to category properties with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int $plenty_id Filter restricts the result to category properties with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $value Filter restricts the result to category properties with the specified value. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimCategoriesPropertiesGetRequest($with = null, $category_id = null, $plenty_id = null, $value = null)
    {

        $resourcePath = '/rest/pim/categories/properties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }
        // query params
        if (is_array($category_id)) {
            $category_id = ObjectSerializer::serializeCollection($category_id, '', true);
        }
        if ($category_id !== null) {
            $queryParams['categoryId'] = $category_id;
        }
        // query params
        if (is_array($plenty_id)) {
            $plenty_id = ObjectSerializer::serializeCollection($plenty_id, '', true);
        }
        if ($plenty_id !== null) {
            $queryParams['plentyId'] = $plenty_id;
        }
        // query params
        if (is_array($value)) {
            $value = ObjectSerializer::serializeCollection($value, '', true);
        }
        if ($value !== null) {
            $queryParams['value'] = $value;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimVariationsGet
     *
     * Lists variations
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;additionalSkus&#39; &#x3D; The additional skus of the variation.&lt;/li&gt;&lt;li&gt;&#39;attributeValues&#39; &#x3D; The attribute values of the variation.&lt;/li&gt;&lt;li&gt;&#39;attributeValues.attribute&#39;/b&gt; &#x3D; Includes attributeValues. The attribute data to the related attribute ID.&lt;/li&gt;&lt;li&gt;&#39;attributeValues.attributeValue&#39; &#x3D; Includes attributeValues. The attribute value data to the related attribute value ID.&lt;/li&gt;&lt;li&gt;&#39;barcodes&#39; &#x3D; The barcodes of the variation.&lt;/li&gt;&lt;li&gt;&#39;barcodes.barcode&#39; &#x3D; Includes barcodes. The barcode data to the related barcode ID.&lt;/li&gt;&lt;li&gt;&#39;base&#39; &#x3D; The variation base.&lt;/li&gt;&lt;li&gt;&#39;base.item&#39; &#x3D; Includes base. The item data of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.itemSerialNumber&#39; &#x3D; Includes base. The item serial numbers of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.feedback&#39; &#x3D; Includes base. The feedback of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.characteristics&#39; &#x3D; Includes base. The characteristics of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.crossSelling&#39; &#x3D; Includes base. The cross selling items of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.texts&#39; &#x3D; Includes base. The texts of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.availability&#39; &#x3D; Includes base. The availability data related to the variation&#39;s availability ID.&lt;/li&gt;&lt;li&gt;&#39;base.images&#39; &#x3D; Includes base. The images linked to the item.&lt;/li&gt;&lt;li&gt;&#39;base.shippingProfiles&#39; &#x3D; Includes base. The shipping profiles linked to the item.&lt;/li&gt;&lt;li&gt;&#39;base.stock&#39; &#x3D; Includes base. The stock of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.stockStorageLocations&#39; &#x3D; Includes base. The stock storage locations of the variation.&lt;/li&gt;&lt;li&gt;&#39;bundleComponents&#39; &#x3D; The bundle components of the variation.&lt;/li&gt;&lt;li&gt;&#39;categories&#39; &#x3D; The categories of the variation.&lt;/li&gt;&lt;li&gt;&#39;categories.category&#39; &#x3D; Includes categories. The related category data for each category ID.&lt;/li&gt;&lt;li&gt;&#39;categories.categoryBranch&#39; &#x3D; Includes categories. The related category branch data for each category ID.&lt;/li&gt;&lt;li&gt;&#39;clients&#39; &#x3D; The clients of the variation.&lt;/li&gt;&lt;li&gt;&#39;defaultCategories&#39; &#x3D; The default categories of the variation&lt;/li&gt;&lt;li&gt;&#39;defaultCategories.category&#39; &#x3D; Includes defaultCategories. The category data to the related category ID.&lt;/li&gt;&lt;li&gt;&#39;images&#39; &#x3D; The images of the variation&lt;/li&gt;&lt;li&gt;&#39;images.image&#39; &#x3D; Includes images. The image data to the related image ID.&lt;/li&gt;&lt;li&gt;&#39;markets&#39; &#x3D; The markets of the variation.&lt;/li&gt;&lt;li&gt;&#39;marketIdentNumbers&#39; &#x3D; The market ident numbers of the variation&lt;/li&gt;&lt;li&gt;&#39;salesPrices&#39; &#x3D; The sales prices of the variation.&lt;/li&gt;&lt;li&gt;&#39;salesPrices.salesPrice&#39; &#x3D; Includes salesPrices. The sales price data to the related sales price ID.&lt;/li&gt;&lt;li&gt;&#39;skus&#39; &#x3D; The skus of the variation.&lt;/li&gt;&lt;li&gt;&#39;supplier&#39; &#x3D; The supplier of the variation.&lt;/li&gt;&lt;li&gt;&#39;supplier.supplier&#39; &#x3D; Includes supplier. The contact data to the related supplier ID.&lt;/li&gt;&lt;li&gt;&#39;timestamps&#39; &#x3D; The timetamps of the variation.&lt;/li&gt;&lt;li&gt;&#39;warehouses&#39; &#x3D; The warehouses of the variation&lt;/li&gt;&lt;li&gt;&#39;warehouses.warehouse&#39; &#x3D; Includes warehouses. The warehouse data to the related warehouse ID.&lt;/li&gt;&lt;li&gt;&#39;unit&#39; &#x3D; The unit of the variation&lt;/li&gt;&lt;li&gt;&#39;unit.unit&#39; &#x3D; Includes unit. The unit data of the related unit ID.&lt;/li&gt;&lt;li&gt;&#39;tags&#39; &#x3D; The tags of the variation.&lt;/li&gt;&lt;li&gt;&#39;tags.tag&#39; &#x3D; Includes tags. The tag data to the related tag ID.&lt;/li&gt;&lt;li&gt;&#39;properties&#39; &#x3D; The properties of the variation.&lt;/li&gt;&lt;li&gt;&#39;properties.property&#39; &#x3D; Includes properties. The property data to the related property ID.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $sort_by Sorts the results. Append &#39;_asc&#39; or &#39;_desc&#39; to specify the sorting order. &#39;_desc&#39; is the default value if no other is specified. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;id&#39;&lt;/li&gt;&lt;li&gt;&#39;itemId&#39;&lt;/li&gt;&lt;li&gt;&#39;isMain&#39;&lt;/li&gt;&lt;li&gt;&#39;position&#39;&lt;/li&gt;&lt;li&gt;&#39;availabilityId&#39;&lt;/li&gt;&lt;li&gt;&#39;createdAt&#39;&lt;/li&gt;&lt;li&gt;&#39;updatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;itemUpdatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;relatedUpdatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;variationName&#39;&lt;/li&gt;&lt;li&gt;&#39;number&#39;&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $group_by Groups the result. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;itemId&#39; &#x3D; Groups the result by the item ID.&lt;/li&gt;&lt;li&gt;&#39;itemAttributeValue&#39; &#x3D; Groups the result by the attribute with the flag &#39;isGroupable&#39;.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $ids Filter restricts the list of results to variations with the specified IDs. More than one parameter should be separated by commas. (optional)
     * @param  int $item_id Filter restricts the list of results to variations with the specified item ID. (optional)
     * @param  string $item_ids Filter restricts the list of results to variations with the specified item IDs. More than one parameter should be separated by commas. (optional)
     * @param  bool $is_active Filter restricts the list of results to variations which are active/inactive. (optional)
     * @param  bool $is_main Filter restricts the list of results to variations which are main/not main. (optional)
     * @param  bool $is_salable Filter restricts the list of results to variations which are salable. (optional)
     * @param  int $supplier_id Filter restricts the list of results to variations which have the given supplier ID. (optional)
     * @param  string $availability_ids Filter restricts the list of results to variations with the specified availability IDs. More than one parameter should be separated by commas. (optional)
     * @param  bool $has_children Filter restricts the list of results to variations which have children. (optional)
     * @param  bool $has_active_children Filter restricts the list of results to variations which have active children. (optional)
     * @param  int $attribute_id Filter restricts the list of results to variations which have the specified attribute ID. (optional)
     * @param  string $any_attribute_id Filter restricts the list of results to variations which have any of the specified attribute IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $all_attribute_ids Filter restricts the list of results to variations which have all specified attribute IDs. More than one parameter should be separated by commas. (optional)
     * @param  int $attribute_value_id Filter restricts the list of results to variations which have the specified attribute value ID. (optional)
     * @param  string $any_attribute_value_id Filter restricts the list of results to variations which have the any of the specified attribute value IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $all_attribute_value_ids Filter restricts the list of results to variations which have all specified attribute value IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $barcode_code Filter restricts the list of results to variations which have a barcode with the specified code. (optional)
     * @param  int $barcode_id Filter restricts the list of results to variations which have a barcode with the specified ID. (optional)
     * @param  string $bundle_type Filter restricts the list of results to variations with the specified bundle type. (optional)
     * @param  int $category_id Filter restricts the list of results to variations which have the specified category ID. (optional)
     * @param  string $any_category_id Filter restricts the list of results to variations which have any of the specified category IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $all_category_ids Filter restricts the list of results to variations which have all specified category IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $any_characteristic_id Filter restricts the list of results to variations which have any of the specified characteristic IDs. (optional)
     * @param  string $all_characteristic_ids Filter restricts the list of results to variations which have all specified characteristic IDs. (optional)
     * @param  int $client_id Filter restricts the list of results to variations which have the specified client ID. (optional)
     * @param  string $any_client_id Filter restricts the list of results to variations which have any of the specified client IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $all_client_ids Filter restricts the list of results to variations which have all specified client IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $automatic_client_visibilities Filter restricts the list of results to variations which have any of the specified automatic client visibilities. More than one parameter should be separated by commas. (optional)
     * @param  float $image_has_market_id Filter restricts the list of results to variations which have an image available for the specified market ID. (optional)
     * @param  int $flag1 Filter restricts the list of results to variations with the specified flag one. (optional)
     * @param  int $flag2 Filter restricts the list of results to variations with the specified flag two. (optional)
     * @param  int $manufacturer_id Filter restricts the list of results to variations with the specified manufacturer ID. (optional)
     * @param  string $any_manufacturer_id Filter restricts the list of results to variations with any of the specified manufacturer IDs. (optional)
     * @param  string $item_type Filter restricts the list of results to variations which have the specified item type. (optional)
     * @param  float $market_id Filter restricts the list of results to variations which have the specified market ID. (optional)
     * @param  string $any_market_id Filter restricts the list of results to variations which have any of the specified market IDs. (optional)
     * @param  string $all_market_ids Filter restricts the list of results to variations which have all specified market IDs. (optional)
     * @param  string $price_between Filter restricts the list of results to variations which have a sales price between the specified minimum and maximum value. Minimum and maximum value should be separated by a comma. (optional)
     * @param  string $price_between_by_id Filter restricts the list of results to variations where the specified sales price is between the specified minimum and maximum value. Sales price ID, Minimum and maximum value should be separated by a comma. (optional)
     * @param  string $any_sales_price_id Filter restricts the list of results to variations which have any of the specified sales price IDs. More than one parameter should be separated by commas. (optional)
     * @param  int $property_selection_id Filter restricts the list of results to variations which have the specified property selection ID. (optional)
     * @param  string $any_property_selection_id Filter restricts the list of results to variations which have any of the specified property selection IDs. (optional)
     * @param  string $all_property_selection_ids Filter restricts the list of results to variations which have all specified property selection IDs. (optional)
     * @param  string $has_name_in_language Filter restricts the list of results to variations which have a name in the specified language. (optional)
     * @param  string $created_at Filter restricts the list of results to variations which have been created in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $updated_at Filter restricts the list of results to variations which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $item_created_at Filter restricts the list of results to variations whose item has been created in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $item_updated_at Filter restricts the list of results to variations whose item has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $availability_updated_at Filter restricts the list of results to variations whose availablity has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $stock_updated_at Filter restricts the list of results to variations whose stock has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  int $page The requested page of results. Default value is 1. (optional)
     * @param  int $items_per_page The number of results per page. Maximum value is 250. Default value is 50. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20020
     */
    public function restPimVariationsGet($with = null, $sort_by = null, $group_by = null, $ids = null, $item_id = null, $item_ids = null, $is_active = null, $is_main = null, $is_salable = null, $supplier_id = null, $availability_ids = null, $has_children = null, $has_active_children = null, $attribute_id = null, $any_attribute_id = null, $all_attribute_ids = null, $attribute_value_id = null, $any_attribute_value_id = null, $all_attribute_value_ids = null, $barcode_code = null, $barcode_id = null, $bundle_type = null, $category_id = null, $any_category_id = null, $all_category_ids = null, $any_characteristic_id = null, $all_characteristic_ids = null, $client_id = null, $any_client_id = null, $all_client_ids = null, $automatic_client_visibilities = null, $image_has_market_id = null, $flag1 = null, $flag2 = null, $manufacturer_id = null, $any_manufacturer_id = null, $item_type = null, $market_id = null, $any_market_id = null, $all_market_ids = null, $price_between = null, $price_between_by_id = null, $any_sales_price_id = null, $property_selection_id = null, $any_property_selection_id = null, $all_property_selection_ids = null, $has_name_in_language = null, $created_at = null, $updated_at = null, $item_created_at = null, $item_updated_at = null, $availability_updated_at = null, $stock_updated_at = null, $page = null, $items_per_page = null)
    {
        list($response) = $this->restPimVariationsGetWithHttpInfo($with, $sort_by, $group_by, $ids, $item_id, $item_ids, $is_active, $is_main, $is_salable, $supplier_id, $availability_ids, $has_children, $has_active_children, $attribute_id, $any_attribute_id, $all_attribute_ids, $attribute_value_id, $any_attribute_value_id, $all_attribute_value_ids, $barcode_code, $barcode_id, $bundle_type, $category_id, $any_category_id, $all_category_ids, $any_characteristic_id, $all_characteristic_ids, $client_id, $any_client_id, $all_client_ids, $automatic_client_visibilities, $image_has_market_id, $flag1, $flag2, $manufacturer_id, $any_manufacturer_id, $item_type, $market_id, $any_market_id, $all_market_ids, $price_between, $price_between_by_id, $any_sales_price_id, $property_selection_id, $any_property_selection_id, $all_property_selection_ids, $has_name_in_language, $created_at, $updated_at, $item_created_at, $item_updated_at, $availability_updated_at, $stock_updated_at, $page, $items_per_page);
        return $response;
    }

    /**
     * Operation restPimVariationsGetWithHttpInfo
     *
     * Lists variations
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;additionalSkus&#39; &#x3D; The additional skus of the variation.&lt;/li&gt;&lt;li&gt;&#39;attributeValues&#39; &#x3D; The attribute values of the variation.&lt;/li&gt;&lt;li&gt;&#39;attributeValues.attribute&#39;/b&gt; &#x3D; Includes attributeValues. The attribute data to the related attribute ID.&lt;/li&gt;&lt;li&gt;&#39;attributeValues.attributeValue&#39; &#x3D; Includes attributeValues. The attribute value data to the related attribute value ID.&lt;/li&gt;&lt;li&gt;&#39;barcodes&#39; &#x3D; The barcodes of the variation.&lt;/li&gt;&lt;li&gt;&#39;barcodes.barcode&#39; &#x3D; Includes barcodes. The barcode data to the related barcode ID.&lt;/li&gt;&lt;li&gt;&#39;base&#39; &#x3D; The variation base.&lt;/li&gt;&lt;li&gt;&#39;base.item&#39; &#x3D; Includes base. The item data of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.itemSerialNumber&#39; &#x3D; Includes base. The item serial numbers of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.feedback&#39; &#x3D; Includes base. The feedback of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.characteristics&#39; &#x3D; Includes base. The characteristics of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.crossSelling&#39; &#x3D; Includes base. The cross selling items of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.texts&#39; &#x3D; Includes base. The texts of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.availability&#39; &#x3D; Includes base. The availability data related to the variation&#39;s availability ID.&lt;/li&gt;&lt;li&gt;&#39;base.images&#39; &#x3D; Includes base. The images linked to the item.&lt;/li&gt;&lt;li&gt;&#39;base.shippingProfiles&#39; &#x3D; Includes base. The shipping profiles linked to the item.&lt;/li&gt;&lt;li&gt;&#39;base.stock&#39; &#x3D; Includes base. The stock of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.stockStorageLocations&#39; &#x3D; Includes base. The stock storage locations of the variation.&lt;/li&gt;&lt;li&gt;&#39;bundleComponents&#39; &#x3D; The bundle components of the variation.&lt;/li&gt;&lt;li&gt;&#39;categories&#39; &#x3D; The categories of the variation.&lt;/li&gt;&lt;li&gt;&#39;categories.category&#39; &#x3D; Includes categories. The related category data for each category ID.&lt;/li&gt;&lt;li&gt;&#39;categories.categoryBranch&#39; &#x3D; Includes categories. The related category branch data for each category ID.&lt;/li&gt;&lt;li&gt;&#39;clients&#39; &#x3D; The clients of the variation.&lt;/li&gt;&lt;li&gt;&#39;defaultCategories&#39; &#x3D; The default categories of the variation&lt;/li&gt;&lt;li&gt;&#39;defaultCategories.category&#39; &#x3D; Includes defaultCategories. The category data to the related category ID.&lt;/li&gt;&lt;li&gt;&#39;images&#39; &#x3D; The images of the variation&lt;/li&gt;&lt;li&gt;&#39;images.image&#39; &#x3D; Includes images. The image data to the related image ID.&lt;/li&gt;&lt;li&gt;&#39;markets&#39; &#x3D; The markets of the variation.&lt;/li&gt;&lt;li&gt;&#39;marketIdentNumbers&#39; &#x3D; The market ident numbers of the variation&lt;/li&gt;&lt;li&gt;&#39;salesPrices&#39; &#x3D; The sales prices of the variation.&lt;/li&gt;&lt;li&gt;&#39;salesPrices.salesPrice&#39; &#x3D; Includes salesPrices. The sales price data to the related sales price ID.&lt;/li&gt;&lt;li&gt;&#39;skus&#39; &#x3D; The skus of the variation.&lt;/li&gt;&lt;li&gt;&#39;supplier&#39; &#x3D; The supplier of the variation.&lt;/li&gt;&lt;li&gt;&#39;supplier.supplier&#39; &#x3D; Includes supplier. The contact data to the related supplier ID.&lt;/li&gt;&lt;li&gt;&#39;timestamps&#39; &#x3D; The timetamps of the variation.&lt;/li&gt;&lt;li&gt;&#39;warehouses&#39; &#x3D; The warehouses of the variation&lt;/li&gt;&lt;li&gt;&#39;warehouses.warehouse&#39; &#x3D; Includes warehouses. The warehouse data to the related warehouse ID.&lt;/li&gt;&lt;li&gt;&#39;unit&#39; &#x3D; The unit of the variation&lt;/li&gt;&lt;li&gt;&#39;unit.unit&#39; &#x3D; Includes unit. The unit data of the related unit ID.&lt;/li&gt;&lt;li&gt;&#39;tags&#39; &#x3D; The tags of the variation.&lt;/li&gt;&lt;li&gt;&#39;tags.tag&#39; &#x3D; Includes tags. The tag data to the related tag ID.&lt;/li&gt;&lt;li&gt;&#39;properties&#39; &#x3D; The properties of the variation.&lt;/li&gt;&lt;li&gt;&#39;properties.property&#39; &#x3D; Includes properties. The property data to the related property ID.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $sort_by Sorts the results. Append &#39;_asc&#39; or &#39;_desc&#39; to specify the sorting order. &#39;_desc&#39; is the default value if no other is specified. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;id&#39;&lt;/li&gt;&lt;li&gt;&#39;itemId&#39;&lt;/li&gt;&lt;li&gt;&#39;isMain&#39;&lt;/li&gt;&lt;li&gt;&#39;position&#39;&lt;/li&gt;&lt;li&gt;&#39;availabilityId&#39;&lt;/li&gt;&lt;li&gt;&#39;createdAt&#39;&lt;/li&gt;&lt;li&gt;&#39;updatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;itemUpdatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;relatedUpdatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;variationName&#39;&lt;/li&gt;&lt;li&gt;&#39;number&#39;&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $group_by Groups the result. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;itemId&#39; &#x3D; Groups the result by the item ID.&lt;/li&gt;&lt;li&gt;&#39;itemAttributeValue&#39; &#x3D; Groups the result by the attribute with the flag &#39;isGroupable&#39;.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $ids Filter restricts the list of results to variations with the specified IDs. More than one parameter should be separated by commas. (optional)
     * @param  int $item_id Filter restricts the list of results to variations with the specified item ID. (optional)
     * @param  string $item_ids Filter restricts the list of results to variations with the specified item IDs. More than one parameter should be separated by commas. (optional)
     * @param  bool $is_active Filter restricts the list of results to variations which are active/inactive. (optional)
     * @param  bool $is_main Filter restricts the list of results to variations which are main/not main. (optional)
     * @param  bool $is_salable Filter restricts the list of results to variations which are salable. (optional)
     * @param  int $supplier_id Filter restricts the list of results to variations which have the given supplier ID. (optional)
     * @param  string $availability_ids Filter restricts the list of results to variations with the specified availability IDs. More than one parameter should be separated by commas. (optional)
     * @param  bool $has_children Filter restricts the list of results to variations which have children. (optional)
     * @param  bool $has_active_children Filter restricts the list of results to variations which have active children. (optional)
     * @param  int $attribute_id Filter restricts the list of results to variations which have the specified attribute ID. (optional)
     * @param  string $any_attribute_id Filter restricts the list of results to variations which have any of the specified attribute IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $all_attribute_ids Filter restricts the list of results to variations which have all specified attribute IDs. More than one parameter should be separated by commas. (optional)
     * @param  int $attribute_value_id Filter restricts the list of results to variations which have the specified attribute value ID. (optional)
     * @param  string $any_attribute_value_id Filter restricts the list of results to variations which have the any of the specified attribute value IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $all_attribute_value_ids Filter restricts the list of results to variations which have all specified attribute value IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $barcode_code Filter restricts the list of results to variations which have a barcode with the specified code. (optional)
     * @param  int $barcode_id Filter restricts the list of results to variations which have a barcode with the specified ID. (optional)
     * @param  string $bundle_type Filter restricts the list of results to variations with the specified bundle type. (optional)
     * @param  int $category_id Filter restricts the list of results to variations which have the specified category ID. (optional)
     * @param  string $any_category_id Filter restricts the list of results to variations which have any of the specified category IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $all_category_ids Filter restricts the list of results to variations which have all specified category IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $any_characteristic_id Filter restricts the list of results to variations which have any of the specified characteristic IDs. (optional)
     * @param  string $all_characteristic_ids Filter restricts the list of results to variations which have all specified characteristic IDs. (optional)
     * @param  int $client_id Filter restricts the list of results to variations which have the specified client ID. (optional)
     * @param  string $any_client_id Filter restricts the list of results to variations which have any of the specified client IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $all_client_ids Filter restricts the list of results to variations which have all specified client IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $automatic_client_visibilities Filter restricts the list of results to variations which have any of the specified automatic client visibilities. More than one parameter should be separated by commas. (optional)
     * @param  float $image_has_market_id Filter restricts the list of results to variations which have an image available for the specified market ID. (optional)
     * @param  int $flag1 Filter restricts the list of results to variations with the specified flag one. (optional)
     * @param  int $flag2 Filter restricts the list of results to variations with the specified flag two. (optional)
     * @param  int $manufacturer_id Filter restricts the list of results to variations with the specified manufacturer ID. (optional)
     * @param  string $any_manufacturer_id Filter restricts the list of results to variations with any of the specified manufacturer IDs. (optional)
     * @param  string $item_type Filter restricts the list of results to variations which have the specified item type. (optional)
     * @param  float $market_id Filter restricts the list of results to variations which have the specified market ID. (optional)
     * @param  string $any_market_id Filter restricts the list of results to variations which have any of the specified market IDs. (optional)
     * @param  string $all_market_ids Filter restricts the list of results to variations which have all specified market IDs. (optional)
     * @param  string $price_between Filter restricts the list of results to variations which have a sales price between the specified minimum and maximum value. Minimum and maximum value should be separated by a comma. (optional)
     * @param  string $price_between_by_id Filter restricts the list of results to variations where the specified sales price is between the specified minimum and maximum value. Sales price ID, Minimum and maximum value should be separated by a comma. (optional)
     * @param  string $any_sales_price_id Filter restricts the list of results to variations which have any of the specified sales price IDs. More than one parameter should be separated by commas. (optional)
     * @param  int $property_selection_id Filter restricts the list of results to variations which have the specified property selection ID. (optional)
     * @param  string $any_property_selection_id Filter restricts the list of results to variations which have any of the specified property selection IDs. (optional)
     * @param  string $all_property_selection_ids Filter restricts the list of results to variations which have all specified property selection IDs. (optional)
     * @param  string $has_name_in_language Filter restricts the list of results to variations which have a name in the specified language. (optional)
     * @param  string $created_at Filter restricts the list of results to variations which have been created in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $updated_at Filter restricts the list of results to variations which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $item_created_at Filter restricts the list of results to variations whose item has been created in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $item_updated_at Filter restricts the list of results to variations whose item has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $availability_updated_at Filter restricts the list of results to variations whose availablity has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $stock_updated_at Filter restricts the list of results to variations whose stock has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  int $page The requested page of results. Default value is 1. (optional)
     * @param  int $items_per_page The number of results per page. Maximum value is 250. Default value is 50. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20020, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimVariationsGetWithHttpInfo($with = null, $sort_by = null, $group_by = null, $ids = null, $item_id = null, $item_ids = null, $is_active = null, $is_main = null, $is_salable = null, $supplier_id = null, $availability_ids = null, $has_children = null, $has_active_children = null, $attribute_id = null, $any_attribute_id = null, $all_attribute_ids = null, $attribute_value_id = null, $any_attribute_value_id = null, $all_attribute_value_ids = null, $barcode_code = null, $barcode_id = null, $bundle_type = null, $category_id = null, $any_category_id = null, $all_category_ids = null, $any_characteristic_id = null, $all_characteristic_ids = null, $client_id = null, $any_client_id = null, $all_client_ids = null, $automatic_client_visibilities = null, $image_has_market_id = null, $flag1 = null, $flag2 = null, $manufacturer_id = null, $any_manufacturer_id = null, $item_type = null, $market_id = null, $any_market_id = null, $all_market_ids = null, $price_between = null, $price_between_by_id = null, $any_sales_price_id = null, $property_selection_id = null, $any_property_selection_id = null, $all_property_selection_ids = null, $has_name_in_language = null, $created_at = null, $updated_at = null, $item_created_at = null, $item_updated_at = null, $availability_updated_at = null, $stock_updated_at = null, $page = null, $items_per_page = null)
    {
        $request = $this->restPimVariationsGetRequest($with, $sort_by, $group_by, $ids, $item_id, $item_ids, $is_active, $is_main, $is_salable, $supplier_id, $availability_ids, $has_children, $has_active_children, $attribute_id, $any_attribute_id, $all_attribute_ids, $attribute_value_id, $any_attribute_value_id, $all_attribute_value_ids, $barcode_code, $barcode_id, $bundle_type, $category_id, $any_category_id, $all_category_ids, $any_characteristic_id, $all_characteristic_ids, $client_id, $any_client_id, $all_client_ids, $automatic_client_visibilities, $image_has_market_id, $flag1, $flag2, $manufacturer_id, $any_manufacturer_id, $item_type, $market_id, $any_market_id, $all_market_ids, $price_between, $price_between_by_id, $any_sales_price_id, $property_selection_id, $any_property_selection_id, $all_property_selection_ids, $has_name_in_language, $created_at, $updated_at, $item_created_at, $item_updated_at, $availability_updated_at, $stock_updated_at, $page, $items_per_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20020' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20020', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20020';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20020',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimVariationsGetAsync
     *
     * Lists variations
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;additionalSkus&#39; &#x3D; The additional skus of the variation.&lt;/li&gt;&lt;li&gt;&#39;attributeValues&#39; &#x3D; The attribute values of the variation.&lt;/li&gt;&lt;li&gt;&#39;attributeValues.attribute&#39;/b&gt; &#x3D; Includes attributeValues. The attribute data to the related attribute ID.&lt;/li&gt;&lt;li&gt;&#39;attributeValues.attributeValue&#39; &#x3D; Includes attributeValues. The attribute value data to the related attribute value ID.&lt;/li&gt;&lt;li&gt;&#39;barcodes&#39; &#x3D; The barcodes of the variation.&lt;/li&gt;&lt;li&gt;&#39;barcodes.barcode&#39; &#x3D; Includes barcodes. The barcode data to the related barcode ID.&lt;/li&gt;&lt;li&gt;&#39;base&#39; &#x3D; The variation base.&lt;/li&gt;&lt;li&gt;&#39;base.item&#39; &#x3D; Includes base. The item data of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.itemSerialNumber&#39; &#x3D; Includes base. The item serial numbers of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.feedback&#39; &#x3D; Includes base. The feedback of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.characteristics&#39; &#x3D; Includes base. The characteristics of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.crossSelling&#39; &#x3D; Includes base. The cross selling items of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.texts&#39; &#x3D; Includes base. The texts of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.availability&#39; &#x3D; Includes base. The availability data related to the variation&#39;s availability ID.&lt;/li&gt;&lt;li&gt;&#39;base.images&#39; &#x3D; Includes base. The images linked to the item.&lt;/li&gt;&lt;li&gt;&#39;base.shippingProfiles&#39; &#x3D; Includes base. The shipping profiles linked to the item.&lt;/li&gt;&lt;li&gt;&#39;base.stock&#39; &#x3D; Includes base. The stock of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.stockStorageLocations&#39; &#x3D; Includes base. The stock storage locations of the variation.&lt;/li&gt;&lt;li&gt;&#39;bundleComponents&#39; &#x3D; The bundle components of the variation.&lt;/li&gt;&lt;li&gt;&#39;categories&#39; &#x3D; The categories of the variation.&lt;/li&gt;&lt;li&gt;&#39;categories.category&#39; &#x3D; Includes categories. The related category data for each category ID.&lt;/li&gt;&lt;li&gt;&#39;categories.categoryBranch&#39; &#x3D; Includes categories. The related category branch data for each category ID.&lt;/li&gt;&lt;li&gt;&#39;clients&#39; &#x3D; The clients of the variation.&lt;/li&gt;&lt;li&gt;&#39;defaultCategories&#39; &#x3D; The default categories of the variation&lt;/li&gt;&lt;li&gt;&#39;defaultCategories.category&#39; &#x3D; Includes defaultCategories. The category data to the related category ID.&lt;/li&gt;&lt;li&gt;&#39;images&#39; &#x3D; The images of the variation&lt;/li&gt;&lt;li&gt;&#39;images.image&#39; &#x3D; Includes images. The image data to the related image ID.&lt;/li&gt;&lt;li&gt;&#39;markets&#39; &#x3D; The markets of the variation.&lt;/li&gt;&lt;li&gt;&#39;marketIdentNumbers&#39; &#x3D; The market ident numbers of the variation&lt;/li&gt;&lt;li&gt;&#39;salesPrices&#39; &#x3D; The sales prices of the variation.&lt;/li&gt;&lt;li&gt;&#39;salesPrices.salesPrice&#39; &#x3D; Includes salesPrices. The sales price data to the related sales price ID.&lt;/li&gt;&lt;li&gt;&#39;skus&#39; &#x3D; The skus of the variation.&lt;/li&gt;&lt;li&gt;&#39;supplier&#39; &#x3D; The supplier of the variation.&lt;/li&gt;&lt;li&gt;&#39;supplier.supplier&#39; &#x3D; Includes supplier. The contact data to the related supplier ID.&lt;/li&gt;&lt;li&gt;&#39;timestamps&#39; &#x3D; The timetamps of the variation.&lt;/li&gt;&lt;li&gt;&#39;warehouses&#39; &#x3D; The warehouses of the variation&lt;/li&gt;&lt;li&gt;&#39;warehouses.warehouse&#39; &#x3D; Includes warehouses. The warehouse data to the related warehouse ID.&lt;/li&gt;&lt;li&gt;&#39;unit&#39; &#x3D; The unit of the variation&lt;/li&gt;&lt;li&gt;&#39;unit.unit&#39; &#x3D; Includes unit. The unit data of the related unit ID.&lt;/li&gt;&lt;li&gt;&#39;tags&#39; &#x3D; The tags of the variation.&lt;/li&gt;&lt;li&gt;&#39;tags.tag&#39; &#x3D; Includes tags. The tag data to the related tag ID.&lt;/li&gt;&lt;li&gt;&#39;properties&#39; &#x3D; The properties of the variation.&lt;/li&gt;&lt;li&gt;&#39;properties.property&#39; &#x3D; Includes properties. The property data to the related property ID.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $sort_by Sorts the results. Append &#39;_asc&#39; or &#39;_desc&#39; to specify the sorting order. &#39;_desc&#39; is the default value if no other is specified. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;id&#39;&lt;/li&gt;&lt;li&gt;&#39;itemId&#39;&lt;/li&gt;&lt;li&gt;&#39;isMain&#39;&lt;/li&gt;&lt;li&gt;&#39;position&#39;&lt;/li&gt;&lt;li&gt;&#39;availabilityId&#39;&lt;/li&gt;&lt;li&gt;&#39;createdAt&#39;&lt;/li&gt;&lt;li&gt;&#39;updatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;itemUpdatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;relatedUpdatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;variationName&#39;&lt;/li&gt;&lt;li&gt;&#39;number&#39;&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $group_by Groups the result. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;itemId&#39; &#x3D; Groups the result by the item ID.&lt;/li&gt;&lt;li&gt;&#39;itemAttributeValue&#39; &#x3D; Groups the result by the attribute with the flag &#39;isGroupable&#39;.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $ids Filter restricts the list of results to variations with the specified IDs. More than one parameter should be separated by commas. (optional)
     * @param  int $item_id Filter restricts the list of results to variations with the specified item ID. (optional)
     * @param  string $item_ids Filter restricts the list of results to variations with the specified item IDs. More than one parameter should be separated by commas. (optional)
     * @param  bool $is_active Filter restricts the list of results to variations which are active/inactive. (optional)
     * @param  bool $is_main Filter restricts the list of results to variations which are main/not main. (optional)
     * @param  bool $is_salable Filter restricts the list of results to variations which are salable. (optional)
     * @param  int $supplier_id Filter restricts the list of results to variations which have the given supplier ID. (optional)
     * @param  string $availability_ids Filter restricts the list of results to variations with the specified availability IDs. More than one parameter should be separated by commas. (optional)
     * @param  bool $has_children Filter restricts the list of results to variations which have children. (optional)
     * @param  bool $has_active_children Filter restricts the list of results to variations which have active children. (optional)
     * @param  int $attribute_id Filter restricts the list of results to variations which have the specified attribute ID. (optional)
     * @param  string $any_attribute_id Filter restricts the list of results to variations which have any of the specified attribute IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $all_attribute_ids Filter restricts the list of results to variations which have all specified attribute IDs. More than one parameter should be separated by commas. (optional)
     * @param  int $attribute_value_id Filter restricts the list of results to variations which have the specified attribute value ID. (optional)
     * @param  string $any_attribute_value_id Filter restricts the list of results to variations which have the any of the specified attribute value IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $all_attribute_value_ids Filter restricts the list of results to variations which have all specified attribute value IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $barcode_code Filter restricts the list of results to variations which have a barcode with the specified code. (optional)
     * @param  int $barcode_id Filter restricts the list of results to variations which have a barcode with the specified ID. (optional)
     * @param  string $bundle_type Filter restricts the list of results to variations with the specified bundle type. (optional)
     * @param  int $category_id Filter restricts the list of results to variations which have the specified category ID. (optional)
     * @param  string $any_category_id Filter restricts the list of results to variations which have any of the specified category IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $all_category_ids Filter restricts the list of results to variations which have all specified category IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $any_characteristic_id Filter restricts the list of results to variations which have any of the specified characteristic IDs. (optional)
     * @param  string $all_characteristic_ids Filter restricts the list of results to variations which have all specified characteristic IDs. (optional)
     * @param  int $client_id Filter restricts the list of results to variations which have the specified client ID. (optional)
     * @param  string $any_client_id Filter restricts the list of results to variations which have any of the specified client IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $all_client_ids Filter restricts the list of results to variations which have all specified client IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $automatic_client_visibilities Filter restricts the list of results to variations which have any of the specified automatic client visibilities. More than one parameter should be separated by commas. (optional)
     * @param  float $image_has_market_id Filter restricts the list of results to variations which have an image available for the specified market ID. (optional)
     * @param  int $flag1 Filter restricts the list of results to variations with the specified flag one. (optional)
     * @param  int $flag2 Filter restricts the list of results to variations with the specified flag two. (optional)
     * @param  int $manufacturer_id Filter restricts the list of results to variations with the specified manufacturer ID. (optional)
     * @param  string $any_manufacturer_id Filter restricts the list of results to variations with any of the specified manufacturer IDs. (optional)
     * @param  string $item_type Filter restricts the list of results to variations which have the specified item type. (optional)
     * @param  float $market_id Filter restricts the list of results to variations which have the specified market ID. (optional)
     * @param  string $any_market_id Filter restricts the list of results to variations which have any of the specified market IDs. (optional)
     * @param  string $all_market_ids Filter restricts the list of results to variations which have all specified market IDs. (optional)
     * @param  string $price_between Filter restricts the list of results to variations which have a sales price between the specified minimum and maximum value. Minimum and maximum value should be separated by a comma. (optional)
     * @param  string $price_between_by_id Filter restricts the list of results to variations where the specified sales price is between the specified minimum and maximum value. Sales price ID, Minimum and maximum value should be separated by a comma. (optional)
     * @param  string $any_sales_price_id Filter restricts the list of results to variations which have any of the specified sales price IDs. More than one parameter should be separated by commas. (optional)
     * @param  int $property_selection_id Filter restricts the list of results to variations which have the specified property selection ID. (optional)
     * @param  string $any_property_selection_id Filter restricts the list of results to variations which have any of the specified property selection IDs. (optional)
     * @param  string $all_property_selection_ids Filter restricts the list of results to variations which have all specified property selection IDs. (optional)
     * @param  string $has_name_in_language Filter restricts the list of results to variations which have a name in the specified language. (optional)
     * @param  string $created_at Filter restricts the list of results to variations which have been created in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $updated_at Filter restricts the list of results to variations which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $item_created_at Filter restricts the list of results to variations whose item has been created in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $item_updated_at Filter restricts the list of results to variations whose item has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $availability_updated_at Filter restricts the list of results to variations whose availablity has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $stock_updated_at Filter restricts the list of results to variations whose stock has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  int $page The requested page of results. Default value is 1. (optional)
     * @param  int $items_per_page The number of results per page. Maximum value is 250. Default value is 50. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimVariationsGetAsync($with = null, $sort_by = null, $group_by = null, $ids = null, $item_id = null, $item_ids = null, $is_active = null, $is_main = null, $is_salable = null, $supplier_id = null, $availability_ids = null, $has_children = null, $has_active_children = null, $attribute_id = null, $any_attribute_id = null, $all_attribute_ids = null, $attribute_value_id = null, $any_attribute_value_id = null, $all_attribute_value_ids = null, $barcode_code = null, $barcode_id = null, $bundle_type = null, $category_id = null, $any_category_id = null, $all_category_ids = null, $any_characteristic_id = null, $all_characteristic_ids = null, $client_id = null, $any_client_id = null, $all_client_ids = null, $automatic_client_visibilities = null, $image_has_market_id = null, $flag1 = null, $flag2 = null, $manufacturer_id = null, $any_manufacturer_id = null, $item_type = null, $market_id = null, $any_market_id = null, $all_market_ids = null, $price_between = null, $price_between_by_id = null, $any_sales_price_id = null, $property_selection_id = null, $any_property_selection_id = null, $all_property_selection_ids = null, $has_name_in_language = null, $created_at = null, $updated_at = null, $item_created_at = null, $item_updated_at = null, $availability_updated_at = null, $stock_updated_at = null, $page = null, $items_per_page = null)
    {
        return $this->restPimVariationsGetAsyncWithHttpInfo($with, $sort_by, $group_by, $ids, $item_id, $item_ids, $is_active, $is_main, $is_salable, $supplier_id, $availability_ids, $has_children, $has_active_children, $attribute_id, $any_attribute_id, $all_attribute_ids, $attribute_value_id, $any_attribute_value_id, $all_attribute_value_ids, $barcode_code, $barcode_id, $bundle_type, $category_id, $any_category_id, $all_category_ids, $any_characteristic_id, $all_characteristic_ids, $client_id, $any_client_id, $all_client_ids, $automatic_client_visibilities, $image_has_market_id, $flag1, $flag2, $manufacturer_id, $any_manufacturer_id, $item_type, $market_id, $any_market_id, $all_market_ids, $price_between, $price_between_by_id, $any_sales_price_id, $property_selection_id, $any_property_selection_id, $all_property_selection_ids, $has_name_in_language, $created_at, $updated_at, $item_created_at, $item_updated_at, $availability_updated_at, $stock_updated_at, $page, $items_per_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimVariationsGetAsyncWithHttpInfo
     *
     * Lists variations
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;additionalSkus&#39; &#x3D; The additional skus of the variation.&lt;/li&gt;&lt;li&gt;&#39;attributeValues&#39; &#x3D; The attribute values of the variation.&lt;/li&gt;&lt;li&gt;&#39;attributeValues.attribute&#39;/b&gt; &#x3D; Includes attributeValues. The attribute data to the related attribute ID.&lt;/li&gt;&lt;li&gt;&#39;attributeValues.attributeValue&#39; &#x3D; Includes attributeValues. The attribute value data to the related attribute value ID.&lt;/li&gt;&lt;li&gt;&#39;barcodes&#39; &#x3D; The barcodes of the variation.&lt;/li&gt;&lt;li&gt;&#39;barcodes.barcode&#39; &#x3D; Includes barcodes. The barcode data to the related barcode ID.&lt;/li&gt;&lt;li&gt;&#39;base&#39; &#x3D; The variation base.&lt;/li&gt;&lt;li&gt;&#39;base.item&#39; &#x3D; Includes base. The item data of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.itemSerialNumber&#39; &#x3D; Includes base. The item serial numbers of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.feedback&#39; &#x3D; Includes base. The feedback of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.characteristics&#39; &#x3D; Includes base. The characteristics of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.crossSelling&#39; &#x3D; Includes base. The cross selling items of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.texts&#39; &#x3D; Includes base. The texts of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.availability&#39; &#x3D; Includes base. The availability data related to the variation&#39;s availability ID.&lt;/li&gt;&lt;li&gt;&#39;base.images&#39; &#x3D; Includes base. The images linked to the item.&lt;/li&gt;&lt;li&gt;&#39;base.shippingProfiles&#39; &#x3D; Includes base. The shipping profiles linked to the item.&lt;/li&gt;&lt;li&gt;&#39;base.stock&#39; &#x3D; Includes base. The stock of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.stockStorageLocations&#39; &#x3D; Includes base. The stock storage locations of the variation.&lt;/li&gt;&lt;li&gt;&#39;bundleComponents&#39; &#x3D; The bundle components of the variation.&lt;/li&gt;&lt;li&gt;&#39;categories&#39; &#x3D; The categories of the variation.&lt;/li&gt;&lt;li&gt;&#39;categories.category&#39; &#x3D; Includes categories. The related category data for each category ID.&lt;/li&gt;&lt;li&gt;&#39;categories.categoryBranch&#39; &#x3D; Includes categories. The related category branch data for each category ID.&lt;/li&gt;&lt;li&gt;&#39;clients&#39; &#x3D; The clients of the variation.&lt;/li&gt;&lt;li&gt;&#39;defaultCategories&#39; &#x3D; The default categories of the variation&lt;/li&gt;&lt;li&gt;&#39;defaultCategories.category&#39; &#x3D; Includes defaultCategories. The category data to the related category ID.&lt;/li&gt;&lt;li&gt;&#39;images&#39; &#x3D; The images of the variation&lt;/li&gt;&lt;li&gt;&#39;images.image&#39; &#x3D; Includes images. The image data to the related image ID.&lt;/li&gt;&lt;li&gt;&#39;markets&#39; &#x3D; The markets of the variation.&lt;/li&gt;&lt;li&gt;&#39;marketIdentNumbers&#39; &#x3D; The market ident numbers of the variation&lt;/li&gt;&lt;li&gt;&#39;salesPrices&#39; &#x3D; The sales prices of the variation.&lt;/li&gt;&lt;li&gt;&#39;salesPrices.salesPrice&#39; &#x3D; Includes salesPrices. The sales price data to the related sales price ID.&lt;/li&gt;&lt;li&gt;&#39;skus&#39; &#x3D; The skus of the variation.&lt;/li&gt;&lt;li&gt;&#39;supplier&#39; &#x3D; The supplier of the variation.&lt;/li&gt;&lt;li&gt;&#39;supplier.supplier&#39; &#x3D; Includes supplier. The contact data to the related supplier ID.&lt;/li&gt;&lt;li&gt;&#39;timestamps&#39; &#x3D; The timetamps of the variation.&lt;/li&gt;&lt;li&gt;&#39;warehouses&#39; &#x3D; The warehouses of the variation&lt;/li&gt;&lt;li&gt;&#39;warehouses.warehouse&#39; &#x3D; Includes warehouses. The warehouse data to the related warehouse ID.&lt;/li&gt;&lt;li&gt;&#39;unit&#39; &#x3D; The unit of the variation&lt;/li&gt;&lt;li&gt;&#39;unit.unit&#39; &#x3D; Includes unit. The unit data of the related unit ID.&lt;/li&gt;&lt;li&gt;&#39;tags&#39; &#x3D; The tags of the variation.&lt;/li&gt;&lt;li&gt;&#39;tags.tag&#39; &#x3D; Includes tags. The tag data to the related tag ID.&lt;/li&gt;&lt;li&gt;&#39;properties&#39; &#x3D; The properties of the variation.&lt;/li&gt;&lt;li&gt;&#39;properties.property&#39; &#x3D; Includes properties. The property data to the related property ID.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $sort_by Sorts the results. Append &#39;_asc&#39; or &#39;_desc&#39; to specify the sorting order. &#39;_desc&#39; is the default value if no other is specified. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;id&#39;&lt;/li&gt;&lt;li&gt;&#39;itemId&#39;&lt;/li&gt;&lt;li&gt;&#39;isMain&#39;&lt;/li&gt;&lt;li&gt;&#39;position&#39;&lt;/li&gt;&lt;li&gt;&#39;availabilityId&#39;&lt;/li&gt;&lt;li&gt;&#39;createdAt&#39;&lt;/li&gt;&lt;li&gt;&#39;updatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;itemUpdatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;relatedUpdatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;variationName&#39;&lt;/li&gt;&lt;li&gt;&#39;number&#39;&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $group_by Groups the result. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;itemId&#39; &#x3D; Groups the result by the item ID.&lt;/li&gt;&lt;li&gt;&#39;itemAttributeValue&#39; &#x3D; Groups the result by the attribute with the flag &#39;isGroupable&#39;.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $ids Filter restricts the list of results to variations with the specified IDs. More than one parameter should be separated by commas. (optional)
     * @param  int $item_id Filter restricts the list of results to variations with the specified item ID. (optional)
     * @param  string $item_ids Filter restricts the list of results to variations with the specified item IDs. More than one parameter should be separated by commas. (optional)
     * @param  bool $is_active Filter restricts the list of results to variations which are active/inactive. (optional)
     * @param  bool $is_main Filter restricts the list of results to variations which are main/not main. (optional)
     * @param  bool $is_salable Filter restricts the list of results to variations which are salable. (optional)
     * @param  int $supplier_id Filter restricts the list of results to variations which have the given supplier ID. (optional)
     * @param  string $availability_ids Filter restricts the list of results to variations with the specified availability IDs. More than one parameter should be separated by commas. (optional)
     * @param  bool $has_children Filter restricts the list of results to variations which have children. (optional)
     * @param  bool $has_active_children Filter restricts the list of results to variations which have active children. (optional)
     * @param  int $attribute_id Filter restricts the list of results to variations which have the specified attribute ID. (optional)
     * @param  string $any_attribute_id Filter restricts the list of results to variations which have any of the specified attribute IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $all_attribute_ids Filter restricts the list of results to variations which have all specified attribute IDs. More than one parameter should be separated by commas. (optional)
     * @param  int $attribute_value_id Filter restricts the list of results to variations which have the specified attribute value ID. (optional)
     * @param  string $any_attribute_value_id Filter restricts the list of results to variations which have the any of the specified attribute value IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $all_attribute_value_ids Filter restricts the list of results to variations which have all specified attribute value IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $barcode_code Filter restricts the list of results to variations which have a barcode with the specified code. (optional)
     * @param  int $barcode_id Filter restricts the list of results to variations which have a barcode with the specified ID. (optional)
     * @param  string $bundle_type Filter restricts the list of results to variations with the specified bundle type. (optional)
     * @param  int $category_id Filter restricts the list of results to variations which have the specified category ID. (optional)
     * @param  string $any_category_id Filter restricts the list of results to variations which have any of the specified category IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $all_category_ids Filter restricts the list of results to variations which have all specified category IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $any_characteristic_id Filter restricts the list of results to variations which have any of the specified characteristic IDs. (optional)
     * @param  string $all_characteristic_ids Filter restricts the list of results to variations which have all specified characteristic IDs. (optional)
     * @param  int $client_id Filter restricts the list of results to variations which have the specified client ID. (optional)
     * @param  string $any_client_id Filter restricts the list of results to variations which have any of the specified client IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $all_client_ids Filter restricts the list of results to variations which have all specified client IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $automatic_client_visibilities Filter restricts the list of results to variations which have any of the specified automatic client visibilities. More than one parameter should be separated by commas. (optional)
     * @param  float $image_has_market_id Filter restricts the list of results to variations which have an image available for the specified market ID. (optional)
     * @param  int $flag1 Filter restricts the list of results to variations with the specified flag one. (optional)
     * @param  int $flag2 Filter restricts the list of results to variations with the specified flag two. (optional)
     * @param  int $manufacturer_id Filter restricts the list of results to variations with the specified manufacturer ID. (optional)
     * @param  string $any_manufacturer_id Filter restricts the list of results to variations with any of the specified manufacturer IDs. (optional)
     * @param  string $item_type Filter restricts the list of results to variations which have the specified item type. (optional)
     * @param  float $market_id Filter restricts the list of results to variations which have the specified market ID. (optional)
     * @param  string $any_market_id Filter restricts the list of results to variations which have any of the specified market IDs. (optional)
     * @param  string $all_market_ids Filter restricts the list of results to variations which have all specified market IDs. (optional)
     * @param  string $price_between Filter restricts the list of results to variations which have a sales price between the specified minimum and maximum value. Minimum and maximum value should be separated by a comma. (optional)
     * @param  string $price_between_by_id Filter restricts the list of results to variations where the specified sales price is between the specified minimum and maximum value. Sales price ID, Minimum and maximum value should be separated by a comma. (optional)
     * @param  string $any_sales_price_id Filter restricts the list of results to variations which have any of the specified sales price IDs. More than one parameter should be separated by commas. (optional)
     * @param  int $property_selection_id Filter restricts the list of results to variations which have the specified property selection ID. (optional)
     * @param  string $any_property_selection_id Filter restricts the list of results to variations which have any of the specified property selection IDs. (optional)
     * @param  string $all_property_selection_ids Filter restricts the list of results to variations which have all specified property selection IDs. (optional)
     * @param  string $has_name_in_language Filter restricts the list of results to variations which have a name in the specified language. (optional)
     * @param  string $created_at Filter restricts the list of results to variations which have been created in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $updated_at Filter restricts the list of results to variations which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $item_created_at Filter restricts the list of results to variations whose item has been created in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $item_updated_at Filter restricts the list of results to variations whose item has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $availability_updated_at Filter restricts the list of results to variations whose availablity has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $stock_updated_at Filter restricts the list of results to variations whose stock has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  int $page The requested page of results. Default value is 1. (optional)
     * @param  int $items_per_page The number of results per page. Maximum value is 250. Default value is 50. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPimVariationsGetAsyncWithHttpInfo($with = null, $sort_by = null, $group_by = null, $ids = null, $item_id = null, $item_ids = null, $is_active = null, $is_main = null, $is_salable = null, $supplier_id = null, $availability_ids = null, $has_children = null, $has_active_children = null, $attribute_id = null, $any_attribute_id = null, $all_attribute_ids = null, $attribute_value_id = null, $any_attribute_value_id = null, $all_attribute_value_ids = null, $barcode_code = null, $barcode_id = null, $bundle_type = null, $category_id = null, $any_category_id = null, $all_category_ids = null, $any_characteristic_id = null, $all_characteristic_ids = null, $client_id = null, $any_client_id = null, $all_client_ids = null, $automatic_client_visibilities = null, $image_has_market_id = null, $flag1 = null, $flag2 = null, $manufacturer_id = null, $any_manufacturer_id = null, $item_type = null, $market_id = null, $any_market_id = null, $all_market_ids = null, $price_between = null, $price_between_by_id = null, $any_sales_price_id = null, $property_selection_id = null, $any_property_selection_id = null, $all_property_selection_ids = null, $has_name_in_language = null, $created_at = null, $updated_at = null, $item_created_at = null, $item_updated_at = null, $availability_updated_at = null, $stock_updated_at = null, $page = null, $items_per_page = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20020';
        $request = $this->restPimVariationsGetRequest($with, $sort_by, $group_by, $ids, $item_id, $item_ids, $is_active, $is_main, $is_salable, $supplier_id, $availability_ids, $has_children, $has_active_children, $attribute_id, $any_attribute_id, $all_attribute_ids, $attribute_value_id, $any_attribute_value_id, $all_attribute_value_ids, $barcode_code, $barcode_id, $bundle_type, $category_id, $any_category_id, $all_category_ids, $any_characteristic_id, $all_characteristic_ids, $client_id, $any_client_id, $all_client_ids, $automatic_client_visibilities, $image_has_market_id, $flag1, $flag2, $manufacturer_id, $any_manufacturer_id, $item_type, $market_id, $any_market_id, $all_market_ids, $price_between, $price_between_by_id, $any_sales_price_id, $property_selection_id, $any_property_selection_id, $all_property_selection_ids, $has_name_in_language, $created_at, $updated_at, $item_created_at, $item_updated_at, $availability_updated_at, $stock_updated_at, $page, $items_per_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimVariationsGet'
     *
     * @param  string $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;additionalSkus&#39; &#x3D; The additional skus of the variation.&lt;/li&gt;&lt;li&gt;&#39;attributeValues&#39; &#x3D; The attribute values of the variation.&lt;/li&gt;&lt;li&gt;&#39;attributeValues.attribute&#39;/b&gt; &#x3D; Includes attributeValues. The attribute data to the related attribute ID.&lt;/li&gt;&lt;li&gt;&#39;attributeValues.attributeValue&#39; &#x3D; Includes attributeValues. The attribute value data to the related attribute value ID.&lt;/li&gt;&lt;li&gt;&#39;barcodes&#39; &#x3D; The barcodes of the variation.&lt;/li&gt;&lt;li&gt;&#39;barcodes.barcode&#39; &#x3D; Includes barcodes. The barcode data to the related barcode ID.&lt;/li&gt;&lt;li&gt;&#39;base&#39; &#x3D; The variation base.&lt;/li&gt;&lt;li&gt;&#39;base.item&#39; &#x3D; Includes base. The item data of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.itemSerialNumber&#39; &#x3D; Includes base. The item serial numbers of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.feedback&#39; &#x3D; Includes base. The feedback of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.characteristics&#39; &#x3D; Includes base. The characteristics of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.crossSelling&#39; &#x3D; Includes base. The cross selling items of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.texts&#39; &#x3D; Includes base. The texts of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.availability&#39; &#x3D; Includes base. The availability data related to the variation&#39;s availability ID.&lt;/li&gt;&lt;li&gt;&#39;base.images&#39; &#x3D; Includes base. The images linked to the item.&lt;/li&gt;&lt;li&gt;&#39;base.shippingProfiles&#39; &#x3D; Includes base. The shipping profiles linked to the item.&lt;/li&gt;&lt;li&gt;&#39;base.stock&#39; &#x3D; Includes base. The stock of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.stockStorageLocations&#39; &#x3D; Includes base. The stock storage locations of the variation.&lt;/li&gt;&lt;li&gt;&#39;bundleComponents&#39; &#x3D; The bundle components of the variation.&lt;/li&gt;&lt;li&gt;&#39;categories&#39; &#x3D; The categories of the variation.&lt;/li&gt;&lt;li&gt;&#39;categories.category&#39; &#x3D; Includes categories. The related category data for each category ID.&lt;/li&gt;&lt;li&gt;&#39;categories.categoryBranch&#39; &#x3D; Includes categories. The related category branch data for each category ID.&lt;/li&gt;&lt;li&gt;&#39;clients&#39; &#x3D; The clients of the variation.&lt;/li&gt;&lt;li&gt;&#39;defaultCategories&#39; &#x3D; The default categories of the variation&lt;/li&gt;&lt;li&gt;&#39;defaultCategories.category&#39; &#x3D; Includes defaultCategories. The category data to the related category ID.&lt;/li&gt;&lt;li&gt;&#39;images&#39; &#x3D; The images of the variation&lt;/li&gt;&lt;li&gt;&#39;images.image&#39; &#x3D; Includes images. The image data to the related image ID.&lt;/li&gt;&lt;li&gt;&#39;markets&#39; &#x3D; The markets of the variation.&lt;/li&gt;&lt;li&gt;&#39;marketIdentNumbers&#39; &#x3D; The market ident numbers of the variation&lt;/li&gt;&lt;li&gt;&#39;salesPrices&#39; &#x3D; The sales prices of the variation.&lt;/li&gt;&lt;li&gt;&#39;salesPrices.salesPrice&#39; &#x3D; Includes salesPrices. The sales price data to the related sales price ID.&lt;/li&gt;&lt;li&gt;&#39;skus&#39; &#x3D; The skus of the variation.&lt;/li&gt;&lt;li&gt;&#39;supplier&#39; &#x3D; The supplier of the variation.&lt;/li&gt;&lt;li&gt;&#39;supplier.supplier&#39; &#x3D; Includes supplier. The contact data to the related supplier ID.&lt;/li&gt;&lt;li&gt;&#39;timestamps&#39; &#x3D; The timetamps of the variation.&lt;/li&gt;&lt;li&gt;&#39;warehouses&#39; &#x3D; The warehouses of the variation&lt;/li&gt;&lt;li&gt;&#39;warehouses.warehouse&#39; &#x3D; Includes warehouses. The warehouse data to the related warehouse ID.&lt;/li&gt;&lt;li&gt;&#39;unit&#39; &#x3D; The unit of the variation&lt;/li&gt;&lt;li&gt;&#39;unit.unit&#39; &#x3D; Includes unit. The unit data of the related unit ID.&lt;/li&gt;&lt;li&gt;&#39;tags&#39; &#x3D; The tags of the variation.&lt;/li&gt;&lt;li&gt;&#39;tags.tag&#39; &#x3D; Includes tags. The tag data to the related tag ID.&lt;/li&gt;&lt;li&gt;&#39;properties&#39; &#x3D; The properties of the variation.&lt;/li&gt;&lt;li&gt;&#39;properties.property&#39; &#x3D; Includes properties. The property data to the related property ID.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $sort_by Sorts the results. Append &#39;_asc&#39; or &#39;_desc&#39; to specify the sorting order. &#39;_desc&#39; is the default value if no other is specified. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;id&#39;&lt;/li&gt;&lt;li&gt;&#39;itemId&#39;&lt;/li&gt;&lt;li&gt;&#39;isMain&#39;&lt;/li&gt;&lt;li&gt;&#39;position&#39;&lt;/li&gt;&lt;li&gt;&#39;availabilityId&#39;&lt;/li&gt;&lt;li&gt;&#39;createdAt&#39;&lt;/li&gt;&lt;li&gt;&#39;updatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;itemUpdatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;relatedUpdatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;variationName&#39;&lt;/li&gt;&lt;li&gt;&#39;number&#39;&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $group_by Groups the result. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;itemId&#39; &#x3D; Groups the result by the item ID.&lt;/li&gt;&lt;li&gt;&#39;itemAttributeValue&#39; &#x3D; Groups the result by the attribute with the flag &#39;isGroupable&#39;.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $ids Filter restricts the list of results to variations with the specified IDs. More than one parameter should be separated by commas. (optional)
     * @param  int $item_id Filter restricts the list of results to variations with the specified item ID. (optional)
     * @param  string $item_ids Filter restricts the list of results to variations with the specified item IDs. More than one parameter should be separated by commas. (optional)
     * @param  bool $is_active Filter restricts the list of results to variations which are active/inactive. (optional)
     * @param  bool $is_main Filter restricts the list of results to variations which are main/not main. (optional)
     * @param  bool $is_salable Filter restricts the list of results to variations which are salable. (optional)
     * @param  int $supplier_id Filter restricts the list of results to variations which have the given supplier ID. (optional)
     * @param  string $availability_ids Filter restricts the list of results to variations with the specified availability IDs. More than one parameter should be separated by commas. (optional)
     * @param  bool $has_children Filter restricts the list of results to variations which have children. (optional)
     * @param  bool $has_active_children Filter restricts the list of results to variations which have active children. (optional)
     * @param  int $attribute_id Filter restricts the list of results to variations which have the specified attribute ID. (optional)
     * @param  string $any_attribute_id Filter restricts the list of results to variations which have any of the specified attribute IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $all_attribute_ids Filter restricts the list of results to variations which have all specified attribute IDs. More than one parameter should be separated by commas. (optional)
     * @param  int $attribute_value_id Filter restricts the list of results to variations which have the specified attribute value ID. (optional)
     * @param  string $any_attribute_value_id Filter restricts the list of results to variations which have the any of the specified attribute value IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $all_attribute_value_ids Filter restricts the list of results to variations which have all specified attribute value IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $barcode_code Filter restricts the list of results to variations which have a barcode with the specified code. (optional)
     * @param  int $barcode_id Filter restricts the list of results to variations which have a barcode with the specified ID. (optional)
     * @param  string $bundle_type Filter restricts the list of results to variations with the specified bundle type. (optional)
     * @param  int $category_id Filter restricts the list of results to variations which have the specified category ID. (optional)
     * @param  string $any_category_id Filter restricts the list of results to variations which have any of the specified category IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $all_category_ids Filter restricts the list of results to variations which have all specified category IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $any_characteristic_id Filter restricts the list of results to variations which have any of the specified characteristic IDs. (optional)
     * @param  string $all_characteristic_ids Filter restricts the list of results to variations which have all specified characteristic IDs. (optional)
     * @param  int $client_id Filter restricts the list of results to variations which have the specified client ID. (optional)
     * @param  string $any_client_id Filter restricts the list of results to variations which have any of the specified client IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $all_client_ids Filter restricts the list of results to variations which have all specified client IDs. More than one parameter should be separated by commas. (optional)
     * @param  string $automatic_client_visibilities Filter restricts the list of results to variations which have any of the specified automatic client visibilities. More than one parameter should be separated by commas. (optional)
     * @param  float $image_has_market_id Filter restricts the list of results to variations which have an image available for the specified market ID. (optional)
     * @param  int $flag1 Filter restricts the list of results to variations with the specified flag one. (optional)
     * @param  int $flag2 Filter restricts the list of results to variations with the specified flag two. (optional)
     * @param  int $manufacturer_id Filter restricts the list of results to variations with the specified manufacturer ID. (optional)
     * @param  string $any_manufacturer_id Filter restricts the list of results to variations with any of the specified manufacturer IDs. (optional)
     * @param  string $item_type Filter restricts the list of results to variations which have the specified item type. (optional)
     * @param  float $market_id Filter restricts the list of results to variations which have the specified market ID. (optional)
     * @param  string $any_market_id Filter restricts the list of results to variations which have any of the specified market IDs. (optional)
     * @param  string $all_market_ids Filter restricts the list of results to variations which have all specified market IDs. (optional)
     * @param  string $price_between Filter restricts the list of results to variations which have a sales price between the specified minimum and maximum value. Minimum and maximum value should be separated by a comma. (optional)
     * @param  string $price_between_by_id Filter restricts the list of results to variations where the specified sales price is between the specified minimum and maximum value. Sales price ID, Minimum and maximum value should be separated by a comma. (optional)
     * @param  string $any_sales_price_id Filter restricts the list of results to variations which have any of the specified sales price IDs. More than one parameter should be separated by commas. (optional)
     * @param  int $property_selection_id Filter restricts the list of results to variations which have the specified property selection ID. (optional)
     * @param  string $any_property_selection_id Filter restricts the list of results to variations which have any of the specified property selection IDs. (optional)
     * @param  string $all_property_selection_ids Filter restricts the list of results to variations which have all specified property selection IDs. (optional)
     * @param  string $has_name_in_language Filter restricts the list of results to variations which have a name in the specified language. (optional)
     * @param  string $created_at Filter restricts the list of results to variations which have been created in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $updated_at Filter restricts the list of results to variations which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $item_created_at Filter restricts the list of results to variations whose item has been created in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $item_updated_at Filter restricts the list of results to variations whose item has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $availability_updated_at Filter restricts the list of results to variations whose availablity has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string $stock_updated_at Filter restricts the list of results to variations whose stock has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  int $page The requested page of results. Default value is 1. (optional)
     * @param  int $items_per_page The number of results per page. Maximum value is 250. Default value is 50. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPimVariationsGetRequest($with = null, $sort_by = null, $group_by = null, $ids = null, $item_id = null, $item_ids = null, $is_active = null, $is_main = null, $is_salable = null, $supplier_id = null, $availability_ids = null, $has_children = null, $has_active_children = null, $attribute_id = null, $any_attribute_id = null, $all_attribute_ids = null, $attribute_value_id = null, $any_attribute_value_id = null, $all_attribute_value_ids = null, $barcode_code = null, $barcode_id = null, $bundle_type = null, $category_id = null, $any_category_id = null, $all_category_ids = null, $any_characteristic_id = null, $all_characteristic_ids = null, $client_id = null, $any_client_id = null, $all_client_ids = null, $automatic_client_visibilities = null, $image_has_market_id = null, $flag1 = null, $flag2 = null, $manufacturer_id = null, $any_manufacturer_id = null, $item_type = null, $market_id = null, $any_market_id = null, $all_market_ids = null, $price_between = null, $price_between_by_id = null, $any_sales_price_id = null, $property_selection_id = null, $any_property_selection_id = null, $all_property_selection_ids = null, $has_name_in_language = null, $created_at = null, $updated_at = null, $item_created_at = null, $item_updated_at = null, $availability_updated_at = null, $stock_updated_at = null, $page = null, $items_per_page = null)
    {

        $resourcePath = '/rest/pim/variations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }
        // query params
        if (is_array($sort_by)) {
            $sort_by = ObjectSerializer::serializeCollection($sort_by, '', true);
        }
        if ($sort_by !== null) {
            $queryParams['sortBy'] = $sort_by;
        }
        // query params
        if (is_array($group_by)) {
            $group_by = ObjectSerializer::serializeCollection($group_by, '', true);
        }
        if ($group_by !== null) {
            $queryParams['groupBy'] = $group_by;
        }
        // query params
        if (is_array($ids)) {
            $ids = ObjectSerializer::serializeCollection($ids, '', true);
        }
        if ($ids !== null) {
            $queryParams['ids'] = $ids;
        }
        // query params
        if (is_array($item_id)) {
            $item_id = ObjectSerializer::serializeCollection($item_id, '', true);
        }
        if ($item_id !== null) {
            $queryParams['itemId'] = $item_id;
        }
        // query params
        if (is_array($item_ids)) {
            $item_ids = ObjectSerializer::serializeCollection($item_ids, '', true);
        }
        if ($item_ids !== null) {
            $queryParams['itemIds'] = $item_ids;
        }
        // query params
        if (is_array($is_active)) {
            $is_active = ObjectSerializer::serializeCollection($is_active, '', true);
        }
        if ($is_active !== null) {
            $queryParams['isActive'] = $is_active;
        }
        // query params
        if (is_array($is_main)) {
            $is_main = ObjectSerializer::serializeCollection($is_main, '', true);
        }
        if ($is_main !== null) {
            $queryParams['isMain'] = $is_main;
        }
        // query params
        if (is_array($is_salable)) {
            $is_salable = ObjectSerializer::serializeCollection($is_salable, '', true);
        }
        if ($is_salable !== null) {
            $queryParams['isSalable'] = $is_salable;
        }
        // query params
        if (is_array($supplier_id)) {
            $supplier_id = ObjectSerializer::serializeCollection($supplier_id, '', true);
        }
        if ($supplier_id !== null) {
            $queryParams['supplierId'] = $supplier_id;
        }
        // query params
        if (is_array($availability_ids)) {
            $availability_ids = ObjectSerializer::serializeCollection($availability_ids, '', true);
        }
        if ($availability_ids !== null) {
            $queryParams['availabilityIds'] = $availability_ids;
        }
        // query params
        if (is_array($has_children)) {
            $has_children = ObjectSerializer::serializeCollection($has_children, '', true);
        }
        if ($has_children !== null) {
            $queryParams['hasChildren'] = $has_children;
        }
        // query params
        if (is_array($has_active_children)) {
            $has_active_children = ObjectSerializer::serializeCollection($has_active_children, '', true);
        }
        if ($has_active_children !== null) {
            $queryParams['hasActiveChildren'] = $has_active_children;
        }
        // query params
        if (is_array($attribute_id)) {
            $attribute_id = ObjectSerializer::serializeCollection($attribute_id, '', true);
        }
        if ($attribute_id !== null) {
            $queryParams['attributeId'] = $attribute_id;
        }
        // query params
        if (is_array($any_attribute_id)) {
            $any_attribute_id = ObjectSerializer::serializeCollection($any_attribute_id, '', true);
        }
        if ($any_attribute_id !== null) {
            $queryParams['anyAttributeId'] = $any_attribute_id;
        }
        // query params
        if (is_array($all_attribute_ids)) {
            $all_attribute_ids = ObjectSerializer::serializeCollection($all_attribute_ids, '', true);
        }
        if ($all_attribute_ids !== null) {
            $queryParams['allAttributeIds'] = $all_attribute_ids;
        }
        // query params
        if (is_array($attribute_value_id)) {
            $attribute_value_id = ObjectSerializer::serializeCollection($attribute_value_id, '', true);
        }
        if ($attribute_value_id !== null) {
            $queryParams['attributeValueId'] = $attribute_value_id;
        }
        // query params
        if (is_array($any_attribute_value_id)) {
            $any_attribute_value_id = ObjectSerializer::serializeCollection($any_attribute_value_id, '', true);
        }
        if ($any_attribute_value_id !== null) {
            $queryParams['anyAttributeValueId'] = $any_attribute_value_id;
        }
        // query params
        if (is_array($all_attribute_value_ids)) {
            $all_attribute_value_ids = ObjectSerializer::serializeCollection($all_attribute_value_ids, '', true);
        }
        if ($all_attribute_value_ids !== null) {
            $queryParams['allAttributeValueIds'] = $all_attribute_value_ids;
        }
        // query params
        if (is_array($barcode_code)) {
            $barcode_code = ObjectSerializer::serializeCollection($barcode_code, '', true);
        }
        if ($barcode_code !== null) {
            $queryParams['barcodeCode'] = $barcode_code;
        }
        // query params
        if (is_array($barcode_id)) {
            $barcode_id = ObjectSerializer::serializeCollection($barcode_id, '', true);
        }
        if ($barcode_id !== null) {
            $queryParams['barcodeId'] = $barcode_id;
        }
        // query params
        if (is_array($bundle_type)) {
            $bundle_type = ObjectSerializer::serializeCollection($bundle_type, '', true);
        }
        if ($bundle_type !== null) {
            $queryParams['bundleType'] = $bundle_type;
        }
        // query params
        if (is_array($category_id)) {
            $category_id = ObjectSerializer::serializeCollection($category_id, '', true);
        }
        if ($category_id !== null) {
            $queryParams['categoryId'] = $category_id;
        }
        // query params
        if (is_array($any_category_id)) {
            $any_category_id = ObjectSerializer::serializeCollection($any_category_id, '', true);
        }
        if ($any_category_id !== null) {
            $queryParams['anyCategoryId'] = $any_category_id;
        }
        // query params
        if (is_array($all_category_ids)) {
            $all_category_ids = ObjectSerializer::serializeCollection($all_category_ids, '', true);
        }
        if ($all_category_ids !== null) {
            $queryParams['allCategoryIds'] = $all_category_ids;
        }
        // query params
        if (is_array($any_characteristic_id)) {
            $any_characteristic_id = ObjectSerializer::serializeCollection($any_characteristic_id, '', true);
        }
        if ($any_characteristic_id !== null) {
            $queryParams['anyCharacteristicId'] = $any_characteristic_id;
        }
        // query params
        if (is_array($all_characteristic_ids)) {
            $all_characteristic_ids = ObjectSerializer::serializeCollection($all_characteristic_ids, '', true);
        }
        if ($all_characteristic_ids !== null) {
            $queryParams['allCharacteristicIds'] = $all_characteristic_ids;
        }
        // query params
        if (is_array($client_id)) {
            $client_id = ObjectSerializer::serializeCollection($client_id, '', true);
        }
        if ($client_id !== null) {
            $queryParams['clientId'] = $client_id;
        }
        // query params
        if (is_array($any_client_id)) {
            $any_client_id = ObjectSerializer::serializeCollection($any_client_id, '', true);
        }
        if ($any_client_id !== null) {
            $queryParams['anyClientId'] = $any_client_id;
        }
        // query params
        if (is_array($all_client_ids)) {
            $all_client_ids = ObjectSerializer::serializeCollection($all_client_ids, '', true);
        }
        if ($all_client_ids !== null) {
            $queryParams['allClientIds'] = $all_client_ids;
        }
        // query params
        if (is_array($automatic_client_visibilities)) {
            $automatic_client_visibilities = ObjectSerializer::serializeCollection($automatic_client_visibilities, '', true);
        }
        if ($automatic_client_visibilities !== null) {
            $queryParams['automaticClientVisibilities'] = $automatic_client_visibilities;
        }
        // query params
        if (is_array($image_has_market_id)) {
            $image_has_market_id = ObjectSerializer::serializeCollection($image_has_market_id, '', true);
        }
        if ($image_has_market_id !== null) {
            $queryParams['imageHasMarketId'] = $image_has_market_id;
        }
        // query params
        if (is_array($flag1)) {
            $flag1 = ObjectSerializer::serializeCollection($flag1, '', true);
        }
        if ($flag1 !== null) {
            $queryParams['flag1'] = $flag1;
        }
        // query params
        if (is_array($flag2)) {
            $flag2 = ObjectSerializer::serializeCollection($flag2, '', true);
        }
        if ($flag2 !== null) {
            $queryParams['flag2'] = $flag2;
        }
        // query params
        if (is_array($manufacturer_id)) {
            $manufacturer_id = ObjectSerializer::serializeCollection($manufacturer_id, '', true);
        }
        if ($manufacturer_id !== null) {
            $queryParams['manufacturerId'] = $manufacturer_id;
        }
        // query params
        if (is_array($any_manufacturer_id)) {
            $any_manufacturer_id = ObjectSerializer::serializeCollection($any_manufacturer_id, '', true);
        }
        if ($any_manufacturer_id !== null) {
            $queryParams['anyManufacturerId'] = $any_manufacturer_id;
        }
        // query params
        if (is_array($item_type)) {
            $item_type = ObjectSerializer::serializeCollection($item_type, '', true);
        }
        if ($item_type !== null) {
            $queryParams['itemType'] = $item_type;
        }
        // query params
        if (is_array($market_id)) {
            $market_id = ObjectSerializer::serializeCollection($market_id, '', true);
        }
        if ($market_id !== null) {
            $queryParams['marketId'] = $market_id;
        }
        // query params
        if (is_array($any_market_id)) {
            $any_market_id = ObjectSerializer::serializeCollection($any_market_id, '', true);
        }
        if ($any_market_id !== null) {
            $queryParams['anyMarketId'] = $any_market_id;
        }
        // query params
        if (is_array($all_market_ids)) {
            $all_market_ids = ObjectSerializer::serializeCollection($all_market_ids, '', true);
        }
        if ($all_market_ids !== null) {
            $queryParams['allMarketIds'] = $all_market_ids;
        }
        // query params
        if (is_array($price_between)) {
            $price_between = ObjectSerializer::serializeCollection($price_between, '', true);
        }
        if ($price_between !== null) {
            $queryParams['priceBetween'] = $price_between;
        }
        // query params
        if (is_array($price_between_by_id)) {
            $price_between_by_id = ObjectSerializer::serializeCollection($price_between_by_id, '', true);
        }
        if ($price_between_by_id !== null) {
            $queryParams['priceBetweenById'] = $price_between_by_id;
        }
        // query params
        if (is_array($any_sales_price_id)) {
            $any_sales_price_id = ObjectSerializer::serializeCollection($any_sales_price_id, '', true);
        }
        if ($any_sales_price_id !== null) {
            $queryParams['anySalesPriceId'] = $any_sales_price_id;
        }
        // query params
        if (is_array($property_selection_id)) {
            $property_selection_id = ObjectSerializer::serializeCollection($property_selection_id, '', true);
        }
        if ($property_selection_id !== null) {
            $queryParams['propertySelectionId'] = $property_selection_id;
        }
        // query params
        if (is_array($any_property_selection_id)) {
            $any_property_selection_id = ObjectSerializer::serializeCollection($any_property_selection_id, '', true);
        }
        if ($any_property_selection_id !== null) {
            $queryParams['anyPropertySelectionId'] = $any_property_selection_id;
        }
        // query params
        if (is_array($all_property_selection_ids)) {
            $all_property_selection_ids = ObjectSerializer::serializeCollection($all_property_selection_ids, '', true);
        }
        if ($all_property_selection_ids !== null) {
            $queryParams['allPropertySelectionIds'] = $all_property_selection_ids;
        }
        // query params
        if (is_array($has_name_in_language)) {
            $has_name_in_language = ObjectSerializer::serializeCollection($has_name_in_language, '', true);
        }
        if ($has_name_in_language !== null) {
            $queryParams['hasNameInLanguage'] = $has_name_in_language;
        }
        // query params
        if (is_array($created_at)) {
            $created_at = ObjectSerializer::serializeCollection($created_at, '', true);
        }
        if ($created_at !== null) {
            $queryParams['createdAt'] = $created_at;
        }
        // query params
        if (is_array($updated_at)) {
            $updated_at = ObjectSerializer::serializeCollection($updated_at, '', true);
        }
        if ($updated_at !== null) {
            $queryParams['updatedAt'] = $updated_at;
        }
        // query params
        if (is_array($item_created_at)) {
            $item_created_at = ObjectSerializer::serializeCollection($item_created_at, '', true);
        }
        if ($item_created_at !== null) {
            $queryParams['itemCreatedAt'] = $item_created_at;
        }
        // query params
        if (is_array($item_updated_at)) {
            $item_updated_at = ObjectSerializer::serializeCollection($item_updated_at, '', true);
        }
        if ($item_updated_at !== null) {
            $queryParams['itemUpdatedAt'] = $item_updated_at;
        }
        // query params
        if (is_array($availability_updated_at)) {
            $availability_updated_at = ObjectSerializer::serializeCollection($availability_updated_at, '', true);
        }
        if ($availability_updated_at !== null) {
            $queryParams['availabilityUpdatedAt'] = $availability_updated_at;
        }
        // query params
        if (is_array($stock_updated_at)) {
            $stock_updated_at = ObjectSerializer::serializeCollection($stock_updated_at, '', true);
        }
        if ($stock_updated_at !== null) {
            $queryParams['stockUpdatedAt'] = $stock_updated_at;
        }
        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
