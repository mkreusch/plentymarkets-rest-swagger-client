<?php
/**
 * PropertyApi
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0-beta2
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * PropertyApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class PropertyApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation restPropertiesAmazonsGet
     *
     * List property amazons
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyAmazon[]
     */
    public function restPropertiesAmazonsGet()
    {
        list($response) = $this->restPropertiesAmazonsGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPropertiesAmazonsGetWithHttpInfo
     *
     * List property amazons
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyAmazon[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesAmazonsGetWithHttpInfo()
    {
        $request = $this->restPropertiesAmazonsGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyAmazon[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyAmazon[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyAmazon[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyAmazon[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesAmazonsGetAsync
     *
     * List property amazons
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesAmazonsGetAsync()
    {
        return $this->restPropertiesAmazonsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesAmazonsGetAsyncWithHttpInfo
     *
     * List property amazons
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesAmazonsGetAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\PropertyAmazon[]';
        $request = $this->restPropertiesAmazonsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesAmazonsGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesAmazonsGetRequest()
    {

        $resourcePath = '/rest/properties/amazons';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesAmazonsPost
     *
     * Create one or multiple property amazon
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $platform The platform of the property amazon (required)
     * @param  string $category The category of the property amazon (required)
     * @param  string $field The field of the property amazon (required)
     * @param  \OpenAPI\Client\Model\InlineObject213 $_rest_properties_amazons _rest_properties_amazons (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyAmazon
     */
    public function restPropertiesAmazonsPost($property_id, $platform, $category, $field, $_rest_properties_amazons = null)
    {
        list($response) = $this->restPropertiesAmazonsPostWithHttpInfo($property_id, $platform, $category, $field, $_rest_properties_amazons);
        return $response;
    }

    /**
     * Operation restPropertiesAmazonsPostWithHttpInfo
     *
     * Create one or multiple property amazon
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $platform The platform of the property amazon (required)
     * @param  string $category The category of the property amazon (required)
     * @param  string $field The field of the property amazon (required)
     * @param  \OpenAPI\Client\Model\InlineObject213 $_rest_properties_amazons (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyAmazon, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesAmazonsPostWithHttpInfo($property_id, $platform, $category, $field, $_rest_properties_amazons = null)
    {
        $request = $this->restPropertiesAmazonsPostRequest($property_id, $platform, $category, $field, $_rest_properties_amazons);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyAmazon' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyAmazon', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyAmazon';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyAmazon',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesAmazonsPostAsync
     *
     * Create one or multiple property amazon
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $platform The platform of the property amazon (required)
     * @param  string $category The category of the property amazon (required)
     * @param  string $field The field of the property amazon (required)
     * @param  \OpenAPI\Client\Model\InlineObject213 $_rest_properties_amazons (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesAmazonsPostAsync($property_id, $platform, $category, $field, $_rest_properties_amazons = null)
    {
        return $this->restPropertiesAmazonsPostAsyncWithHttpInfo($property_id, $platform, $category, $field, $_rest_properties_amazons)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesAmazonsPostAsyncWithHttpInfo
     *
     * Create one or multiple property amazon
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $platform The platform of the property amazon (required)
     * @param  string $category The category of the property amazon (required)
     * @param  string $field The field of the property amazon (required)
     * @param  \OpenAPI\Client\Model\InlineObject213 $_rest_properties_amazons (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesAmazonsPostAsyncWithHttpInfo($property_id, $platform, $category, $field, $_rest_properties_amazons = null)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyAmazon';
        $request = $this->restPropertiesAmazonsPostRequest($property_id, $platform, $category, $field, $_rest_properties_amazons);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesAmazonsPost'
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $platform The platform of the property amazon (required)
     * @param  string $category The category of the property amazon (required)
     * @param  string $field The field of the property amazon (required)
     * @param  \OpenAPI\Client\Model\InlineObject213 $_rest_properties_amazons (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesAmazonsPostRequest($property_id, $platform, $category, $field, $_rest_properties_amazons = null)
    {
        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesAmazonsPost'
            );
        }
        // verify the required parameter 'platform' is set
        if ($platform === null || (is_array($platform) && count($platform) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $platform when calling restPropertiesAmazonsPost'
            );
        }
        // verify the required parameter 'category' is set
        if ($category === null || (is_array($category) && count($category) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category when calling restPropertiesAmazonsPost'
            );
        }
        // verify the required parameter 'field' is set
        if ($field === null || (is_array($field) && count($field) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field when calling restPropertiesAmazonsPost'
            );
        }

        $resourcePath = '/rest/properties/amazons';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($property_id)) {
            $property_id = ObjectSerializer::serializeCollection($property_id, '', true);
        }
        if ($property_id !== null) {
            $queryParams['propertyId'] = $property_id;
        }
        // query params
        if (is_array($platform)) {
            $platform = ObjectSerializer::serializeCollection($platform, '', true);
        }
        if ($platform !== null) {
            $queryParams['platform'] = $platform;
        }
        // query params
        if (is_array($category)) {
            $category = ObjectSerializer::serializeCollection($category, '', true);
        }
        if ($category !== null) {
            $queryParams['category'] = $category;
        }
        // query params
        if (is_array($field)) {
            $field = ObjectSerializer::serializeCollection($field, '', true);
        }
        if ($field !== null) {
            $queryParams['field'] = $field;
        }



        // body params
        $_tempBody = null;
        if (isset($_rest_properties_amazons)) {
            $_tempBody = $_rest_properties_amazons;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesAmazonsPropertyAmazonIdDelete
     *
     * Delete a property amazon
     *
     * @param  int $property_amazon_id The ID of the property amazon (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restPropertiesAmazonsPropertyAmazonIdDelete($property_amazon_id)
    {
        $this->restPropertiesAmazonsPropertyAmazonIdDeleteWithHttpInfo($property_amazon_id);
    }

    /**
     * Operation restPropertiesAmazonsPropertyAmazonIdDeleteWithHttpInfo
     *
     * Delete a property amazon
     *
     * @param  int $property_amazon_id The ID of the property amazon (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesAmazonsPropertyAmazonIdDeleteWithHttpInfo($property_amazon_id)
    {
        $request = $this->restPropertiesAmazonsPropertyAmazonIdDeleteRequest($property_amazon_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesAmazonsPropertyAmazonIdDeleteAsync
     *
     * Delete a property amazon
     *
     * @param  int $property_amazon_id The ID of the property amazon (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesAmazonsPropertyAmazonIdDeleteAsync($property_amazon_id)
    {
        return $this->restPropertiesAmazonsPropertyAmazonIdDeleteAsyncWithHttpInfo($property_amazon_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesAmazonsPropertyAmazonIdDeleteAsyncWithHttpInfo
     *
     * Delete a property amazon
     *
     * @param  int $property_amazon_id The ID of the property amazon (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesAmazonsPropertyAmazonIdDeleteAsyncWithHttpInfo($property_amazon_id)
    {
        $returnType = '';
        $request = $this->restPropertiesAmazonsPropertyAmazonIdDeleteRequest($property_amazon_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesAmazonsPropertyAmazonIdDelete'
     *
     * @param  int $property_amazon_id The ID of the property amazon (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesAmazonsPropertyAmazonIdDeleteRequest($property_amazon_id)
    {
        // verify the required parameter 'property_amazon_id' is set
        if ($property_amazon_id === null || (is_array($property_amazon_id) && count($property_amazon_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_amazon_id when calling restPropertiesAmazonsPropertyAmazonIdDelete'
            );
        }

        $resourcePath = '/rest/properties/amazons/{propertyAmazonId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_amazon_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyAmazonId' . '}',
                ObjectSerializer::toPathValue($property_amazon_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesAmazonsPropertyAmazonIdGet
     *
     * Get a property amazon
     *
     * @param  int $property_amazon_id The ID of the property amazon (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyAmazon
     */
    public function restPropertiesAmazonsPropertyAmazonIdGet($property_amazon_id)
    {
        list($response) = $this->restPropertiesAmazonsPropertyAmazonIdGetWithHttpInfo($property_amazon_id);
        return $response;
    }

    /**
     * Operation restPropertiesAmazonsPropertyAmazonIdGetWithHttpInfo
     *
     * Get a property amazon
     *
     * @param  int $property_amazon_id The ID of the property amazon (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyAmazon, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesAmazonsPropertyAmazonIdGetWithHttpInfo($property_amazon_id)
    {
        $request = $this->restPropertiesAmazonsPropertyAmazonIdGetRequest($property_amazon_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyAmazon' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyAmazon', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyAmazon';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyAmazon',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesAmazonsPropertyAmazonIdGetAsync
     *
     * Get a property amazon
     *
     * @param  int $property_amazon_id The ID of the property amazon (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesAmazonsPropertyAmazonIdGetAsync($property_amazon_id)
    {
        return $this->restPropertiesAmazonsPropertyAmazonIdGetAsyncWithHttpInfo($property_amazon_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesAmazonsPropertyAmazonIdGetAsyncWithHttpInfo
     *
     * Get a property amazon
     *
     * @param  int $property_amazon_id The ID of the property amazon (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesAmazonsPropertyAmazonIdGetAsyncWithHttpInfo($property_amazon_id)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyAmazon';
        $request = $this->restPropertiesAmazonsPropertyAmazonIdGetRequest($property_amazon_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesAmazonsPropertyAmazonIdGet'
     *
     * @param  int $property_amazon_id The ID of the property amazon (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesAmazonsPropertyAmazonIdGetRequest($property_amazon_id)
    {
        // verify the required parameter 'property_amazon_id' is set
        if ($property_amazon_id === null || (is_array($property_amazon_id) && count($property_amazon_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_amazon_id when calling restPropertiesAmazonsPropertyAmazonIdGet'
            );
        }

        $resourcePath = '/rest/properties/amazons/{propertyAmazonId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_amazon_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyAmazonId' . '}',
                ObjectSerializer::toPathValue($property_amazon_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesAmazonsPut
     *
     * Update one or multiple property amazon
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyAmazon
     */
    public function restPropertiesAmazonsPut()
    {
        list($response) = $this->restPropertiesAmazonsPutWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPropertiesAmazonsPutWithHttpInfo
     *
     * Update one or multiple property amazon
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyAmazon, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesAmazonsPutWithHttpInfo()
    {
        $request = $this->restPropertiesAmazonsPutRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyAmazon' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyAmazon', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyAmazon';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyAmazon',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesAmazonsPutAsync
     *
     * Update one or multiple property amazon
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesAmazonsPutAsync()
    {
        return $this->restPropertiesAmazonsPutAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesAmazonsPutAsyncWithHttpInfo
     *
     * Update one or multiple property amazon
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesAmazonsPutAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\PropertyAmazon';
        $request = $this->restPropertiesAmazonsPutRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesAmazonsPut'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesAmazonsPutRequest()
    {

        $resourcePath = '/rest/properties/amazons';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesAvailabilitiesAvailabilityIdDelete
     *
     * Delete an availability
     *
     * @param  int $availability_id The ID of the availability (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restPropertiesAvailabilitiesAvailabilityIdDelete($availability_id)
    {
        $this->restPropertiesAvailabilitiesAvailabilityIdDeleteWithHttpInfo($availability_id);
    }

    /**
     * Operation restPropertiesAvailabilitiesAvailabilityIdDeleteWithHttpInfo
     *
     * Delete an availability
     *
     * @param  int $availability_id The ID of the availability (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesAvailabilitiesAvailabilityIdDeleteWithHttpInfo($availability_id)
    {
        $request = $this->restPropertiesAvailabilitiesAvailabilityIdDeleteRequest($availability_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesAvailabilitiesAvailabilityIdDeleteAsync
     *
     * Delete an availability
     *
     * @param  int $availability_id The ID of the availability (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesAvailabilitiesAvailabilityIdDeleteAsync($availability_id)
    {
        return $this->restPropertiesAvailabilitiesAvailabilityIdDeleteAsyncWithHttpInfo($availability_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesAvailabilitiesAvailabilityIdDeleteAsyncWithHttpInfo
     *
     * Delete an availability
     *
     * @param  int $availability_id The ID of the availability (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesAvailabilitiesAvailabilityIdDeleteAsyncWithHttpInfo($availability_id)
    {
        $returnType = '';
        $request = $this->restPropertiesAvailabilitiesAvailabilityIdDeleteRequest($availability_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesAvailabilitiesAvailabilityIdDelete'
     *
     * @param  int $availability_id The ID of the availability (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesAvailabilitiesAvailabilityIdDeleteRequest($availability_id)
    {
        // verify the required parameter 'availability_id' is set
        if ($availability_id === null || (is_array($availability_id) && count($availability_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $availability_id when calling restPropertiesAvailabilitiesAvailabilityIdDelete'
            );
        }

        $resourcePath = '/rest/properties/availabilities/{availabilityId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($availability_id !== null) {
            $resourcePath = str_replace(
                '{' . 'availabilityId' . '}',
                ObjectSerializer::toPathValue($availability_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesAvailabilitiesAvailabilityIdGet
     *
     * Get an availability
     *
     * @param  int $availability_id The ID of the property availability (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyAvailability
     */
    public function restPropertiesAvailabilitiesAvailabilityIdGet($availability_id)
    {
        list($response) = $this->restPropertiesAvailabilitiesAvailabilityIdGetWithHttpInfo($availability_id);
        return $response;
    }

    /**
     * Operation restPropertiesAvailabilitiesAvailabilityIdGetWithHttpInfo
     *
     * Get an availability
     *
     * @param  int $availability_id The ID of the property availability (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyAvailability, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesAvailabilitiesAvailabilityIdGetWithHttpInfo($availability_id)
    {
        $request = $this->restPropertiesAvailabilitiesAvailabilityIdGetRequest($availability_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyAvailability' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyAvailability', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyAvailability';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyAvailability',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesAvailabilitiesAvailabilityIdGetAsync
     *
     * Get an availability
     *
     * @param  int $availability_id The ID of the property availability (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesAvailabilitiesAvailabilityIdGetAsync($availability_id)
    {
        return $this->restPropertiesAvailabilitiesAvailabilityIdGetAsyncWithHttpInfo($availability_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesAvailabilitiesAvailabilityIdGetAsyncWithHttpInfo
     *
     * Get an availability
     *
     * @param  int $availability_id The ID of the property availability (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesAvailabilitiesAvailabilityIdGetAsyncWithHttpInfo($availability_id)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyAvailability';
        $request = $this->restPropertiesAvailabilitiesAvailabilityIdGetRequest($availability_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesAvailabilitiesAvailabilityIdGet'
     *
     * @param  int $availability_id The ID of the property availability (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesAvailabilitiesAvailabilityIdGetRequest($availability_id)
    {
        // verify the required parameter 'availability_id' is set
        if ($availability_id === null || (is_array($availability_id) && count($availability_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $availability_id when calling restPropertiesAvailabilitiesAvailabilityIdGet'
            );
        }

        $resourcePath = '/rest/properties/availabilities/{availabilityId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($availability_id !== null) {
            $resourcePath = str_replace(
                '{' . 'availabilityId' . '}',
                ObjectSerializer::toPathValue($availability_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesAvailabilitiesAvailabilityIdPut
     *
     * Update an availability
     *
     * @param  int $availability_id The ID of the availability (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyAvailability
     */
    public function restPropertiesAvailabilitiesAvailabilityIdPut($availability_id)
    {
        list($response) = $this->restPropertiesAvailabilitiesAvailabilityIdPutWithHttpInfo($availability_id);
        return $response;
    }

    /**
     * Operation restPropertiesAvailabilitiesAvailabilityIdPutWithHttpInfo
     *
     * Update an availability
     *
     * @param  int $availability_id The ID of the availability (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyAvailability, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesAvailabilitiesAvailabilityIdPutWithHttpInfo($availability_id)
    {
        $request = $this->restPropertiesAvailabilitiesAvailabilityIdPutRequest($availability_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyAvailability' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyAvailability', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyAvailability';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyAvailability',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesAvailabilitiesAvailabilityIdPutAsync
     *
     * Update an availability
     *
     * @param  int $availability_id The ID of the availability (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesAvailabilitiesAvailabilityIdPutAsync($availability_id)
    {
        return $this->restPropertiesAvailabilitiesAvailabilityIdPutAsyncWithHttpInfo($availability_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesAvailabilitiesAvailabilityIdPutAsyncWithHttpInfo
     *
     * Update an availability
     *
     * @param  int $availability_id The ID of the availability (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesAvailabilitiesAvailabilityIdPutAsyncWithHttpInfo($availability_id)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyAvailability';
        $request = $this->restPropertiesAvailabilitiesAvailabilityIdPutRequest($availability_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesAvailabilitiesAvailabilityIdPut'
     *
     * @param  int $availability_id The ID of the availability (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesAvailabilitiesAvailabilityIdPutRequest($availability_id)
    {
        // verify the required parameter 'availability_id' is set
        if ($availability_id === null || (is_array($availability_id) && count($availability_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $availability_id when calling restPropertiesAvailabilitiesAvailabilityIdPut'
            );
        }

        $resourcePath = '/rest/properties/availabilities/{availabilityId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($availability_id !== null) {
            $resourcePath = str_replace(
                '{' . 'availabilityId' . '}',
                ObjectSerializer::toPathValue($availability_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesAvailabilitiesGet
     *
     * List availabilities
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyAvailability[]
     */
    public function restPropertiesAvailabilitiesGet()
    {
        list($response) = $this->restPropertiesAvailabilitiesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPropertiesAvailabilitiesGetWithHttpInfo
     *
     * List availabilities
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyAvailability[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesAvailabilitiesGetWithHttpInfo()
    {
        $request = $this->restPropertiesAvailabilitiesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyAvailability[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyAvailability[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyAvailability[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyAvailability[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesAvailabilitiesGetAsync
     *
     * List availabilities
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesAvailabilitiesGetAsync()
    {
        return $this->restPropertiesAvailabilitiesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesAvailabilitiesGetAsyncWithHttpInfo
     *
     * List availabilities
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesAvailabilitiesGetAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\PropertyAvailability[]';
        $request = $this->restPropertiesAvailabilitiesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesAvailabilitiesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesAvailabilitiesGetRequest()
    {

        $resourcePath = '/rest/properties/availabilities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesAvailabilitiesPost
     *
     * Create an availability
     *
     * @param  int $property_id The ID of the property (required)
     * @param  int $type The type of the availability (required)
     * @param  int $value The value of the availability (required)
     * @param  \OpenAPI\Client\Model\InlineObject214 $_rest_properties_availabilities _rest_properties_availabilities (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyAvailability
     */
    public function restPropertiesAvailabilitiesPost($property_id, $type, $value, $_rest_properties_availabilities = null)
    {
        list($response) = $this->restPropertiesAvailabilitiesPostWithHttpInfo($property_id, $type, $value, $_rest_properties_availabilities);
        return $response;
    }

    /**
     * Operation restPropertiesAvailabilitiesPostWithHttpInfo
     *
     * Create an availability
     *
     * @param  int $property_id The ID of the property (required)
     * @param  int $type The type of the availability (required)
     * @param  int $value The value of the availability (required)
     * @param  \OpenAPI\Client\Model\InlineObject214 $_rest_properties_availabilities (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyAvailability, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesAvailabilitiesPostWithHttpInfo($property_id, $type, $value, $_rest_properties_availabilities = null)
    {
        $request = $this->restPropertiesAvailabilitiesPostRequest($property_id, $type, $value, $_rest_properties_availabilities);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyAvailability' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyAvailability', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyAvailability';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyAvailability',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesAvailabilitiesPostAsync
     *
     * Create an availability
     *
     * @param  int $property_id The ID of the property (required)
     * @param  int $type The type of the availability (required)
     * @param  int $value The value of the availability (required)
     * @param  \OpenAPI\Client\Model\InlineObject214 $_rest_properties_availabilities (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesAvailabilitiesPostAsync($property_id, $type, $value, $_rest_properties_availabilities = null)
    {
        return $this->restPropertiesAvailabilitiesPostAsyncWithHttpInfo($property_id, $type, $value, $_rest_properties_availabilities)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesAvailabilitiesPostAsyncWithHttpInfo
     *
     * Create an availability
     *
     * @param  int $property_id The ID of the property (required)
     * @param  int $type The type of the availability (required)
     * @param  int $value The value of the availability (required)
     * @param  \OpenAPI\Client\Model\InlineObject214 $_rest_properties_availabilities (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesAvailabilitiesPostAsyncWithHttpInfo($property_id, $type, $value, $_rest_properties_availabilities = null)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyAvailability';
        $request = $this->restPropertiesAvailabilitiesPostRequest($property_id, $type, $value, $_rest_properties_availabilities);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesAvailabilitiesPost'
     *
     * @param  int $property_id The ID of the property (required)
     * @param  int $type The type of the availability (required)
     * @param  int $value The value of the availability (required)
     * @param  \OpenAPI\Client\Model\InlineObject214 $_rest_properties_availabilities (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesAvailabilitiesPostRequest($property_id, $type, $value, $_rest_properties_availabilities = null)
    {
        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesAvailabilitiesPost'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling restPropertiesAvailabilitiesPost'
            );
        }
        // verify the required parameter 'value' is set
        if ($value === null || (is_array($value) && count($value) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $value when calling restPropertiesAvailabilitiesPost'
            );
        }

        $resourcePath = '/rest/properties/availabilities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($property_id)) {
            $property_id = ObjectSerializer::serializeCollection($property_id, '', true);
        }
        if ($property_id !== null) {
            $queryParams['propertyId'] = $property_id;
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($value)) {
            $value = ObjectSerializer::serializeCollection($value, '', true);
        }
        if ($value !== null) {
            $queryParams['value'] = $value;
        }



        // body params
        $_tempBody = null;
        if (isset($_rest_properties_availabilities)) {
            $_tempBody = $_rest_properties_availabilities;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesDestinationsGet
     *
     * Get property destinations
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restPropertiesDestinationsGet()
    {
        list($response) = $this->restPropertiesDestinationsGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPropertiesDestinationsGetWithHttpInfo
     *
     * Get property destinations
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesDestinationsGetWithHttpInfo()
    {
        $request = $this->restPropertiesDestinationsGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesDestinationsGetAsync
     *
     * Get property destinations
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesDestinationsGetAsync()
    {
        return $this->restPropertiesDestinationsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesDestinationsGetAsyncWithHttpInfo
     *
     * Get property destinations
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesDestinationsGetAsyncWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->restPropertiesDestinationsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesDestinationsGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesDestinationsGetRequest()
    {

        $resourcePath = '/rest/properties/destinations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGet
     *
     * List properties
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Property[]
     */
    public function restPropertiesGet()
    {
        list($response) = $this->restPropertiesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPropertiesGetWithHttpInfo
     *
     * List properties
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Property[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGetWithHttpInfo()
    {
        $request = $this->restPropertiesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Property[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Property[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Property[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Property[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGetAsync
     *
     * List properties
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGetAsync()
    {
        return $this->restPropertiesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGetAsyncWithHttpInfo
     *
     * List properties
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGetAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\Property[]';
        $request = $this->restPropertiesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesGetRequest()
    {

        $resourcePath = '/rest/properties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsGet
     *
     * List property groups
     *
     * @param  int $group_id The ID of the group (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyGroup[]
     */
    public function restPropertiesGroupsGet($group_id)
    {
        list($response) = $this->restPropertiesGroupsGetWithHttpInfo($group_id);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsGetWithHttpInfo
     *
     * List property groups
     *
     * @param  int $group_id The ID of the group (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyGroup[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsGetWithHttpInfo($group_id)
    {
        $request = $this->restPropertiesGroupsGetRequest($group_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyGroup[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyGroup[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyGroup[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyGroup[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsGetAsync
     *
     * List property groups
     *
     * @param  int $group_id The ID of the group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsGetAsync($group_id)
    {
        return $this->restPropertiesGroupsGetAsyncWithHttpInfo($group_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsGetAsyncWithHttpInfo
     *
     * List property groups
     *
     * @param  int $group_id The ID of the group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsGetAsyncWithHttpInfo($group_id)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyGroup[]';
        $request = $this->restPropertiesGroupsGetRequest($group_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsGet'
     *
     * @param  int $group_id The ID of the group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesGroupsGetRequest($group_id)
    {
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling restPropertiesGroupsGet'
            );
        }

        $resourcePath = '/rest/properties/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($group_id)) {
            $group_id = ObjectSerializer::serializeCollection($group_id, '', true);
        }
        if ($group_id !== null) {
            $queryParams['groupId'] = $group_id;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsGroupIdGet
     *
     * Get a property group
     *
     * @param  int $group_id The ID of the group (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyGroup
     */
    public function restPropertiesGroupsGroupIdGet($group_id)
    {
        list($response) = $this->restPropertiesGroupsGroupIdGetWithHttpInfo($group_id);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsGroupIdGetWithHttpInfo
     *
     * Get a property group
     *
     * @param  int $group_id The ID of the group (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsGroupIdGetWithHttpInfo($group_id)
    {
        $request = $this->restPropertiesGroupsGroupIdGetRequest($group_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyGroup' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyGroup';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsGroupIdGetAsync
     *
     * Get a property group
     *
     * @param  int $group_id The ID of the group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsGroupIdGetAsync($group_id)
    {
        return $this->restPropertiesGroupsGroupIdGetAsyncWithHttpInfo($group_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsGroupIdGetAsyncWithHttpInfo
     *
     * Get a property group
     *
     * @param  int $group_id The ID of the group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsGroupIdGetAsyncWithHttpInfo($group_id)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyGroup';
        $request = $this->restPropertiesGroupsGroupIdGetRequest($group_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsGroupIdGet'
     *
     * @param  int $group_id The ID of the group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesGroupsGroupIdGetRequest($group_id)
    {
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling restPropertiesGroupsGroupIdGet'
            );
        }

        $resourcePath = '/rest/properties/groups/{groupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsGroupIdPropertiesPost
     *
     * Mass attach propertyId and groupId collection into the pivot table.
     *
     * @param  int $group_id The ID of the group (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restPropertiesGroupsGroupIdPropertiesPost($group_id)
    {
        list($response) = $this->restPropertiesGroupsGroupIdPropertiesPostWithHttpInfo($group_id);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsGroupIdPropertiesPostWithHttpInfo
     *
     * Mass attach propertyId and groupId collection into the pivot table.
     *
     * @param  int $group_id The ID of the group (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsGroupIdPropertiesPostWithHttpInfo($group_id)
    {
        $request = $this->restPropertiesGroupsGroupIdPropertiesPostRequest($group_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsGroupIdPropertiesPostAsync
     *
     * Mass attach propertyId and groupId collection into the pivot table.
     *
     * @param  int $group_id The ID of the group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsGroupIdPropertiesPostAsync($group_id)
    {
        return $this->restPropertiesGroupsGroupIdPropertiesPostAsyncWithHttpInfo($group_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsGroupIdPropertiesPostAsyncWithHttpInfo
     *
     * Mass attach propertyId and groupId collection into the pivot table.
     *
     * @param  int $group_id The ID of the group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsGroupIdPropertiesPostAsyncWithHttpInfo($group_id)
    {
        $returnType = 'object';
        $request = $this->restPropertiesGroupsGroupIdPropertiesPostRequest($group_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsGroupIdPropertiesPost'
     *
     * @param  int $group_id The ID of the group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesGroupsGroupIdPropertiesPostRequest($group_id)
    {
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling restPropertiesGroupsGroupIdPropertiesPost'
            );
        }

        $resourcePath = '/rest/properties/groups/{groupId}/properties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsGroupIdPropertiesPropertyIdDelete
     *
     * Detach a property from a property group.
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restPropertiesGroupsGroupIdPropertiesPropertyIdDelete($group_id, $property_id)
    {
        list($response) = $this->restPropertiesGroupsGroupIdPropertiesPropertyIdDeleteWithHttpInfo($group_id, $property_id);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsGroupIdPropertiesPropertyIdDeleteWithHttpInfo
     *
     * Detach a property from a property group.
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsGroupIdPropertiesPropertyIdDeleteWithHttpInfo($group_id, $property_id)
    {
        $request = $this->restPropertiesGroupsGroupIdPropertiesPropertyIdDeleteRequest($group_id, $property_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsGroupIdPropertiesPropertyIdDeleteAsync
     *
     * Detach a property from a property group.
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsGroupIdPropertiesPropertyIdDeleteAsync($group_id, $property_id)
    {
        return $this->restPropertiesGroupsGroupIdPropertiesPropertyIdDeleteAsyncWithHttpInfo($group_id, $property_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsGroupIdPropertiesPropertyIdDeleteAsyncWithHttpInfo
     *
     * Detach a property from a property group.
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsGroupIdPropertiesPropertyIdDeleteAsyncWithHttpInfo($group_id, $property_id)
    {
        $returnType = 'object';
        $request = $this->restPropertiesGroupsGroupIdPropertiesPropertyIdDeleteRequest($group_id, $property_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsGroupIdPropertiesPropertyIdDelete'
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesGroupsGroupIdPropertiesPropertyIdDeleteRequest($group_id, $property_id)
    {
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling restPropertiesGroupsGroupIdPropertiesPropertyIdDelete'
            );
        }
        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesGroupsGroupIdPropertiesPropertyIdDelete'
            );
        }

        $resourcePath = '/rest/properties/groups/{groupId}/properties/{propertyId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }
        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsGroupIdPropertiesPropertyIdPost
     *
     * Attach a property to a property group
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restPropertiesGroupsGroupIdPropertiesPropertyIdPost($group_id, $property_id)
    {
        list($response) = $this->restPropertiesGroupsGroupIdPropertiesPropertyIdPostWithHttpInfo($group_id, $property_id);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsGroupIdPropertiesPropertyIdPostWithHttpInfo
     *
     * Attach a property to a property group
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsGroupIdPropertiesPropertyIdPostWithHttpInfo($group_id, $property_id)
    {
        $request = $this->restPropertiesGroupsGroupIdPropertiesPropertyIdPostRequest($group_id, $property_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsGroupIdPropertiesPropertyIdPostAsync
     *
     * Attach a property to a property group
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsGroupIdPropertiesPropertyIdPostAsync($group_id, $property_id)
    {
        return $this->restPropertiesGroupsGroupIdPropertiesPropertyIdPostAsyncWithHttpInfo($group_id, $property_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsGroupIdPropertiesPropertyIdPostAsyncWithHttpInfo
     *
     * Attach a property to a property group
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsGroupIdPropertiesPropertyIdPostAsyncWithHttpInfo($group_id, $property_id)
    {
        $returnType = 'object';
        $request = $this->restPropertiesGroupsGroupIdPropertiesPropertyIdPostRequest($group_id, $property_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsGroupIdPropertiesPropertyIdPost'
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesGroupsGroupIdPropertiesPropertyIdPostRequest($group_id, $property_id)
    {
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling restPropertiesGroupsGroupIdPropertiesPropertyIdPost'
            );
        }
        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesGroupsGroupIdPropertiesPropertyIdPost'
            );
        }

        $resourcePath = '/rest/properties/groups/{groupId}/properties/{propertyId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }
        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsGroupIdPut
     *
     * Update a property group
     *
     * @param  int $group_id group_id (required)
     * @param  int $position The position  of the group (optional)
     * @param  int $names The names of the group. (optional)
     * @param  int $options The options of the group (optional)
     * @param  \OpenAPI\Client\Model\InlineObject218 $_rest_properties_groups_group_id _rest_properties_groups_group_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyGroup
     */
    public function restPropertiesGroupsGroupIdPut($group_id, $position = null, $names = null, $options = null, $_rest_properties_groups_group_id = null)
    {
        list($response) = $this->restPropertiesGroupsGroupIdPutWithHttpInfo($group_id, $position, $names, $options, $_rest_properties_groups_group_id);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsGroupIdPutWithHttpInfo
     *
     * Update a property group
     *
     * @param  int $group_id (required)
     * @param  int $position The position  of the group (optional)
     * @param  int $names The names of the group. (optional)
     * @param  int $options The options of the group (optional)
     * @param  \OpenAPI\Client\Model\InlineObject218 $_rest_properties_groups_group_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsGroupIdPutWithHttpInfo($group_id, $position = null, $names = null, $options = null, $_rest_properties_groups_group_id = null)
    {
        $request = $this->restPropertiesGroupsGroupIdPutRequest($group_id, $position, $names, $options, $_rest_properties_groups_group_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyGroup' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyGroup';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsGroupIdPutAsync
     *
     * Update a property group
     *
     * @param  int $group_id (required)
     * @param  int $position The position  of the group (optional)
     * @param  int $names The names of the group. (optional)
     * @param  int $options The options of the group (optional)
     * @param  \OpenAPI\Client\Model\InlineObject218 $_rest_properties_groups_group_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsGroupIdPutAsync($group_id, $position = null, $names = null, $options = null, $_rest_properties_groups_group_id = null)
    {
        return $this->restPropertiesGroupsGroupIdPutAsyncWithHttpInfo($group_id, $position, $names, $options, $_rest_properties_groups_group_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsGroupIdPutAsyncWithHttpInfo
     *
     * Update a property group
     *
     * @param  int $group_id (required)
     * @param  int $position The position  of the group (optional)
     * @param  int $names The names of the group. (optional)
     * @param  int $options The options of the group (optional)
     * @param  \OpenAPI\Client\Model\InlineObject218 $_rest_properties_groups_group_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsGroupIdPutAsyncWithHttpInfo($group_id, $position = null, $names = null, $options = null, $_rest_properties_groups_group_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyGroup';
        $request = $this->restPropertiesGroupsGroupIdPutRequest($group_id, $position, $names, $options, $_rest_properties_groups_group_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsGroupIdPut'
     *
     * @param  int $group_id (required)
     * @param  int $position The position  of the group (optional)
     * @param  int $names The names of the group. (optional)
     * @param  int $options The options of the group (optional)
     * @param  \OpenAPI\Client\Model\InlineObject218 $_rest_properties_groups_group_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesGroupsGroupIdPutRequest($group_id, $position = null, $names = null, $options = null, $_rest_properties_groups_group_id = null)
    {
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling restPropertiesGroupsGroupIdPut'
            );
        }

        $resourcePath = '/rest/properties/groups/{groupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($position)) {
            $position = ObjectSerializer::serializeCollection($position, '', true);
        }
        if ($position !== null) {
            $queryParams['position'] = $position;
        }
        // query params
        if (is_array($names)) {
            $names = ObjectSerializer::serializeCollection($names, '', true);
        }
        if ($names !== null) {
            $queryParams['names'] = $names;
        }
        // query params
        if (is_array($options)) {
            $options = ObjectSerializer::serializeCollection($options, '', true);
        }
        if ($options !== null) {
            $queryParams['options'] = $options;
        }


        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_properties_groups_group_id)) {
            $_tempBody = $_rest_properties_groups_group_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsNamesGet
     *
     * List group names
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyGroupName[]
     */
    public function restPropertiesGroupsNamesGet()
    {
        list($response) = $this->restPropertiesGroupsNamesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPropertiesGroupsNamesGetWithHttpInfo
     *
     * List group names
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyGroupName[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsNamesGetWithHttpInfo()
    {
        $request = $this->restPropertiesGroupsNamesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyGroupName[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyGroupName[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyGroupName[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyGroupName[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsNamesGetAsync
     *
     * List group names
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsNamesGetAsync()
    {
        return $this->restPropertiesGroupsNamesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsNamesGetAsyncWithHttpInfo
     *
     * List group names
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsNamesGetAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\PropertyGroupName[]';
        $request = $this->restPropertiesGroupsNamesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsNamesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesGroupsNamesGetRequest()
    {

        $resourcePath = '/rest/properties/groups/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsNamesGroupNameIdDelete
     *
     * Delete a group name
     *
     * @param  int $group_name_id The ID of the group name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restPropertiesGroupsNamesGroupNameIdDelete($group_name_id)
    {
        $this->restPropertiesGroupsNamesGroupNameIdDeleteWithHttpInfo($group_name_id);
    }

    /**
     * Operation restPropertiesGroupsNamesGroupNameIdDeleteWithHttpInfo
     *
     * Delete a group name
     *
     * @param  int $group_name_id The ID of the group name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsNamesGroupNameIdDeleteWithHttpInfo($group_name_id)
    {
        $request = $this->restPropertiesGroupsNamesGroupNameIdDeleteRequest($group_name_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsNamesGroupNameIdDeleteAsync
     *
     * Delete a group name
     *
     * @param  int $group_name_id The ID of the group name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsNamesGroupNameIdDeleteAsync($group_name_id)
    {
        return $this->restPropertiesGroupsNamesGroupNameIdDeleteAsyncWithHttpInfo($group_name_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsNamesGroupNameIdDeleteAsyncWithHttpInfo
     *
     * Delete a group name
     *
     * @param  int $group_name_id The ID of the group name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsNamesGroupNameIdDeleteAsyncWithHttpInfo($group_name_id)
    {
        $returnType = '';
        $request = $this->restPropertiesGroupsNamesGroupNameIdDeleteRequest($group_name_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsNamesGroupNameIdDelete'
     *
     * @param  int $group_name_id The ID of the group name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesGroupsNamesGroupNameIdDeleteRequest($group_name_id)
    {
        // verify the required parameter 'group_name_id' is set
        if ($group_name_id === null || (is_array($group_name_id) && count($group_name_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_name_id when calling restPropertiesGroupsNamesGroupNameIdDelete'
            );
        }

        $resourcePath = '/rest/properties/groups/names/{groupNameId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_name_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupNameId' . '}',
                ObjectSerializer::toPathValue($group_name_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsNamesGroupNameIdGet
     *
     * Get a group name
     *
     * @param  int $group_name_id The ID of the group name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyGroupName
     */
    public function restPropertiesGroupsNamesGroupNameIdGet($group_name_id)
    {
        list($response) = $this->restPropertiesGroupsNamesGroupNameIdGetWithHttpInfo($group_name_id);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsNamesGroupNameIdGetWithHttpInfo
     *
     * Get a group name
     *
     * @param  int $group_name_id The ID of the group name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyGroupName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsNamesGroupNameIdGetWithHttpInfo($group_name_id)
    {
        $request = $this->restPropertiesGroupsNamesGroupNameIdGetRequest($group_name_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyGroupName' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyGroupName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyGroupName';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyGroupName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsNamesGroupNameIdGetAsync
     *
     * Get a group name
     *
     * @param  int $group_name_id The ID of the group name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsNamesGroupNameIdGetAsync($group_name_id)
    {
        return $this->restPropertiesGroupsNamesGroupNameIdGetAsyncWithHttpInfo($group_name_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsNamesGroupNameIdGetAsyncWithHttpInfo
     *
     * Get a group name
     *
     * @param  int $group_name_id The ID of the group name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsNamesGroupNameIdGetAsyncWithHttpInfo($group_name_id)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyGroupName';
        $request = $this->restPropertiesGroupsNamesGroupNameIdGetRequest($group_name_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsNamesGroupNameIdGet'
     *
     * @param  int $group_name_id The ID of the group name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesGroupsNamesGroupNameIdGetRequest($group_name_id)
    {
        // verify the required parameter 'group_name_id' is set
        if ($group_name_id === null || (is_array($group_name_id) && count($group_name_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_name_id when calling restPropertiesGroupsNamesGroupNameIdGet'
            );
        }

        $resourcePath = '/rest/properties/groups/names/{groupNameId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_name_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupNameId' . '}',
                ObjectSerializer::toPathValue($group_name_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsNamesGroupNameIdPut
     *
     * Update a group name
     *
     * @param  int $group_name_id The ID of the group name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyGroupName
     */
    public function restPropertiesGroupsNamesGroupNameIdPut($group_name_id)
    {
        list($response) = $this->restPropertiesGroupsNamesGroupNameIdPutWithHttpInfo($group_name_id);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsNamesGroupNameIdPutWithHttpInfo
     *
     * Update a group name
     *
     * @param  int $group_name_id The ID of the group name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyGroupName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsNamesGroupNameIdPutWithHttpInfo($group_name_id)
    {
        $request = $this->restPropertiesGroupsNamesGroupNameIdPutRequest($group_name_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyGroupName' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyGroupName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyGroupName';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyGroupName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsNamesGroupNameIdPutAsync
     *
     * Update a group name
     *
     * @param  int $group_name_id The ID of the group name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsNamesGroupNameIdPutAsync($group_name_id)
    {
        return $this->restPropertiesGroupsNamesGroupNameIdPutAsyncWithHttpInfo($group_name_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsNamesGroupNameIdPutAsyncWithHttpInfo
     *
     * Update a group name
     *
     * @param  int $group_name_id The ID of the group name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsNamesGroupNameIdPutAsyncWithHttpInfo($group_name_id)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyGroupName';
        $request = $this->restPropertiesGroupsNamesGroupNameIdPutRequest($group_name_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsNamesGroupNameIdPut'
     *
     * @param  int $group_name_id The ID of the group name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesGroupsNamesGroupNameIdPutRequest($group_name_id)
    {
        // verify the required parameter 'group_name_id' is set
        if ($group_name_id === null || (is_array($group_name_id) && count($group_name_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_name_id when calling restPropertiesGroupsNamesGroupNameIdPut'
            );
        }

        $resourcePath = '/rest/properties/groups/names/{groupNameId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_name_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupNameId' . '}',
                ObjectSerializer::toPathValue($group_name_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsNamesPost
     *
     * Create an group name
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $lang The lang of the group name (required)
     * @param  string $name The name of the group name (required)
     * @param  \OpenAPI\Client\Model\InlineObject216 $_rest_properties_groups_names _rest_properties_groups_names (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyGroupName
     */
    public function restPropertiesGroupsNamesPost($property_id, $lang, $name, $_rest_properties_groups_names = null)
    {
        list($response) = $this->restPropertiesGroupsNamesPostWithHttpInfo($property_id, $lang, $name, $_rest_properties_groups_names);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsNamesPostWithHttpInfo
     *
     * Create an group name
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $lang The lang of the group name (required)
     * @param  string $name The name of the group name (required)
     * @param  \OpenAPI\Client\Model\InlineObject216 $_rest_properties_groups_names (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyGroupName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsNamesPostWithHttpInfo($property_id, $lang, $name, $_rest_properties_groups_names = null)
    {
        $request = $this->restPropertiesGroupsNamesPostRequest($property_id, $lang, $name, $_rest_properties_groups_names);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyGroupName' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyGroupName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyGroupName';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyGroupName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsNamesPostAsync
     *
     * Create an group name
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $lang The lang of the group name (required)
     * @param  string $name The name of the group name (required)
     * @param  \OpenAPI\Client\Model\InlineObject216 $_rest_properties_groups_names (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsNamesPostAsync($property_id, $lang, $name, $_rest_properties_groups_names = null)
    {
        return $this->restPropertiesGroupsNamesPostAsyncWithHttpInfo($property_id, $lang, $name, $_rest_properties_groups_names)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsNamesPostAsyncWithHttpInfo
     *
     * Create an group name
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $lang The lang of the group name (required)
     * @param  string $name The name of the group name (required)
     * @param  \OpenAPI\Client\Model\InlineObject216 $_rest_properties_groups_names (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsNamesPostAsyncWithHttpInfo($property_id, $lang, $name, $_rest_properties_groups_names = null)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyGroupName';
        $request = $this->restPropertiesGroupsNamesPostRequest($property_id, $lang, $name, $_rest_properties_groups_names);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsNamesPost'
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $lang The lang of the group name (required)
     * @param  string $name The name of the group name (required)
     * @param  \OpenAPI\Client\Model\InlineObject216 $_rest_properties_groups_names (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesGroupsNamesPostRequest($property_id, $lang, $name, $_rest_properties_groups_names = null)
    {
        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesGroupsNamesPost'
            );
        }
        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lang when calling restPropertiesGroupsNamesPost'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling restPropertiesGroupsNamesPost'
            );
        }

        $resourcePath = '/rest/properties/groups/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($property_id)) {
            $property_id = ObjectSerializer::serializeCollection($property_id, '', true);
        }
        if ($property_id !== null) {
            $queryParams['propertyId'] = $property_id;
        }
        // query params
        if (is_array($lang)) {
            $lang = ObjectSerializer::serializeCollection($lang, '', true);
        }
        if ($lang !== null) {
            $queryParams['lang'] = $lang;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }



        // body params
        $_tempBody = null;
        if (isset($_rest_properties_groups_names)) {
            $_tempBody = $_rest_properties_groups_names;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsOptionsGet
     *
     * List group options
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyGroupOption[]
     */
    public function restPropertiesGroupsOptionsGet()
    {
        list($response) = $this->restPropertiesGroupsOptionsGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPropertiesGroupsOptionsGetWithHttpInfo
     *
     * List group options
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyGroupOption[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsOptionsGetWithHttpInfo()
    {
        $request = $this->restPropertiesGroupsOptionsGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyGroupOption[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyGroupOption[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyGroupOption[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyGroupOption[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsOptionsGetAsync
     *
     * List group options
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsOptionsGetAsync()
    {
        return $this->restPropertiesGroupsOptionsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsOptionsGetAsyncWithHttpInfo
     *
     * List group options
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsOptionsGetAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\PropertyGroupOption[]';
        $request = $this->restPropertiesGroupsOptionsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsOptionsGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesGroupsOptionsGetRequest()
    {

        $resourcePath = '/rest/properties/groups/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsOptionsGroupOptionIdDelete
     *
     * Delete a group option
     *
     * @param  int $group_option_id The ID of the group option (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restPropertiesGroupsOptionsGroupOptionIdDelete($group_option_id)
    {
        $this->restPropertiesGroupsOptionsGroupOptionIdDeleteWithHttpInfo($group_option_id);
    }

    /**
     * Operation restPropertiesGroupsOptionsGroupOptionIdDeleteWithHttpInfo
     *
     * Delete a group option
     *
     * @param  int $group_option_id The ID of the group option (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsOptionsGroupOptionIdDeleteWithHttpInfo($group_option_id)
    {
        $request = $this->restPropertiesGroupsOptionsGroupOptionIdDeleteRequest($group_option_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsOptionsGroupOptionIdDeleteAsync
     *
     * Delete a group option
     *
     * @param  int $group_option_id The ID of the group option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsOptionsGroupOptionIdDeleteAsync($group_option_id)
    {
        return $this->restPropertiesGroupsOptionsGroupOptionIdDeleteAsyncWithHttpInfo($group_option_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsOptionsGroupOptionIdDeleteAsyncWithHttpInfo
     *
     * Delete a group option
     *
     * @param  int $group_option_id The ID of the group option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsOptionsGroupOptionIdDeleteAsyncWithHttpInfo($group_option_id)
    {
        $returnType = '';
        $request = $this->restPropertiesGroupsOptionsGroupOptionIdDeleteRequest($group_option_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsOptionsGroupOptionIdDelete'
     *
     * @param  int $group_option_id The ID of the group option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesGroupsOptionsGroupOptionIdDeleteRequest($group_option_id)
    {
        // verify the required parameter 'group_option_id' is set
        if ($group_option_id === null || (is_array($group_option_id) && count($group_option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_option_id when calling restPropertiesGroupsOptionsGroupOptionIdDelete'
            );
        }

        $resourcePath = '/rest/properties/groups/options/{groupOptionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupOptionId' . '}',
                ObjectSerializer::toPathValue($group_option_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsOptionsGroupOptionIdGet
     *
     * Get a group option
     *
     * @param  int $group_option_id The ID of the group option (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyGroupOption
     */
    public function restPropertiesGroupsOptionsGroupOptionIdGet($group_option_id)
    {
        list($response) = $this->restPropertiesGroupsOptionsGroupOptionIdGetWithHttpInfo($group_option_id);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsOptionsGroupOptionIdGetWithHttpInfo
     *
     * Get a group option
     *
     * @param  int $group_option_id The ID of the group option (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyGroupOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsOptionsGroupOptionIdGetWithHttpInfo($group_option_id)
    {
        $request = $this->restPropertiesGroupsOptionsGroupOptionIdGetRequest($group_option_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyGroupOption' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyGroupOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyGroupOption';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyGroupOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsOptionsGroupOptionIdGetAsync
     *
     * Get a group option
     *
     * @param  int $group_option_id The ID of the group option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsOptionsGroupOptionIdGetAsync($group_option_id)
    {
        return $this->restPropertiesGroupsOptionsGroupOptionIdGetAsyncWithHttpInfo($group_option_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsOptionsGroupOptionIdGetAsyncWithHttpInfo
     *
     * Get a group option
     *
     * @param  int $group_option_id The ID of the group option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsOptionsGroupOptionIdGetAsyncWithHttpInfo($group_option_id)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyGroupOption';
        $request = $this->restPropertiesGroupsOptionsGroupOptionIdGetRequest($group_option_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsOptionsGroupOptionIdGet'
     *
     * @param  int $group_option_id The ID of the group option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesGroupsOptionsGroupOptionIdGetRequest($group_option_id)
    {
        // verify the required parameter 'group_option_id' is set
        if ($group_option_id === null || (is_array($group_option_id) && count($group_option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_option_id when calling restPropertiesGroupsOptionsGroupOptionIdGet'
            );
        }

        $resourcePath = '/rest/properties/groups/options/{groupOptionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupOptionId' . '}',
                ObjectSerializer::toPathValue($group_option_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsOptionsGroupOptionIdPut
     *
     * Update a group option
     *
     * @param  int $group_option_id The ID of the group option (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyGroupOption
     */
    public function restPropertiesGroupsOptionsGroupOptionIdPut($group_option_id)
    {
        list($response) = $this->restPropertiesGroupsOptionsGroupOptionIdPutWithHttpInfo($group_option_id);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsOptionsGroupOptionIdPutWithHttpInfo
     *
     * Update a group option
     *
     * @param  int $group_option_id The ID of the group option (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyGroupOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsOptionsGroupOptionIdPutWithHttpInfo($group_option_id)
    {
        $request = $this->restPropertiesGroupsOptionsGroupOptionIdPutRequest($group_option_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyGroupOption' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyGroupOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyGroupOption';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyGroupOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsOptionsGroupOptionIdPutAsync
     *
     * Update a group option
     *
     * @param  int $group_option_id The ID of the group option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsOptionsGroupOptionIdPutAsync($group_option_id)
    {
        return $this->restPropertiesGroupsOptionsGroupOptionIdPutAsyncWithHttpInfo($group_option_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsOptionsGroupOptionIdPutAsyncWithHttpInfo
     *
     * Update a group option
     *
     * @param  int $group_option_id The ID of the group option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsOptionsGroupOptionIdPutAsyncWithHttpInfo($group_option_id)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyGroupOption';
        $request = $this->restPropertiesGroupsOptionsGroupOptionIdPutRequest($group_option_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsOptionsGroupOptionIdPut'
     *
     * @param  int $group_option_id The ID of the group option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesGroupsOptionsGroupOptionIdPutRequest($group_option_id)
    {
        // verify the required parameter 'group_option_id' is set
        if ($group_option_id === null || (is_array($group_option_id) && count($group_option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_option_id when calling restPropertiesGroupsOptionsGroupOptionIdPut'
            );
        }

        $resourcePath = '/rest/properties/groups/options/{groupOptionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupOptionId' . '}',
                ObjectSerializer::toPathValue($group_option_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsOptionsPost
     *
     * Create a group option
     *
     * @param  int $property_group_id The ID of the property group (required)
     * @param  string $group_option_identifier The groupOptionIdentifier of the group name (required)
     * @param  string $value The value of the group name (required)
     * @param  \OpenAPI\Client\Model\InlineObject217 $_rest_properties_groups_options _rest_properties_groups_options (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyGroupOption
     */
    public function restPropertiesGroupsOptionsPost($property_group_id, $group_option_identifier, $value, $_rest_properties_groups_options = null)
    {
        list($response) = $this->restPropertiesGroupsOptionsPostWithHttpInfo($property_group_id, $group_option_identifier, $value, $_rest_properties_groups_options);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsOptionsPostWithHttpInfo
     *
     * Create a group option
     *
     * @param  int $property_group_id The ID of the property group (required)
     * @param  string $group_option_identifier The groupOptionIdentifier of the group name (required)
     * @param  string $value The value of the group name (required)
     * @param  \OpenAPI\Client\Model\InlineObject217 $_rest_properties_groups_options (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyGroupOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsOptionsPostWithHttpInfo($property_group_id, $group_option_identifier, $value, $_rest_properties_groups_options = null)
    {
        $request = $this->restPropertiesGroupsOptionsPostRequest($property_group_id, $group_option_identifier, $value, $_rest_properties_groups_options);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyGroupOption' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyGroupOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyGroupOption';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyGroupOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsOptionsPostAsync
     *
     * Create a group option
     *
     * @param  int $property_group_id The ID of the property group (required)
     * @param  string $group_option_identifier The groupOptionIdentifier of the group name (required)
     * @param  string $value The value of the group name (required)
     * @param  \OpenAPI\Client\Model\InlineObject217 $_rest_properties_groups_options (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsOptionsPostAsync($property_group_id, $group_option_identifier, $value, $_rest_properties_groups_options = null)
    {
        return $this->restPropertiesGroupsOptionsPostAsyncWithHttpInfo($property_group_id, $group_option_identifier, $value, $_rest_properties_groups_options)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsOptionsPostAsyncWithHttpInfo
     *
     * Create a group option
     *
     * @param  int $property_group_id The ID of the property group (required)
     * @param  string $group_option_identifier The groupOptionIdentifier of the group name (required)
     * @param  string $value The value of the group name (required)
     * @param  \OpenAPI\Client\Model\InlineObject217 $_rest_properties_groups_options (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsOptionsPostAsyncWithHttpInfo($property_group_id, $group_option_identifier, $value, $_rest_properties_groups_options = null)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyGroupOption';
        $request = $this->restPropertiesGroupsOptionsPostRequest($property_group_id, $group_option_identifier, $value, $_rest_properties_groups_options);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsOptionsPost'
     *
     * @param  int $property_group_id The ID of the property group (required)
     * @param  string $group_option_identifier The groupOptionIdentifier of the group name (required)
     * @param  string $value The value of the group name (required)
     * @param  \OpenAPI\Client\Model\InlineObject217 $_rest_properties_groups_options (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesGroupsOptionsPostRequest($property_group_id, $group_option_identifier, $value, $_rest_properties_groups_options = null)
    {
        // verify the required parameter 'property_group_id' is set
        if ($property_group_id === null || (is_array($property_group_id) && count($property_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_group_id when calling restPropertiesGroupsOptionsPost'
            );
        }
        // verify the required parameter 'group_option_identifier' is set
        if ($group_option_identifier === null || (is_array($group_option_identifier) && count($group_option_identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_option_identifier when calling restPropertiesGroupsOptionsPost'
            );
        }
        // verify the required parameter 'value' is set
        if ($value === null || (is_array($value) && count($value) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $value when calling restPropertiesGroupsOptionsPost'
            );
        }

        $resourcePath = '/rest/properties/groups/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($property_group_id)) {
            $property_group_id = ObjectSerializer::serializeCollection($property_group_id, '', true);
        }
        if ($property_group_id !== null) {
            $queryParams['propertyGroupId'] = $property_group_id;
        }
        // query params
        if (is_array($group_option_identifier)) {
            $group_option_identifier = ObjectSerializer::serializeCollection($group_option_identifier, '', true);
        }
        if ($group_option_identifier !== null) {
            $queryParams['groupOptionIdentifier'] = $group_option_identifier;
        }
        // query params
        if (is_array($value)) {
            $value = ObjectSerializer::serializeCollection($value, '', true);
        }
        if ($value !== null) {
            $queryParams['value'] = $value;
        }



        // body params
        $_tempBody = null;
        if (isset($_rest_properties_groups_options)) {
            $_tempBody = $_rest_properties_groups_options;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsPost
     *
     * Create a property group
     *
     * @param  int $position The position  of the group (required)
     * @param  int $names The names of the group. (optional)
     * @param  int $options The options of the group (optional)
     * @param  \OpenAPI\Client\Model\InlineObject215 $_rest_properties_groups _rest_properties_groups (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyGroup
     */
    public function restPropertiesGroupsPost($position, $names = null, $options = null, $_rest_properties_groups = null)
    {
        list($response) = $this->restPropertiesGroupsPostWithHttpInfo($position, $names, $options, $_rest_properties_groups);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsPostWithHttpInfo
     *
     * Create a property group
     *
     * @param  int $position The position  of the group (required)
     * @param  int $names The names of the group. (optional)
     * @param  int $options The options of the group (optional)
     * @param  \OpenAPI\Client\Model\InlineObject215 $_rest_properties_groups (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsPostWithHttpInfo($position, $names = null, $options = null, $_rest_properties_groups = null)
    {
        $request = $this->restPropertiesGroupsPostRequest($position, $names, $options, $_rest_properties_groups);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyGroup' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyGroup';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsPostAsync
     *
     * Create a property group
     *
     * @param  int $position The position  of the group (required)
     * @param  int $names The names of the group. (optional)
     * @param  int $options The options of the group (optional)
     * @param  \OpenAPI\Client\Model\InlineObject215 $_rest_properties_groups (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsPostAsync($position, $names = null, $options = null, $_rest_properties_groups = null)
    {
        return $this->restPropertiesGroupsPostAsyncWithHttpInfo($position, $names, $options, $_rest_properties_groups)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsPostAsyncWithHttpInfo
     *
     * Create a property group
     *
     * @param  int $position The position  of the group (required)
     * @param  int $names The names of the group. (optional)
     * @param  int $options The options of the group (optional)
     * @param  \OpenAPI\Client\Model\InlineObject215 $_rest_properties_groups (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsPostAsyncWithHttpInfo($position, $names = null, $options = null, $_rest_properties_groups = null)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyGroup';
        $request = $this->restPropertiesGroupsPostRequest($position, $names, $options, $_rest_properties_groups);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsPost'
     *
     * @param  int $position The position  of the group (required)
     * @param  int $names The names of the group. (optional)
     * @param  int $options The options of the group (optional)
     * @param  \OpenAPI\Client\Model\InlineObject215 $_rest_properties_groups (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesGroupsPostRequest($position, $names = null, $options = null, $_rest_properties_groups = null)
    {
        // verify the required parameter 'position' is set
        if ($position === null || (is_array($position) && count($position) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $position when calling restPropertiesGroupsPost'
            );
        }

        $resourcePath = '/rest/properties/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($position)) {
            $position = ObjectSerializer::serializeCollection($position, '', true);
        }
        if ($position !== null) {
            $queryParams['position'] = $position;
        }
        // query params
        if (is_array($names)) {
            $names = ObjectSerializer::serializeCollection($names, '', true);
        }
        if ($names !== null) {
            $queryParams['names'] = $names;
        }
        // query params
        if (is_array($options)) {
            $options = ObjectSerializer::serializeCollection($options, '', true);
        }
        if ($options !== null) {
            $queryParams['options'] = $options;
        }



        // body params
        $_tempBody = null;
        if (isset($_rest_properties_groups)) {
            $_tempBody = $_rest_properties_groups;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsPropertyIdDelete
     *
     * Delete a property group
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id property_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restPropertiesGroupsPropertyIdDelete($group_id, $property_id)
    {
        $this->restPropertiesGroupsPropertyIdDeleteWithHttpInfo($group_id, $property_id);
    }

    /**
     * Operation restPropertiesGroupsPropertyIdDeleteWithHttpInfo
     *
     * Delete a property group
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsPropertyIdDeleteWithHttpInfo($group_id, $property_id)
    {
        $request = $this->restPropertiesGroupsPropertyIdDeleteRequest($group_id, $property_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsPropertyIdDeleteAsync
     *
     * Delete a property group
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsPropertyIdDeleteAsync($group_id, $property_id)
    {
        return $this->restPropertiesGroupsPropertyIdDeleteAsyncWithHttpInfo($group_id, $property_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsPropertyIdDeleteAsyncWithHttpInfo
     *
     * Delete a property group
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsPropertyIdDeleteAsyncWithHttpInfo($group_id, $property_id)
    {
        $returnType = '';
        $request = $this->restPropertiesGroupsPropertyIdDeleteRequest($group_id, $property_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsPropertyIdDelete'
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesGroupsPropertyIdDeleteRequest($group_id, $property_id)
    {
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling restPropertiesGroupsPropertyIdDelete'
            );
        }
        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesGroupsPropertyIdDelete'
            );
        }

        $resourcePath = '/rest/properties/groups/{propertyId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($group_id)) {
            $group_id = ObjectSerializer::serializeCollection($group_id, '', true);
        }
        if ($group_id !== null) {
            $queryParams['groupId'] = $group_id;
        }


        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsSurchargeTypesGet
     *
     * Get surcharge types from module configuration
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restPropertiesGroupsSurchargeTypesGet()
    {
        $this->restPropertiesGroupsSurchargeTypesGetWithHttpInfo();
    }

    /**
     * Operation restPropertiesGroupsSurchargeTypesGetWithHttpInfo
     *
     * Get surcharge types from module configuration
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsSurchargeTypesGetWithHttpInfo()
    {
        $request = $this->restPropertiesGroupsSurchargeTypesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsSurchargeTypesGetAsync
     *
     * Get surcharge types from module configuration
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsSurchargeTypesGetAsync()
    {
        return $this->restPropertiesGroupsSurchargeTypesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsSurchargeTypesGetAsyncWithHttpInfo
     *
     * Get surcharge types from module configuration
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsSurchargeTypesGetAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->restPropertiesGroupsSurchargeTypesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsSurchargeTypesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesGroupsSurchargeTypesGetRequest()
    {

        $resourcePath = '/rest/properties/groups/surcharge/types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsTypesGet
     *
     * Get group types from module configuration
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restPropertiesGroupsTypesGet()
    {
        $this->restPropertiesGroupsTypesGetWithHttpInfo();
    }

    /**
     * Operation restPropertiesGroupsTypesGetWithHttpInfo
     *
     * Get group types from module configuration
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsTypesGetWithHttpInfo()
    {
        $request = $this->restPropertiesGroupsTypesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsTypesGetAsync
     *
     * Get group types from module configuration
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsTypesGetAsync()
    {
        return $this->restPropertiesGroupsTypesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsTypesGetAsyncWithHttpInfo
     *
     * Get group types from module configuration
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesGroupsTypesGetAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->restPropertiesGroupsTypesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsTypesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesGroupsTypesGetRequest()
    {

        $resourcePath = '/rest/properties/groups/types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesMarketsGet
     *
     * List property markets
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyMarket[]
     */
    public function restPropertiesMarketsGet()
    {
        list($response) = $this->restPropertiesMarketsGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPropertiesMarketsGetWithHttpInfo
     *
     * List property markets
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyMarket[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesMarketsGetWithHttpInfo()
    {
        $request = $this->restPropertiesMarketsGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyMarket[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyMarket[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyMarket[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyMarket[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesMarketsGetAsync
     *
     * List property markets
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesMarketsGetAsync()
    {
        return $this->restPropertiesMarketsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesMarketsGetAsyncWithHttpInfo
     *
     * List property markets
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesMarketsGetAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\PropertyMarket[]';
        $request = $this->restPropertiesMarketsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesMarketsGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesMarketsGetRequest()
    {

        $resourcePath = '/rest/properties/markets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesMarketsPost
     *
     * Create a property market
     *
     * @param  int $property_id Property id (required)
     * @param  float $referrer_id The referrer id of the property market (required)
     * @param  int $referrer_sub_id The referrer sub id of the property market (required)
     * @param  string $value The value of the property market (required)
     * @param  \OpenAPI\Client\Model\InlineObject219 $_rest_properties_markets _rest_properties_markets (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyMarket
     */
    public function restPropertiesMarketsPost($property_id, $referrer_id, $referrer_sub_id, $value, $_rest_properties_markets = null)
    {
        list($response) = $this->restPropertiesMarketsPostWithHttpInfo($property_id, $referrer_id, $referrer_sub_id, $value, $_rest_properties_markets);
        return $response;
    }

    /**
     * Operation restPropertiesMarketsPostWithHttpInfo
     *
     * Create a property market
     *
     * @param  int $property_id Property id (required)
     * @param  float $referrer_id The referrer id of the property market (required)
     * @param  int $referrer_sub_id The referrer sub id of the property market (required)
     * @param  string $value The value of the property market (required)
     * @param  \OpenAPI\Client\Model\InlineObject219 $_rest_properties_markets (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyMarket, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesMarketsPostWithHttpInfo($property_id, $referrer_id, $referrer_sub_id, $value, $_rest_properties_markets = null)
    {
        $request = $this->restPropertiesMarketsPostRequest($property_id, $referrer_id, $referrer_sub_id, $value, $_rest_properties_markets);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyMarket' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyMarket', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyMarket';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyMarket',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesMarketsPostAsync
     *
     * Create a property market
     *
     * @param  int $property_id Property id (required)
     * @param  float $referrer_id The referrer id of the property market (required)
     * @param  int $referrer_sub_id The referrer sub id of the property market (required)
     * @param  string $value The value of the property market (required)
     * @param  \OpenAPI\Client\Model\InlineObject219 $_rest_properties_markets (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesMarketsPostAsync($property_id, $referrer_id, $referrer_sub_id, $value, $_rest_properties_markets = null)
    {
        return $this->restPropertiesMarketsPostAsyncWithHttpInfo($property_id, $referrer_id, $referrer_sub_id, $value, $_rest_properties_markets)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesMarketsPostAsyncWithHttpInfo
     *
     * Create a property market
     *
     * @param  int $property_id Property id (required)
     * @param  float $referrer_id The referrer id of the property market (required)
     * @param  int $referrer_sub_id The referrer sub id of the property market (required)
     * @param  string $value The value of the property market (required)
     * @param  \OpenAPI\Client\Model\InlineObject219 $_rest_properties_markets (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesMarketsPostAsyncWithHttpInfo($property_id, $referrer_id, $referrer_sub_id, $value, $_rest_properties_markets = null)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyMarket';
        $request = $this->restPropertiesMarketsPostRequest($property_id, $referrer_id, $referrer_sub_id, $value, $_rest_properties_markets);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesMarketsPost'
     *
     * @param  int $property_id Property id (required)
     * @param  float $referrer_id The referrer id of the property market (required)
     * @param  int $referrer_sub_id The referrer sub id of the property market (required)
     * @param  string $value The value of the property market (required)
     * @param  \OpenAPI\Client\Model\InlineObject219 $_rest_properties_markets (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesMarketsPostRequest($property_id, $referrer_id, $referrer_sub_id, $value, $_rest_properties_markets = null)
    {
        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesMarketsPost'
            );
        }
        // verify the required parameter 'referrer_id' is set
        if ($referrer_id === null || (is_array($referrer_id) && count($referrer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $referrer_id when calling restPropertiesMarketsPost'
            );
        }
        // verify the required parameter 'referrer_sub_id' is set
        if ($referrer_sub_id === null || (is_array($referrer_sub_id) && count($referrer_sub_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $referrer_sub_id when calling restPropertiesMarketsPost'
            );
        }
        // verify the required parameter 'value' is set
        if ($value === null || (is_array($value) && count($value) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $value when calling restPropertiesMarketsPost'
            );
        }

        $resourcePath = '/rest/properties/markets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($property_id)) {
            $property_id = ObjectSerializer::serializeCollection($property_id, '', true);
        }
        if ($property_id !== null) {
            $queryParams['propertyId'] = $property_id;
        }
        // query params
        if (is_array($referrer_id)) {
            $referrer_id = ObjectSerializer::serializeCollection($referrer_id, '', true);
        }
        if ($referrer_id !== null) {
            $queryParams['referrerId'] = $referrer_id;
        }
        // query params
        if (is_array($referrer_sub_id)) {
            $referrer_sub_id = ObjectSerializer::serializeCollection($referrer_sub_id, '', true);
        }
        if ($referrer_sub_id !== null) {
            $queryParams['referrerSubId'] = $referrer_sub_id;
        }
        // query params
        if (is_array($value)) {
            $value = ObjectSerializer::serializeCollection($value, '', true);
        }
        if ($value !== null) {
            $queryParams['value'] = $value;
        }



        // body params
        $_tempBody = null;
        if (isset($_rest_properties_markets)) {
            $_tempBody = $_rest_properties_markets;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesMarketsPropertiesMarketIdDelete
     *
     * Delete a property market
     *
     * @param  int $property_market_id The ID of the property market (required)
     * @param  int $properties_market_id properties_market_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restPropertiesMarketsPropertiesMarketIdDelete($property_market_id, $properties_market_id)
    {
        $this->restPropertiesMarketsPropertiesMarketIdDeleteWithHttpInfo($property_market_id, $properties_market_id);
    }

    /**
     * Operation restPropertiesMarketsPropertiesMarketIdDeleteWithHttpInfo
     *
     * Delete a property market
     *
     * @param  int $property_market_id The ID of the property market (required)
     * @param  int $properties_market_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesMarketsPropertiesMarketIdDeleteWithHttpInfo($property_market_id, $properties_market_id)
    {
        $request = $this->restPropertiesMarketsPropertiesMarketIdDeleteRequest($property_market_id, $properties_market_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesMarketsPropertiesMarketIdDeleteAsync
     *
     * Delete a property market
     *
     * @param  int $property_market_id The ID of the property market (required)
     * @param  int $properties_market_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesMarketsPropertiesMarketIdDeleteAsync($property_market_id, $properties_market_id)
    {
        return $this->restPropertiesMarketsPropertiesMarketIdDeleteAsyncWithHttpInfo($property_market_id, $properties_market_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesMarketsPropertiesMarketIdDeleteAsyncWithHttpInfo
     *
     * Delete a property market
     *
     * @param  int $property_market_id The ID of the property market (required)
     * @param  int $properties_market_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesMarketsPropertiesMarketIdDeleteAsyncWithHttpInfo($property_market_id, $properties_market_id)
    {
        $returnType = '';
        $request = $this->restPropertiesMarketsPropertiesMarketIdDeleteRequest($property_market_id, $properties_market_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesMarketsPropertiesMarketIdDelete'
     *
     * @param  int $property_market_id The ID of the property market (required)
     * @param  int $properties_market_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesMarketsPropertiesMarketIdDeleteRequest($property_market_id, $properties_market_id)
    {
        // verify the required parameter 'property_market_id' is set
        if ($property_market_id === null || (is_array($property_market_id) && count($property_market_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_market_id when calling restPropertiesMarketsPropertiesMarketIdDelete'
            );
        }
        // verify the required parameter 'properties_market_id' is set
        if ($properties_market_id === null || (is_array($properties_market_id) && count($properties_market_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $properties_market_id when calling restPropertiesMarketsPropertiesMarketIdDelete'
            );
        }

        $resourcePath = '/rest/properties/markets/{propertiesMarketId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($property_market_id)) {
            $property_market_id = ObjectSerializer::serializeCollection($property_market_id, '', true);
        }
        if ($property_market_id !== null) {
            $queryParams['propertyMarketId'] = $property_market_id;
        }


        // path params
        if ($properties_market_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertiesMarketId' . '}',
                ObjectSerializer::toPathValue($properties_market_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesMarketsPropertiesMarketIdGet
     *
     * Get a property market
     *
     * @param  int $property_market_id The ID of the property market (required)
     * @param  int $properties_market_id properties_market_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyMarket
     */
    public function restPropertiesMarketsPropertiesMarketIdGet($property_market_id, $properties_market_id)
    {
        list($response) = $this->restPropertiesMarketsPropertiesMarketIdGetWithHttpInfo($property_market_id, $properties_market_id);
        return $response;
    }

    /**
     * Operation restPropertiesMarketsPropertiesMarketIdGetWithHttpInfo
     *
     * Get a property market
     *
     * @param  int $property_market_id The ID of the property market (required)
     * @param  int $properties_market_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyMarket, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesMarketsPropertiesMarketIdGetWithHttpInfo($property_market_id, $properties_market_id)
    {
        $request = $this->restPropertiesMarketsPropertiesMarketIdGetRequest($property_market_id, $properties_market_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyMarket' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyMarket', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyMarket';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyMarket',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesMarketsPropertiesMarketIdGetAsync
     *
     * Get a property market
     *
     * @param  int $property_market_id The ID of the property market (required)
     * @param  int $properties_market_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesMarketsPropertiesMarketIdGetAsync($property_market_id, $properties_market_id)
    {
        return $this->restPropertiesMarketsPropertiesMarketIdGetAsyncWithHttpInfo($property_market_id, $properties_market_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesMarketsPropertiesMarketIdGetAsyncWithHttpInfo
     *
     * Get a property market
     *
     * @param  int $property_market_id The ID of the property market (required)
     * @param  int $properties_market_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesMarketsPropertiesMarketIdGetAsyncWithHttpInfo($property_market_id, $properties_market_id)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyMarket';
        $request = $this->restPropertiesMarketsPropertiesMarketIdGetRequest($property_market_id, $properties_market_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesMarketsPropertiesMarketIdGet'
     *
     * @param  int $property_market_id The ID of the property market (required)
     * @param  int $properties_market_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesMarketsPropertiesMarketIdGetRequest($property_market_id, $properties_market_id)
    {
        // verify the required parameter 'property_market_id' is set
        if ($property_market_id === null || (is_array($property_market_id) && count($property_market_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_market_id when calling restPropertiesMarketsPropertiesMarketIdGet'
            );
        }
        // verify the required parameter 'properties_market_id' is set
        if ($properties_market_id === null || (is_array($properties_market_id) && count($properties_market_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $properties_market_id when calling restPropertiesMarketsPropertiesMarketIdGet'
            );
        }

        $resourcePath = '/rest/properties/markets/{propertiesMarketId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($property_market_id)) {
            $property_market_id = ObjectSerializer::serializeCollection($property_market_id, '', true);
        }
        if ($property_market_id !== null) {
            $queryParams['propertyMarketId'] = $property_market_id;
        }


        // path params
        if ($properties_market_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertiesMarketId' . '}',
                ObjectSerializer::toPathValue($properties_market_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesMarketsPropertiesMarketIdPut
     *
     * Update a property market
     *
     * @param  int $properties_market_id properties_market_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject220 $_rest_properties_markets_properties_market_id _rest_properties_markets_properties_market_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyMarket
     */
    public function restPropertiesMarketsPropertiesMarketIdPut($properties_market_id, $_rest_properties_markets_properties_market_id = null)
    {
        list($response) = $this->restPropertiesMarketsPropertiesMarketIdPutWithHttpInfo($properties_market_id, $_rest_properties_markets_properties_market_id);
        return $response;
    }

    /**
     * Operation restPropertiesMarketsPropertiesMarketIdPutWithHttpInfo
     *
     * Update a property market
     *
     * @param  int $properties_market_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject220 $_rest_properties_markets_properties_market_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyMarket, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesMarketsPropertiesMarketIdPutWithHttpInfo($properties_market_id, $_rest_properties_markets_properties_market_id = null)
    {
        $request = $this->restPropertiesMarketsPropertiesMarketIdPutRequest($properties_market_id, $_rest_properties_markets_properties_market_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyMarket' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyMarket', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyMarket';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyMarket',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesMarketsPropertiesMarketIdPutAsync
     *
     * Update a property market
     *
     * @param  int $properties_market_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject220 $_rest_properties_markets_properties_market_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesMarketsPropertiesMarketIdPutAsync($properties_market_id, $_rest_properties_markets_properties_market_id = null)
    {
        return $this->restPropertiesMarketsPropertiesMarketIdPutAsyncWithHttpInfo($properties_market_id, $_rest_properties_markets_properties_market_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesMarketsPropertiesMarketIdPutAsyncWithHttpInfo
     *
     * Update a property market
     *
     * @param  int $properties_market_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject220 $_rest_properties_markets_properties_market_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesMarketsPropertiesMarketIdPutAsyncWithHttpInfo($properties_market_id, $_rest_properties_markets_properties_market_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyMarket';
        $request = $this->restPropertiesMarketsPropertiesMarketIdPutRequest($properties_market_id, $_rest_properties_markets_properties_market_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesMarketsPropertiesMarketIdPut'
     *
     * @param  int $properties_market_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject220 $_rest_properties_markets_properties_market_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesMarketsPropertiesMarketIdPutRequest($properties_market_id, $_rest_properties_markets_properties_market_id = null)
    {
        // verify the required parameter 'properties_market_id' is set
        if ($properties_market_id === null || (is_array($properties_market_id) && count($properties_market_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $properties_market_id when calling restPropertiesMarketsPropertiesMarketIdPut'
            );
        }

        $resourcePath = '/rest/properties/markets/{propertiesMarketId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($properties_market_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertiesMarketId' . '}',
                ObjectSerializer::toPathValue($properties_market_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_properties_markets_properties_market_id)) {
            $_tempBody = $_rest_properties_markets_properties_market_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesMultipleOptionsDelete
     *
     * Delete property options
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restPropertiesMultipleOptionsDelete()
    {
        $this->restPropertiesMultipleOptionsDeleteWithHttpInfo();
    }

    /**
     * Operation restPropertiesMultipleOptionsDeleteWithHttpInfo
     *
     * Delete property options
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesMultipleOptionsDeleteWithHttpInfo()
    {
        $request = $this->restPropertiesMultipleOptionsDeleteRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesMultipleOptionsDeleteAsync
     *
     * Delete property options
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesMultipleOptionsDeleteAsync()
    {
        return $this->restPropertiesMultipleOptionsDeleteAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesMultipleOptionsDeleteAsyncWithHttpInfo
     *
     * Delete property options
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesMultipleOptionsDeleteAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->restPropertiesMultipleOptionsDeleteRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesMultipleOptionsDelete'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesMultipleOptionsDeleteRequest()
    {

        $resourcePath = '/rest/properties/multiple/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesMultipleOptionsPost
     *
     * Create property options
     *
     * @param  int $property_id ID of the property (required)
     * @param  string $type_option_identifier The identifier of the property option type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyOption
     */
    public function restPropertiesMultipleOptionsPost($property_id, $type_option_identifier)
    {
        list($response) = $this->restPropertiesMultipleOptionsPostWithHttpInfo($property_id, $type_option_identifier);
        return $response;
    }

    /**
     * Operation restPropertiesMultipleOptionsPostWithHttpInfo
     *
     * Create property options
     *
     * @param  int $property_id ID of the property (required)
     * @param  string $type_option_identifier The identifier of the property option type (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesMultipleOptionsPostWithHttpInfo($property_id, $type_option_identifier)
    {
        $request = $this->restPropertiesMultipleOptionsPostRequest($property_id, $type_option_identifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyOption' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyOption';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesMultipleOptionsPostAsync
     *
     * Create property options
     *
     * @param  int $property_id ID of the property (required)
     * @param  string $type_option_identifier The identifier of the property option type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesMultipleOptionsPostAsync($property_id, $type_option_identifier)
    {
        return $this->restPropertiesMultipleOptionsPostAsyncWithHttpInfo($property_id, $type_option_identifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesMultipleOptionsPostAsyncWithHttpInfo
     *
     * Create property options
     *
     * @param  int $property_id ID of the property (required)
     * @param  string $type_option_identifier The identifier of the property option type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesMultipleOptionsPostAsyncWithHttpInfo($property_id, $type_option_identifier)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyOption';
        $request = $this->restPropertiesMultipleOptionsPostRequest($property_id, $type_option_identifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesMultipleOptionsPost'
     *
     * @param  int $property_id ID of the property (required)
     * @param  string $type_option_identifier The identifier of the property option type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesMultipleOptionsPostRequest($property_id, $type_option_identifier)
    {
        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesMultipleOptionsPost'
            );
        }
        // verify the required parameter 'type_option_identifier' is set
        if ($type_option_identifier === null || (is_array($type_option_identifier) && count($type_option_identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_option_identifier when calling restPropertiesMultipleOptionsPost'
            );
        }

        $resourcePath = '/rest/properties/multiple/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($property_id)) {
            $property_id = ObjectSerializer::serializeCollection($property_id, '', true);
        }
        if ($property_id !== null) {
            $queryParams['propertyId'] = $property_id;
        }
        // query params
        if (is_array($type_option_identifier)) {
            $type_option_identifier = ObjectSerializer::serializeCollection($type_option_identifier, '', true);
        }
        if ($type_option_identifier !== null) {
            $queryParams['typeOptionIdentifier'] = $type_option_identifier;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesNamesGet
     *
     * List names
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyName[]
     */
    public function restPropertiesNamesGet()
    {
        list($response) = $this->restPropertiesNamesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPropertiesNamesGetWithHttpInfo
     *
     * List names
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyName[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesNamesGetWithHttpInfo()
    {
        $request = $this->restPropertiesNamesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyName[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyName[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyName[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyName[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesNamesGetAsync
     *
     * List names
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesNamesGetAsync()
    {
        return $this->restPropertiesNamesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesNamesGetAsyncWithHttpInfo
     *
     * List names
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesNamesGetAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\PropertyName[]';
        $request = $this->restPropertiesNamesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesNamesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesNamesGetRequest()
    {

        $resourcePath = '/rest/properties/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesNamesNameIdDelete
     *
     * Delete a property name
     *
     * @param  int $name_id The ID of the property name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restPropertiesNamesNameIdDelete($name_id)
    {
        $this->restPropertiesNamesNameIdDeleteWithHttpInfo($name_id);
    }

    /**
     * Operation restPropertiesNamesNameIdDeleteWithHttpInfo
     *
     * Delete a property name
     *
     * @param  int $name_id The ID of the property name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesNamesNameIdDeleteWithHttpInfo($name_id)
    {
        $request = $this->restPropertiesNamesNameIdDeleteRequest($name_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesNamesNameIdDeleteAsync
     *
     * Delete a property name
     *
     * @param  int $name_id The ID of the property name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesNamesNameIdDeleteAsync($name_id)
    {
        return $this->restPropertiesNamesNameIdDeleteAsyncWithHttpInfo($name_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesNamesNameIdDeleteAsyncWithHttpInfo
     *
     * Delete a property name
     *
     * @param  int $name_id The ID of the property name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesNamesNameIdDeleteAsyncWithHttpInfo($name_id)
    {
        $returnType = '';
        $request = $this->restPropertiesNamesNameIdDeleteRequest($name_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesNamesNameIdDelete'
     *
     * @param  int $name_id The ID of the property name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesNamesNameIdDeleteRequest($name_id)
    {
        // verify the required parameter 'name_id' is set
        if ($name_id === null || (is_array($name_id) && count($name_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name_id when calling restPropertiesNamesNameIdDelete'
            );
        }

        $resourcePath = '/rest/properties/names/{nameId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($name_id !== null) {
            $resourcePath = str_replace(
                '{' . 'nameId' . '}',
                ObjectSerializer::toPathValue($name_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesNamesNameIdGet
     *
     * Get a property name
     *
     * @param  int $name_id The ID of the property name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyName
     */
    public function restPropertiesNamesNameIdGet($name_id)
    {
        list($response) = $this->restPropertiesNamesNameIdGetWithHttpInfo($name_id);
        return $response;
    }

    /**
     * Operation restPropertiesNamesNameIdGetWithHttpInfo
     *
     * Get a property name
     *
     * @param  int $name_id The ID of the property name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesNamesNameIdGetWithHttpInfo($name_id)
    {
        $request = $this->restPropertiesNamesNameIdGetRequest($name_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyName' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyName';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesNamesNameIdGetAsync
     *
     * Get a property name
     *
     * @param  int $name_id The ID of the property name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesNamesNameIdGetAsync($name_id)
    {
        return $this->restPropertiesNamesNameIdGetAsyncWithHttpInfo($name_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesNamesNameIdGetAsyncWithHttpInfo
     *
     * Get a property name
     *
     * @param  int $name_id The ID of the property name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesNamesNameIdGetAsyncWithHttpInfo($name_id)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyName';
        $request = $this->restPropertiesNamesNameIdGetRequest($name_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesNamesNameIdGet'
     *
     * @param  int $name_id The ID of the property name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesNamesNameIdGetRequest($name_id)
    {
        // verify the required parameter 'name_id' is set
        if ($name_id === null || (is_array($name_id) && count($name_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name_id when calling restPropertiesNamesNameIdGet'
            );
        }

        $resourcePath = '/rest/properties/names/{nameId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($name_id !== null) {
            $resourcePath = str_replace(
                '{' . 'nameId' . '}',
                ObjectSerializer::toPathValue($name_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesNamesNameIdPut
     *
     * Update a property name
     *
     * @param  int $name_id The ID of the property name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyName
     */
    public function restPropertiesNamesNameIdPut($name_id)
    {
        list($response) = $this->restPropertiesNamesNameIdPutWithHttpInfo($name_id);
        return $response;
    }

    /**
     * Operation restPropertiesNamesNameIdPutWithHttpInfo
     *
     * Update a property name
     *
     * @param  int $name_id The ID of the property name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesNamesNameIdPutWithHttpInfo($name_id)
    {
        $request = $this->restPropertiesNamesNameIdPutRequest($name_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyName' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyName';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesNamesNameIdPutAsync
     *
     * Update a property name
     *
     * @param  int $name_id The ID of the property name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesNamesNameIdPutAsync($name_id)
    {
        return $this->restPropertiesNamesNameIdPutAsyncWithHttpInfo($name_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesNamesNameIdPutAsyncWithHttpInfo
     *
     * Update a property name
     *
     * @param  int $name_id The ID of the property name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesNamesNameIdPutAsyncWithHttpInfo($name_id)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyName';
        $request = $this->restPropertiesNamesNameIdPutRequest($name_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesNamesNameIdPut'
     *
     * @param  int $name_id The ID of the property name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesNamesNameIdPutRequest($name_id)
    {
        // verify the required parameter 'name_id' is set
        if ($name_id === null || (is_array($name_id) && count($name_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name_id when calling restPropertiesNamesNameIdPut'
            );
        }

        $resourcePath = '/rest/properties/names/{nameId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($name_id !== null) {
            $resourcePath = str_replace(
                '{' . 'nameId' . '}',
                ObjectSerializer::toPathValue($name_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesNamesPost
     *
     * Create a name
     *
     * @param  int $property_id The id of the property name (required)
     * @param  string $lang The lang of the property name (required)
     * @param  string $name The name of the property name (required)
     * @param  string $description The description of the property name (optional)
     * @param  \OpenAPI\Client\Model\InlineObject221 $_rest_properties_names _rest_properties_names (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyName
     */
    public function restPropertiesNamesPost($property_id, $lang, $name, $description = null, $_rest_properties_names = null)
    {
        list($response) = $this->restPropertiesNamesPostWithHttpInfo($property_id, $lang, $name, $description, $_rest_properties_names);
        return $response;
    }

    /**
     * Operation restPropertiesNamesPostWithHttpInfo
     *
     * Create a name
     *
     * @param  int $property_id The id of the property name (required)
     * @param  string $lang The lang of the property name (required)
     * @param  string $name The name of the property name (required)
     * @param  string $description The description of the property name (optional)
     * @param  \OpenAPI\Client\Model\InlineObject221 $_rest_properties_names (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesNamesPostWithHttpInfo($property_id, $lang, $name, $description = null, $_rest_properties_names = null)
    {
        $request = $this->restPropertiesNamesPostRequest($property_id, $lang, $name, $description, $_rest_properties_names);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyName' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyName';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesNamesPostAsync
     *
     * Create a name
     *
     * @param  int $property_id The id of the property name (required)
     * @param  string $lang The lang of the property name (required)
     * @param  string $name The name of the property name (required)
     * @param  string $description The description of the property name (optional)
     * @param  \OpenAPI\Client\Model\InlineObject221 $_rest_properties_names (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesNamesPostAsync($property_id, $lang, $name, $description = null, $_rest_properties_names = null)
    {
        return $this->restPropertiesNamesPostAsyncWithHttpInfo($property_id, $lang, $name, $description, $_rest_properties_names)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesNamesPostAsyncWithHttpInfo
     *
     * Create a name
     *
     * @param  int $property_id The id of the property name (required)
     * @param  string $lang The lang of the property name (required)
     * @param  string $name The name of the property name (required)
     * @param  string $description The description of the property name (optional)
     * @param  \OpenAPI\Client\Model\InlineObject221 $_rest_properties_names (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesNamesPostAsyncWithHttpInfo($property_id, $lang, $name, $description = null, $_rest_properties_names = null)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyName';
        $request = $this->restPropertiesNamesPostRequest($property_id, $lang, $name, $description, $_rest_properties_names);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesNamesPost'
     *
     * @param  int $property_id The id of the property name (required)
     * @param  string $lang The lang of the property name (required)
     * @param  string $name The name of the property name (required)
     * @param  string $description The description of the property name (optional)
     * @param  \OpenAPI\Client\Model\InlineObject221 $_rest_properties_names (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesNamesPostRequest($property_id, $lang, $name, $description = null, $_rest_properties_names = null)
    {
        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesNamesPost'
            );
        }
        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lang when calling restPropertiesNamesPost'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling restPropertiesNamesPost'
            );
        }

        $resourcePath = '/rest/properties/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($property_id)) {
            $property_id = ObjectSerializer::serializeCollection($property_id, '', true);
        }
        if ($property_id !== null) {
            $queryParams['propertyId'] = $property_id;
        }
        // query params
        if (is_array($lang)) {
            $lang = ObjectSerializer::serializeCollection($lang, '', true);
        }
        if ($lang !== null) {
            $queryParams['lang'] = $lang;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($description)) {
            $description = ObjectSerializer::serializeCollection($description, '', true);
        }
        if ($description !== null) {
            $queryParams['description'] = $description;
        }



        // body params
        $_tempBody = null;
        if (isset($_rest_properties_names)) {
            $_tempBody = $_rest_properties_names;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesOptionsGet
     *
     * List property options
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyOption[]
     */
    public function restPropertiesOptionsGet()
    {
        list($response) = $this->restPropertiesOptionsGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPropertiesOptionsGetWithHttpInfo
     *
     * List property options
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyOption[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesOptionsGetWithHttpInfo()
    {
        $request = $this->restPropertiesOptionsGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyOption[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyOption[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyOption[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyOption[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesOptionsGetAsync
     *
     * List property options
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesOptionsGetAsync()
    {
        return $this->restPropertiesOptionsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesOptionsGetAsyncWithHttpInfo
     *
     * List property options
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesOptionsGetAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\PropertyOption[]';
        $request = $this->restPropertiesOptionsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesOptionsGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesOptionsGetRequest()
    {

        $resourcePath = '/rest/properties/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesOptionsPost
     *
     * Create a property option
     *
     * @param  int $property_id ID of the property (required)
     * @param  string $type_option_identifier The identifier of the property option type (required)
     * @param  \OpenAPI\Client\Model\InlineObject222 $_rest_properties_options _rest_properties_options (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyOption
     */
    public function restPropertiesOptionsPost($property_id, $type_option_identifier, $_rest_properties_options = null)
    {
        list($response) = $this->restPropertiesOptionsPostWithHttpInfo($property_id, $type_option_identifier, $_rest_properties_options);
        return $response;
    }

    /**
     * Operation restPropertiesOptionsPostWithHttpInfo
     *
     * Create a property option
     *
     * @param  int $property_id ID of the property (required)
     * @param  string $type_option_identifier The identifier of the property option type (required)
     * @param  \OpenAPI\Client\Model\InlineObject222 $_rest_properties_options (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesOptionsPostWithHttpInfo($property_id, $type_option_identifier, $_rest_properties_options = null)
    {
        $request = $this->restPropertiesOptionsPostRequest($property_id, $type_option_identifier, $_rest_properties_options);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyOption' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyOption';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesOptionsPostAsync
     *
     * Create a property option
     *
     * @param  int $property_id ID of the property (required)
     * @param  string $type_option_identifier The identifier of the property option type (required)
     * @param  \OpenAPI\Client\Model\InlineObject222 $_rest_properties_options (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesOptionsPostAsync($property_id, $type_option_identifier, $_rest_properties_options = null)
    {
        return $this->restPropertiesOptionsPostAsyncWithHttpInfo($property_id, $type_option_identifier, $_rest_properties_options)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesOptionsPostAsyncWithHttpInfo
     *
     * Create a property option
     *
     * @param  int $property_id ID of the property (required)
     * @param  string $type_option_identifier The identifier of the property option type (required)
     * @param  \OpenAPI\Client\Model\InlineObject222 $_rest_properties_options (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesOptionsPostAsyncWithHttpInfo($property_id, $type_option_identifier, $_rest_properties_options = null)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyOption';
        $request = $this->restPropertiesOptionsPostRequest($property_id, $type_option_identifier, $_rest_properties_options);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesOptionsPost'
     *
     * @param  int $property_id ID of the property (required)
     * @param  string $type_option_identifier The identifier of the property option type (required)
     * @param  \OpenAPI\Client\Model\InlineObject222 $_rest_properties_options (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesOptionsPostRequest($property_id, $type_option_identifier, $_rest_properties_options = null)
    {
        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesOptionsPost'
            );
        }
        // verify the required parameter 'type_option_identifier' is set
        if ($type_option_identifier === null || (is_array($type_option_identifier) && count($type_option_identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_option_identifier when calling restPropertiesOptionsPost'
            );
        }

        $resourcePath = '/rest/properties/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($property_id)) {
            $property_id = ObjectSerializer::serializeCollection($property_id, '', true);
        }
        if ($property_id !== null) {
            $queryParams['propertyId'] = $property_id;
        }
        // query params
        if (is_array($type_option_identifier)) {
            $type_option_identifier = ObjectSerializer::serializeCollection($type_option_identifier, '', true);
        }
        if ($type_option_identifier !== null) {
            $queryParams['typeOptionIdentifier'] = $type_option_identifier;
        }



        // body params
        $_tempBody = null;
        if (isset($_rest_properties_options)) {
            $_tempBody = $_rest_properties_options;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesOptionsPropertyOptionIdDelete
     *
     * Delete a property option
     *
     * @param  int $property_option_id The ID of the property option (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restPropertiesOptionsPropertyOptionIdDelete($property_option_id)
    {
        $this->restPropertiesOptionsPropertyOptionIdDeleteWithHttpInfo($property_option_id);
    }

    /**
     * Operation restPropertiesOptionsPropertyOptionIdDeleteWithHttpInfo
     *
     * Delete a property option
     *
     * @param  int $property_option_id The ID of the property option (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesOptionsPropertyOptionIdDeleteWithHttpInfo($property_option_id)
    {
        $request = $this->restPropertiesOptionsPropertyOptionIdDeleteRequest($property_option_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesOptionsPropertyOptionIdDeleteAsync
     *
     * Delete a property option
     *
     * @param  int $property_option_id The ID of the property option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesOptionsPropertyOptionIdDeleteAsync($property_option_id)
    {
        return $this->restPropertiesOptionsPropertyOptionIdDeleteAsyncWithHttpInfo($property_option_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesOptionsPropertyOptionIdDeleteAsyncWithHttpInfo
     *
     * Delete a property option
     *
     * @param  int $property_option_id The ID of the property option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesOptionsPropertyOptionIdDeleteAsyncWithHttpInfo($property_option_id)
    {
        $returnType = '';
        $request = $this->restPropertiesOptionsPropertyOptionIdDeleteRequest($property_option_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesOptionsPropertyOptionIdDelete'
     *
     * @param  int $property_option_id The ID of the property option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesOptionsPropertyOptionIdDeleteRequest($property_option_id)
    {
        // verify the required parameter 'property_option_id' is set
        if ($property_option_id === null || (is_array($property_option_id) && count($property_option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_option_id when calling restPropertiesOptionsPropertyOptionIdDelete'
            );
        }

        $resourcePath = '/rest/properties/options/{propertyOptionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyOptionId' . '}',
                ObjectSerializer::toPathValue($property_option_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesOptionsPropertyOptionIdGet
     *
     * Get a property option
     *
     * @param  int $property_option_id The ID of the property option (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyOption
     */
    public function restPropertiesOptionsPropertyOptionIdGet($property_option_id)
    {
        list($response) = $this->restPropertiesOptionsPropertyOptionIdGetWithHttpInfo($property_option_id);
        return $response;
    }

    /**
     * Operation restPropertiesOptionsPropertyOptionIdGetWithHttpInfo
     *
     * Get a property option
     *
     * @param  int $property_option_id The ID of the property option (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesOptionsPropertyOptionIdGetWithHttpInfo($property_option_id)
    {
        $request = $this->restPropertiesOptionsPropertyOptionIdGetRequest($property_option_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyOption' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyOption';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesOptionsPropertyOptionIdGetAsync
     *
     * Get a property option
     *
     * @param  int $property_option_id The ID of the property option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesOptionsPropertyOptionIdGetAsync($property_option_id)
    {
        return $this->restPropertiesOptionsPropertyOptionIdGetAsyncWithHttpInfo($property_option_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesOptionsPropertyOptionIdGetAsyncWithHttpInfo
     *
     * Get a property option
     *
     * @param  int $property_option_id The ID of the property option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesOptionsPropertyOptionIdGetAsyncWithHttpInfo($property_option_id)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyOption';
        $request = $this->restPropertiesOptionsPropertyOptionIdGetRequest($property_option_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesOptionsPropertyOptionIdGet'
     *
     * @param  int $property_option_id The ID of the property option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesOptionsPropertyOptionIdGetRequest($property_option_id)
    {
        // verify the required parameter 'property_option_id' is set
        if ($property_option_id === null || (is_array($property_option_id) && count($property_option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_option_id when calling restPropertiesOptionsPropertyOptionIdGet'
            );
        }

        $resourcePath = '/rest/properties/options/{propertyOptionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyOptionId' . '}',
                ObjectSerializer::toPathValue($property_option_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesOptionsPropertyOptionIdPut
     *
     * Update a property option
     *
     * @param  int $property_option_id The ID of the property option (required)
     * @param  int $property_option_id2 property_option_id2 (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyOption
     */
    public function restPropertiesOptionsPropertyOptionIdPut($property_option_id, $property_option_id2)
    {
        list($response) = $this->restPropertiesOptionsPropertyOptionIdPutWithHttpInfo($property_option_id, $property_option_id2);
        return $response;
    }

    /**
     * Operation restPropertiesOptionsPropertyOptionIdPutWithHttpInfo
     *
     * Update a property option
     *
     * @param  int $property_option_id The ID of the property option (required)
     * @param  int $property_option_id2 (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesOptionsPropertyOptionIdPutWithHttpInfo($property_option_id, $property_option_id2)
    {
        $request = $this->restPropertiesOptionsPropertyOptionIdPutRequest($property_option_id, $property_option_id2);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyOption' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyOption';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesOptionsPropertyOptionIdPutAsync
     *
     * Update a property option
     *
     * @param  int $property_option_id The ID of the property option (required)
     * @param  int $property_option_id2 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesOptionsPropertyOptionIdPutAsync($property_option_id, $property_option_id2)
    {
        return $this->restPropertiesOptionsPropertyOptionIdPutAsyncWithHttpInfo($property_option_id, $property_option_id2)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesOptionsPropertyOptionIdPutAsyncWithHttpInfo
     *
     * Update a property option
     *
     * @param  int $property_option_id The ID of the property option (required)
     * @param  int $property_option_id2 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesOptionsPropertyOptionIdPutAsyncWithHttpInfo($property_option_id, $property_option_id2)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyOption';
        $request = $this->restPropertiesOptionsPropertyOptionIdPutRequest($property_option_id, $property_option_id2);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesOptionsPropertyOptionIdPut'
     *
     * @param  int $property_option_id The ID of the property option (required)
     * @param  int $property_option_id2 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesOptionsPropertyOptionIdPutRequest($property_option_id, $property_option_id2)
    {
        // verify the required parameter 'property_option_id' is set
        if ($property_option_id === null || (is_array($property_option_id) && count($property_option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_option_id when calling restPropertiesOptionsPropertyOptionIdPut'
            );
        }
        // verify the required parameter 'property_option_id2' is set
        if ($property_option_id2 === null || (is_array($property_option_id2) && count($property_option_id2) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_option_id2 when calling restPropertiesOptionsPropertyOptionIdPut'
            );
        }

        $resourcePath = '/rest/properties/options/{propertyOptionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($property_option_id)) {
            $property_option_id = ObjectSerializer::serializeCollection($property_option_id, '', true);
        }
        if ($property_option_id !== null) {
            $queryParams['$propertyOptionId'] = $property_option_id;
        }


        // path params
        if ($property_option_id2 !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyOptionId' . '}',
                ObjectSerializer::toPathValue($property_option_id2),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesPost
     *
     * Create a property
     *
     * @param  string $cast The cast of the property (required)
     * @param  string $type_identifier The identifier of the property type (required)
     * @param  int $position The position of the property (required)
     * @param  \OpenAPI\Client\Model\InlineObject212 $_rest_properties _rest_properties (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Property
     */
    public function restPropertiesPost($cast, $type_identifier, $position, $_rest_properties = null)
    {
        list($response) = $this->restPropertiesPostWithHttpInfo($cast, $type_identifier, $position, $_rest_properties);
        return $response;
    }

    /**
     * Operation restPropertiesPostWithHttpInfo
     *
     * Create a property
     *
     * @param  string $cast The cast of the property (required)
     * @param  string $type_identifier The identifier of the property type (required)
     * @param  int $position The position of the property (required)
     * @param  \OpenAPI\Client\Model\InlineObject212 $_rest_properties (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Property, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesPostWithHttpInfo($cast, $type_identifier, $position, $_rest_properties = null)
    {
        $request = $this->restPropertiesPostRequest($cast, $type_identifier, $position, $_rest_properties);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Property' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Property', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Property';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Property',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesPostAsync
     *
     * Create a property
     *
     * @param  string $cast The cast of the property (required)
     * @param  string $type_identifier The identifier of the property type (required)
     * @param  int $position The position of the property (required)
     * @param  \OpenAPI\Client\Model\InlineObject212 $_rest_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesPostAsync($cast, $type_identifier, $position, $_rest_properties = null)
    {
        return $this->restPropertiesPostAsyncWithHttpInfo($cast, $type_identifier, $position, $_rest_properties)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesPostAsyncWithHttpInfo
     *
     * Create a property
     *
     * @param  string $cast The cast of the property (required)
     * @param  string $type_identifier The identifier of the property type (required)
     * @param  int $position The position of the property (required)
     * @param  \OpenAPI\Client\Model\InlineObject212 $_rest_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesPostAsyncWithHttpInfo($cast, $type_identifier, $position, $_rest_properties = null)
    {
        $returnType = '\OpenAPI\Client\Model\Property';
        $request = $this->restPropertiesPostRequest($cast, $type_identifier, $position, $_rest_properties);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesPost'
     *
     * @param  string $cast The cast of the property (required)
     * @param  string $type_identifier The identifier of the property type (required)
     * @param  int $position The position of the property (required)
     * @param  \OpenAPI\Client\Model\InlineObject212 $_rest_properties (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesPostRequest($cast, $type_identifier, $position, $_rest_properties = null)
    {
        // verify the required parameter 'cast' is set
        if ($cast === null || (is_array($cast) && count($cast) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cast when calling restPropertiesPost'
            );
        }
        // verify the required parameter 'type_identifier' is set
        if ($type_identifier === null || (is_array($type_identifier) && count($type_identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_identifier when calling restPropertiesPost'
            );
        }
        // verify the required parameter 'position' is set
        if ($position === null || (is_array($position) && count($position) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $position when calling restPropertiesPost'
            );
        }

        $resourcePath = '/rest/properties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($cast)) {
            $cast = ObjectSerializer::serializeCollection($cast, '', true);
        }
        if ($cast !== null) {
            $queryParams['cast'] = $cast;
        }
        // query params
        if (is_array($type_identifier)) {
            $type_identifier = ObjectSerializer::serializeCollection($type_identifier, '', true);
        }
        if ($type_identifier !== null) {
            $queryParams['typeIdentifier'] = $type_identifier;
        }
        // query params
        if (is_array($position)) {
            $position = ObjectSerializer::serializeCollection($position, '', true);
        }
        if ($position !== null) {
            $queryParams['position'] = $position;
        }



        // body params
        $_tempBody = null;
        if (isset($_rest_properties)) {
            $_tempBody = $_rest_properties;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesPropertyIdDelete
     *
     * Delete a property
     *
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restPropertiesPropertyIdDelete($property_id)
    {
        $this->restPropertiesPropertyIdDeleteWithHttpInfo($property_id);
    }

    /**
     * Operation restPropertiesPropertyIdDeleteWithHttpInfo
     *
     * Delete a property
     *
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesPropertyIdDeleteWithHttpInfo($property_id)
    {
        $request = $this->restPropertiesPropertyIdDeleteRequest($property_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesPropertyIdDeleteAsync
     *
     * Delete a property
     *
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesPropertyIdDeleteAsync($property_id)
    {
        return $this->restPropertiesPropertyIdDeleteAsyncWithHttpInfo($property_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesPropertyIdDeleteAsyncWithHttpInfo
     *
     * Delete a property
     *
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesPropertyIdDeleteAsyncWithHttpInfo($property_id)
    {
        $returnType = '';
        $request = $this->restPropertiesPropertyIdDeleteRequest($property_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesPropertyIdDelete'
     *
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesPropertyIdDeleteRequest($property_id)
    {
        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesPropertyIdDelete'
            );
        }

        $resourcePath = '/rest/properties/{propertyId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesPropertyIdGet
     *
     * Get a property.
     *
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Property
     */
    public function restPropertiesPropertyIdGet($property_id)
    {
        list($response) = $this->restPropertiesPropertyIdGetWithHttpInfo($property_id);
        return $response;
    }

    /**
     * Operation restPropertiesPropertyIdGetWithHttpInfo
     *
     * Get a property.
     *
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Property, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesPropertyIdGetWithHttpInfo($property_id)
    {
        $request = $this->restPropertiesPropertyIdGetRequest($property_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Property' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Property', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Property';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Property',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesPropertyIdGetAsync
     *
     * Get a property.
     *
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesPropertyIdGetAsync($property_id)
    {
        return $this->restPropertiesPropertyIdGetAsyncWithHttpInfo($property_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesPropertyIdGetAsyncWithHttpInfo
     *
     * Get a property.
     *
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesPropertyIdGetAsyncWithHttpInfo($property_id)
    {
        $returnType = '\OpenAPI\Client\Model\Property';
        $request = $this->restPropertiesPropertyIdGetRequest($property_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesPropertyIdGet'
     *
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesPropertyIdGetRequest($property_id)
    {
        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesPropertyIdGet'
            );
        }

        $resourcePath = '/rest/properties/{propertyId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesPropertyIdPut
     *
     * Update a property
     *
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Property
     */
    public function restPropertiesPropertyIdPut($property_id)
    {
        list($response) = $this->restPropertiesPropertyIdPutWithHttpInfo($property_id);
        return $response;
    }

    /**
     * Operation restPropertiesPropertyIdPutWithHttpInfo
     *
     * Update a property
     *
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Property, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesPropertyIdPutWithHttpInfo($property_id)
    {
        $request = $this->restPropertiesPropertyIdPutRequest($property_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Property' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Property', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Property';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Property',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesPropertyIdPutAsync
     *
     * Update a property
     *
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesPropertyIdPutAsync($property_id)
    {
        return $this->restPropertiesPropertyIdPutAsyncWithHttpInfo($property_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesPropertyIdPutAsyncWithHttpInfo
     *
     * Update a property
     *
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesPropertyIdPutAsyncWithHttpInfo($property_id)
    {
        $returnType = '\OpenAPI\Client\Model\Property';
        $request = $this->restPropertiesPropertyIdPutRequest($property_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesPropertyIdPut'
     *
     * @param  int $property_id The ID of the property (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesPropertyIdPutRequest($property_id)
    {
        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesPropertyIdPut'
            );
        }

        $resourcePath = '/rest/properties/{propertyId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsDelete
     *
     * Delete property relations
     *
     * @param  int $relation_id The ID of the property relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restPropertiesRelationsDelete($relation_id)
    {
        $this->restPropertiesRelationsDeleteWithHttpInfo($relation_id);
    }

    /**
     * Operation restPropertiesRelationsDeleteWithHttpInfo
     *
     * Delete property relations
     *
     * @param  int $relation_id The ID of the property relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsDeleteWithHttpInfo($relation_id)
    {
        $request = $this->restPropertiesRelationsDeleteRequest($relation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsDeleteAsync
     *
     * Delete property relations
     *
     * @param  int $relation_id The ID of the property relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsDeleteAsync($relation_id)
    {
        return $this->restPropertiesRelationsDeleteAsyncWithHttpInfo($relation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsDeleteAsyncWithHttpInfo
     *
     * Delete property relations
     *
     * @param  int $relation_id The ID of the property relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsDeleteAsyncWithHttpInfo($relation_id)
    {
        $returnType = '';
        $request = $this->restPropertiesRelationsDeleteRequest($relation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsDelete'
     *
     * @param  int $relation_id The ID of the property relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesRelationsDeleteRequest($relation_id)
    {
        // verify the required parameter 'relation_id' is set
        if ($relation_id === null || (is_array($relation_id) && count($relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relation_id when calling restPropertiesRelationsDelete'
            );
        }

        $resourcePath = '/rest/properties/relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($relation_id)) {
            $relation_id = ObjectSerializer::serializeCollection($relation_id, '', true);
        }
        if ($relation_id !== null) {
            $queryParams['relationId'] = $relation_id;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsGet
     *
     * List property relations
     *
     * @param  int $page Current page of the response (optional)
     * @param  int $items_per_page The requested amount of items per result page (optional)
     * @param  int $paginate The condition that determines if the pagination should be used (default value is set to 0) (optional)
     * @param  string $relation_type_identifier The parameter that decides the type of relation (optional)
     * @param  int $relation_target_id The ID of the target of the relation (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyRelation[]
     */
    public function restPropertiesRelationsGet($page = null, $items_per_page = null, $paginate = null, $relation_type_identifier = null, $relation_target_id = null)
    {
        list($response) = $this->restPropertiesRelationsGetWithHttpInfo($page, $items_per_page, $paginate, $relation_type_identifier, $relation_target_id);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsGetWithHttpInfo
     *
     * List property relations
     *
     * @param  int $page Current page of the response (optional)
     * @param  int $items_per_page The requested amount of items per result page (optional)
     * @param  int $paginate The condition that determines if the pagination should be used (default value is set to 0) (optional)
     * @param  string $relation_type_identifier The parameter that decides the type of relation (optional)
     * @param  int $relation_target_id The ID of the target of the relation (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyRelation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsGetWithHttpInfo($page = null, $items_per_page = null, $paginate = null, $relation_type_identifier = null, $relation_target_id = null)
    {
        $request = $this->restPropertiesRelationsGetRequest($page, $items_per_page, $paginate, $relation_type_identifier, $relation_target_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyRelation[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyRelation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyRelation[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyRelation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsGetAsync
     *
     * List property relations
     *
     * @param  int $page Current page of the response (optional)
     * @param  int $items_per_page The requested amount of items per result page (optional)
     * @param  int $paginate The condition that determines if the pagination should be used (default value is set to 0) (optional)
     * @param  string $relation_type_identifier The parameter that decides the type of relation (optional)
     * @param  int $relation_target_id The ID of the target of the relation (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsGetAsync($page = null, $items_per_page = null, $paginate = null, $relation_type_identifier = null, $relation_target_id = null)
    {
        return $this->restPropertiesRelationsGetAsyncWithHttpInfo($page, $items_per_page, $paginate, $relation_type_identifier, $relation_target_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsGetAsyncWithHttpInfo
     *
     * List property relations
     *
     * @param  int $page Current page of the response (optional)
     * @param  int $items_per_page The requested amount of items per result page (optional)
     * @param  int $paginate The condition that determines if the pagination should be used (default value is set to 0) (optional)
     * @param  string $relation_type_identifier The parameter that decides the type of relation (optional)
     * @param  int $relation_target_id The ID of the target of the relation (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsGetAsyncWithHttpInfo($page = null, $items_per_page = null, $paginate = null, $relation_type_identifier = null, $relation_target_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyRelation[]';
        $request = $this->restPropertiesRelationsGetRequest($page, $items_per_page, $paginate, $relation_type_identifier, $relation_target_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsGet'
     *
     * @param  int $page Current page of the response (optional)
     * @param  int $items_per_page The requested amount of items per result page (optional)
     * @param  int $paginate The condition that determines if the pagination should be used (default value is set to 0) (optional)
     * @param  string $relation_type_identifier The parameter that decides the type of relation (optional)
     * @param  int $relation_target_id The ID of the target of the relation (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesRelationsGetRequest($page = null, $items_per_page = null, $paginate = null, $relation_type_identifier = null, $relation_target_id = null)
    {

        $resourcePath = '/rest/properties/relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }
        // query params
        if (is_array($paginate)) {
            $paginate = ObjectSerializer::serializeCollection($paginate, '', true);
        }
        if ($paginate !== null) {
            $queryParams['paginate'] = $paginate;
        }
        // query params
        if (is_array($relation_type_identifier)) {
            $relation_type_identifier = ObjectSerializer::serializeCollection($relation_type_identifier, '', true);
        }
        if ($relation_type_identifier !== null) {
            $queryParams['relationTypeIdentifier'] = $relation_type_identifier;
        }
        // query params
        if (is_array($relation_target_id)) {
            $relation_target_id = ObjectSerializer::serializeCollection($relation_target_id, '', true);
        }
        if ($relation_target_id !== null) {
            $queryParams['relationTargetId'] = $relation_target_id;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsMarkupsGet
     *
     * List relation markups
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyRelationMarkup[]
     */
    public function restPropertiesRelationsMarkupsGet()
    {
        list($response) = $this->restPropertiesRelationsMarkupsGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPropertiesRelationsMarkupsGetWithHttpInfo
     *
     * List relation markups
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyRelationMarkup[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsMarkupsGetWithHttpInfo()
    {
        $request = $this->restPropertiesRelationsMarkupsGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyRelationMarkup[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyRelationMarkup[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyRelationMarkup[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyRelationMarkup[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsMarkupsGetAsync
     *
     * List relation markups
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsMarkupsGetAsync()
    {
        return $this->restPropertiesRelationsMarkupsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsMarkupsGetAsyncWithHttpInfo
     *
     * List relation markups
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsMarkupsGetAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\PropertyRelationMarkup[]';
        $request = $this->restPropertiesRelationsMarkupsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsMarkupsGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesRelationsMarkupsGetRequest()
    {

        $resourcePath = '/rest/properties/relations/markups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsMarkupsPost
     *
     * Create a property relation markup
     *
     * @param  int $property_relation_id The ID of the property elation (required)
     * @param  int $variation_sales_price_id The ID of a variation&#39;s sales price (required)
     * @param  float $markup The property relation markup (required)
     * @param  \OpenAPI\Client\Model\InlineObject224 $_rest_properties_relations_markups _rest_properties_relations_markups (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyRelationMarkup
     */
    public function restPropertiesRelationsMarkupsPost($property_relation_id, $variation_sales_price_id, $markup, $_rest_properties_relations_markups = null)
    {
        list($response) = $this->restPropertiesRelationsMarkupsPostWithHttpInfo($property_relation_id, $variation_sales_price_id, $markup, $_rest_properties_relations_markups);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsMarkupsPostWithHttpInfo
     *
     * Create a property relation markup
     *
     * @param  int $property_relation_id The ID of the property elation (required)
     * @param  int $variation_sales_price_id The ID of a variation&#39;s sales price (required)
     * @param  float $markup The property relation markup (required)
     * @param  \OpenAPI\Client\Model\InlineObject224 $_rest_properties_relations_markups (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyRelationMarkup, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsMarkupsPostWithHttpInfo($property_relation_id, $variation_sales_price_id, $markup, $_rest_properties_relations_markups = null)
    {
        $request = $this->restPropertiesRelationsMarkupsPostRequest($property_relation_id, $variation_sales_price_id, $markup, $_rest_properties_relations_markups);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyRelationMarkup' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyRelationMarkup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyRelationMarkup';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyRelationMarkup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsMarkupsPostAsync
     *
     * Create a property relation markup
     *
     * @param  int $property_relation_id The ID of the property elation (required)
     * @param  int $variation_sales_price_id The ID of a variation&#39;s sales price (required)
     * @param  float $markup The property relation markup (required)
     * @param  \OpenAPI\Client\Model\InlineObject224 $_rest_properties_relations_markups (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsMarkupsPostAsync($property_relation_id, $variation_sales_price_id, $markup, $_rest_properties_relations_markups = null)
    {
        return $this->restPropertiesRelationsMarkupsPostAsyncWithHttpInfo($property_relation_id, $variation_sales_price_id, $markup, $_rest_properties_relations_markups)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsMarkupsPostAsyncWithHttpInfo
     *
     * Create a property relation markup
     *
     * @param  int $property_relation_id The ID of the property elation (required)
     * @param  int $variation_sales_price_id The ID of a variation&#39;s sales price (required)
     * @param  float $markup The property relation markup (required)
     * @param  \OpenAPI\Client\Model\InlineObject224 $_rest_properties_relations_markups (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsMarkupsPostAsyncWithHttpInfo($property_relation_id, $variation_sales_price_id, $markup, $_rest_properties_relations_markups = null)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyRelationMarkup';
        $request = $this->restPropertiesRelationsMarkupsPostRequest($property_relation_id, $variation_sales_price_id, $markup, $_rest_properties_relations_markups);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsMarkupsPost'
     *
     * @param  int $property_relation_id The ID of the property elation (required)
     * @param  int $variation_sales_price_id The ID of a variation&#39;s sales price (required)
     * @param  float $markup The property relation markup (required)
     * @param  \OpenAPI\Client\Model\InlineObject224 $_rest_properties_relations_markups (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesRelationsMarkupsPostRequest($property_relation_id, $variation_sales_price_id, $markup, $_rest_properties_relations_markups = null)
    {
        // verify the required parameter 'property_relation_id' is set
        if ($property_relation_id === null || (is_array($property_relation_id) && count($property_relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_relation_id when calling restPropertiesRelationsMarkupsPost'
            );
        }
        // verify the required parameter 'variation_sales_price_id' is set
        if ($variation_sales_price_id === null || (is_array($variation_sales_price_id) && count($variation_sales_price_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $variation_sales_price_id when calling restPropertiesRelationsMarkupsPost'
            );
        }
        // verify the required parameter 'markup' is set
        if ($markup === null || (is_array($markup) && count($markup) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $markup when calling restPropertiesRelationsMarkupsPost'
            );
        }

        $resourcePath = '/rest/properties/relations/markups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($property_relation_id)) {
            $property_relation_id = ObjectSerializer::serializeCollection($property_relation_id, '', true);
        }
        if ($property_relation_id !== null) {
            $queryParams['propertyRelationId'] = $property_relation_id;
        }
        // query params
        if (is_array($variation_sales_price_id)) {
            $variation_sales_price_id = ObjectSerializer::serializeCollection($variation_sales_price_id, '', true);
        }
        if ($variation_sales_price_id !== null) {
            $queryParams['variationSalesPriceId'] = $variation_sales_price_id;
        }
        // query params
        if (is_array($markup)) {
            $markup = ObjectSerializer::serializeCollection($markup, '', true);
        }
        if ($markup !== null) {
            $queryParams['markup'] = $markup;
        }



        // body params
        $_tempBody = null;
        if (isset($_rest_properties_relations_markups)) {
            $_tempBody = $_rest_properties_relations_markups;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsMarkupsRelationMarkupIdDelete
     *
     * Delete a property relation markup
     *
     * @param  int $relation_markup_id The ID of the relation markup (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdDelete($relation_markup_id)
    {
        $this->restPropertiesRelationsMarkupsRelationMarkupIdDeleteWithHttpInfo($relation_markup_id);
    }

    /**
     * Operation restPropertiesRelationsMarkupsRelationMarkupIdDeleteWithHttpInfo
     *
     * Delete a property relation markup
     *
     * @param  int $relation_markup_id The ID of the relation markup (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdDeleteWithHttpInfo($relation_markup_id)
    {
        $request = $this->restPropertiesRelationsMarkupsRelationMarkupIdDeleteRequest($relation_markup_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsMarkupsRelationMarkupIdDeleteAsync
     *
     * Delete a property relation markup
     *
     * @param  int $relation_markup_id The ID of the relation markup (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdDeleteAsync($relation_markup_id)
    {
        return $this->restPropertiesRelationsMarkupsRelationMarkupIdDeleteAsyncWithHttpInfo($relation_markup_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsMarkupsRelationMarkupIdDeleteAsyncWithHttpInfo
     *
     * Delete a property relation markup
     *
     * @param  int $relation_markup_id The ID of the relation markup (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdDeleteAsyncWithHttpInfo($relation_markup_id)
    {
        $returnType = '';
        $request = $this->restPropertiesRelationsMarkupsRelationMarkupIdDeleteRequest($relation_markup_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsMarkupsRelationMarkupIdDelete'
     *
     * @param  int $relation_markup_id The ID of the relation markup (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesRelationsMarkupsRelationMarkupIdDeleteRequest($relation_markup_id)
    {
        // verify the required parameter 'relation_markup_id' is set
        if ($relation_markup_id === null || (is_array($relation_markup_id) && count($relation_markup_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relation_markup_id when calling restPropertiesRelationsMarkupsRelationMarkupIdDelete'
            );
        }

        $resourcePath = '/rest/properties/relations/markups/{relationMarkupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($relation_markup_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationMarkupId' . '}',
                ObjectSerializer::toPathValue($relation_markup_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsMarkupsRelationMarkupIdGet
     *
     * Get a property relation markup
     *
     * @param  int $relation_markup_id The ID of the relation markup (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyRelationMarkup
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdGet($relation_markup_id)
    {
        list($response) = $this->restPropertiesRelationsMarkupsRelationMarkupIdGetWithHttpInfo($relation_markup_id);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsMarkupsRelationMarkupIdGetWithHttpInfo
     *
     * Get a property relation markup
     *
     * @param  int $relation_markup_id The ID of the relation markup (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyRelationMarkup, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdGetWithHttpInfo($relation_markup_id)
    {
        $request = $this->restPropertiesRelationsMarkupsRelationMarkupIdGetRequest($relation_markup_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyRelationMarkup' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyRelationMarkup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyRelationMarkup';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyRelationMarkup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsMarkupsRelationMarkupIdGetAsync
     *
     * Get a property relation markup
     *
     * @param  int $relation_markup_id The ID of the relation markup (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdGetAsync($relation_markup_id)
    {
        return $this->restPropertiesRelationsMarkupsRelationMarkupIdGetAsyncWithHttpInfo($relation_markup_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsMarkupsRelationMarkupIdGetAsyncWithHttpInfo
     *
     * Get a property relation markup
     *
     * @param  int $relation_markup_id The ID of the relation markup (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdGetAsyncWithHttpInfo($relation_markup_id)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyRelationMarkup';
        $request = $this->restPropertiesRelationsMarkupsRelationMarkupIdGetRequest($relation_markup_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsMarkupsRelationMarkupIdGet'
     *
     * @param  int $relation_markup_id The ID of the relation markup (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesRelationsMarkupsRelationMarkupIdGetRequest($relation_markup_id)
    {
        // verify the required parameter 'relation_markup_id' is set
        if ($relation_markup_id === null || (is_array($relation_markup_id) && count($relation_markup_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relation_markup_id when calling restPropertiesRelationsMarkupsRelationMarkupIdGet'
            );
        }

        $resourcePath = '/rest/properties/relations/markups/{relationMarkupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($relation_markup_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationMarkupId' . '}',
                ObjectSerializer::toPathValue($relation_markup_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsMarkupsRelationMarkupIdPut
     *
     * Update a property relation markup
     *
     * @param  int $relation_markup_id The ID of the property relation markup (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyRelationMarkup
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdPut($relation_markup_id)
    {
        list($response) = $this->restPropertiesRelationsMarkupsRelationMarkupIdPutWithHttpInfo($relation_markup_id);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsMarkupsRelationMarkupIdPutWithHttpInfo
     *
     * Update a property relation markup
     *
     * @param  int $relation_markup_id The ID of the property relation markup (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyRelationMarkup, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdPutWithHttpInfo($relation_markup_id)
    {
        $request = $this->restPropertiesRelationsMarkupsRelationMarkupIdPutRequest($relation_markup_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyRelationMarkup' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyRelationMarkup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyRelationMarkup';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyRelationMarkup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsMarkupsRelationMarkupIdPutAsync
     *
     * Update a property relation markup
     *
     * @param  int $relation_markup_id The ID of the property relation markup (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdPutAsync($relation_markup_id)
    {
        return $this->restPropertiesRelationsMarkupsRelationMarkupIdPutAsyncWithHttpInfo($relation_markup_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsMarkupsRelationMarkupIdPutAsyncWithHttpInfo
     *
     * Update a property relation markup
     *
     * @param  int $relation_markup_id The ID of the property relation markup (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdPutAsyncWithHttpInfo($relation_markup_id)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyRelationMarkup';
        $request = $this->restPropertiesRelationsMarkupsRelationMarkupIdPutRequest($relation_markup_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsMarkupsRelationMarkupIdPut'
     *
     * @param  int $relation_markup_id The ID of the property relation markup (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesRelationsMarkupsRelationMarkupIdPutRequest($relation_markup_id)
    {
        // verify the required parameter 'relation_markup_id' is set
        if ($relation_markup_id === null || (is_array($relation_markup_id) && count($relation_markup_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relation_markup_id when calling restPropertiesRelationsMarkupsRelationMarkupIdPut'
            );
        }

        $resourcePath = '/rest/properties/relations/markups/{relationMarkupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($relation_markup_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationMarkupId' . '}',
                ObjectSerializer::toPathValue($relation_markup_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsPost
     *
     * Create a property relation
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $relation_type_identifier The identifier of the property relation type (required)
     * @param  int $relation_target_id The ID of the property relation target (required)
     * @param  int $selection_relation_id The ID of the property selection relation (required)
     * @param  \OpenAPI\Client\Model\InlineObject223 $_rest_properties_relations _rest_properties_relations (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyRelation
     */
    public function restPropertiesRelationsPost($property_id, $relation_type_identifier, $relation_target_id, $selection_relation_id, $_rest_properties_relations = null)
    {
        list($response) = $this->restPropertiesRelationsPostWithHttpInfo($property_id, $relation_type_identifier, $relation_target_id, $selection_relation_id, $_rest_properties_relations);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsPostWithHttpInfo
     *
     * Create a property relation
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $relation_type_identifier The identifier of the property relation type (required)
     * @param  int $relation_target_id The ID of the property relation target (required)
     * @param  int $selection_relation_id The ID of the property selection relation (required)
     * @param  \OpenAPI\Client\Model\InlineObject223 $_rest_properties_relations (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsPostWithHttpInfo($property_id, $relation_type_identifier, $relation_target_id, $selection_relation_id, $_rest_properties_relations = null)
    {
        $request = $this->restPropertiesRelationsPostRequest($property_id, $relation_type_identifier, $relation_target_id, $selection_relation_id, $_rest_properties_relations);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyRelation' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyRelation';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsPostAsync
     *
     * Create a property relation
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $relation_type_identifier The identifier of the property relation type (required)
     * @param  int $relation_target_id The ID of the property relation target (required)
     * @param  int $selection_relation_id The ID of the property selection relation (required)
     * @param  \OpenAPI\Client\Model\InlineObject223 $_rest_properties_relations (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsPostAsync($property_id, $relation_type_identifier, $relation_target_id, $selection_relation_id, $_rest_properties_relations = null)
    {
        return $this->restPropertiesRelationsPostAsyncWithHttpInfo($property_id, $relation_type_identifier, $relation_target_id, $selection_relation_id, $_rest_properties_relations)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsPostAsyncWithHttpInfo
     *
     * Create a property relation
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $relation_type_identifier The identifier of the property relation type (required)
     * @param  int $relation_target_id The ID of the property relation target (required)
     * @param  int $selection_relation_id The ID of the property selection relation (required)
     * @param  \OpenAPI\Client\Model\InlineObject223 $_rest_properties_relations (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsPostAsyncWithHttpInfo($property_id, $relation_type_identifier, $relation_target_id, $selection_relation_id, $_rest_properties_relations = null)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyRelation';
        $request = $this->restPropertiesRelationsPostRequest($property_id, $relation_type_identifier, $relation_target_id, $selection_relation_id, $_rest_properties_relations);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsPost'
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $relation_type_identifier The identifier of the property relation type (required)
     * @param  int $relation_target_id The ID of the property relation target (required)
     * @param  int $selection_relation_id The ID of the property selection relation (required)
     * @param  \OpenAPI\Client\Model\InlineObject223 $_rest_properties_relations (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesRelationsPostRequest($property_id, $relation_type_identifier, $relation_target_id, $selection_relation_id, $_rest_properties_relations = null)
    {
        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesRelationsPost'
            );
        }
        // verify the required parameter 'relation_type_identifier' is set
        if ($relation_type_identifier === null || (is_array($relation_type_identifier) && count($relation_type_identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relation_type_identifier when calling restPropertiesRelationsPost'
            );
        }
        // verify the required parameter 'relation_target_id' is set
        if ($relation_target_id === null || (is_array($relation_target_id) && count($relation_target_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relation_target_id when calling restPropertiesRelationsPost'
            );
        }
        // verify the required parameter 'selection_relation_id' is set
        if ($selection_relation_id === null || (is_array($selection_relation_id) && count($selection_relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $selection_relation_id when calling restPropertiesRelationsPost'
            );
        }

        $resourcePath = '/rest/properties/relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($property_id)) {
            $property_id = ObjectSerializer::serializeCollection($property_id, '', true);
        }
        if ($property_id !== null) {
            $queryParams['propertyId'] = $property_id;
        }
        // query params
        if (is_array($relation_type_identifier)) {
            $relation_type_identifier = ObjectSerializer::serializeCollection($relation_type_identifier, '', true);
        }
        if ($relation_type_identifier !== null) {
            $queryParams['relationTypeIdentifier'] = $relation_type_identifier;
        }
        // query params
        if (is_array($relation_target_id)) {
            $relation_target_id = ObjectSerializer::serializeCollection($relation_target_id, '', true);
        }
        if ($relation_target_id !== null) {
            $queryParams['relationTargetId'] = $relation_target_id;
        }
        // query params
        if (is_array($selection_relation_id)) {
            $selection_relation_id = ObjectSerializer::serializeCollection($selection_relation_id, '', true);
        }
        if ($selection_relation_id !== null) {
            $queryParams['selectionRelationId'] = $selection_relation_id;
        }



        // body params
        $_tempBody = null;
        if (isset($_rest_properties_relations)) {
            $_tempBody = $_rest_properties_relations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsPut
     *
     * Update relations
     *
     * @param  int $relation_id The ID of the property relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyRelation[]
     */
    public function restPropertiesRelationsPut($relation_id)
    {
        list($response) = $this->restPropertiesRelationsPutWithHttpInfo($relation_id);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsPutWithHttpInfo
     *
     * Update relations
     *
     * @param  int $relation_id The ID of the property relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyRelation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsPutWithHttpInfo($relation_id)
    {
        $request = $this->restPropertiesRelationsPutRequest($relation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyRelation[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyRelation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyRelation[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyRelation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsPutAsync
     *
     * Update relations
     *
     * @param  int $relation_id The ID of the property relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsPutAsync($relation_id)
    {
        return $this->restPropertiesRelationsPutAsyncWithHttpInfo($relation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsPutAsyncWithHttpInfo
     *
     * Update relations
     *
     * @param  int $relation_id The ID of the property relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsPutAsyncWithHttpInfo($relation_id)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyRelation[]';
        $request = $this->restPropertiesRelationsPutRequest($relation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsPut'
     *
     * @param  int $relation_id The ID of the property relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesRelationsPutRequest($relation_id)
    {
        // verify the required parameter 'relation_id' is set
        if ($relation_id === null || (is_array($relation_id) && count($relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relation_id when calling restPropertiesRelationsPut'
            );
        }

        $resourcePath = '/rest/properties/relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($relation_id)) {
            $relation_id = ObjectSerializer::serializeCollection($relation_id, '', true);
        }
        if ($relation_id !== null) {
            $queryParams['relationId'] = $relation_id;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsRelationIdDelete
     *
     * Delete a property relation
     *
     * @param  int $relation_id The ID of the property relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restPropertiesRelationsRelationIdDelete($relation_id)
    {
        $this->restPropertiesRelationsRelationIdDeleteWithHttpInfo($relation_id);
    }

    /**
     * Operation restPropertiesRelationsRelationIdDeleteWithHttpInfo
     *
     * Delete a property relation
     *
     * @param  int $relation_id The ID of the property relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsRelationIdDeleteWithHttpInfo($relation_id)
    {
        $request = $this->restPropertiesRelationsRelationIdDeleteRequest($relation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsRelationIdDeleteAsync
     *
     * Delete a property relation
     *
     * @param  int $relation_id The ID of the property relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsRelationIdDeleteAsync($relation_id)
    {
        return $this->restPropertiesRelationsRelationIdDeleteAsyncWithHttpInfo($relation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsRelationIdDeleteAsyncWithHttpInfo
     *
     * Delete a property relation
     *
     * @param  int $relation_id The ID of the property relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsRelationIdDeleteAsyncWithHttpInfo($relation_id)
    {
        $returnType = '';
        $request = $this->restPropertiesRelationsRelationIdDeleteRequest($relation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsRelationIdDelete'
     *
     * @param  int $relation_id The ID of the property relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesRelationsRelationIdDeleteRequest($relation_id)
    {
        // verify the required parameter 'relation_id' is set
        if ($relation_id === null || (is_array($relation_id) && count($relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relation_id when calling restPropertiesRelationsRelationIdDelete'
            );
        }

        $resourcePath = '/rest/properties/relations/{relationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationId' . '}',
                ObjectSerializer::toPathValue($relation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsRelationIdFilePost
     *
     * Save property relation file to S3
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $key The name of the file that needs to be saved (required)
     * @param  string $content The actual file content in text format (required)
     * @param  bool $delete_if_exists Condition for the check of already existing file (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restPropertiesRelationsRelationIdFilePost($relation_id, $key, $content, $delete_if_exists)
    {
        list($response) = $this->restPropertiesRelationsRelationIdFilePostWithHttpInfo($relation_id, $key, $content, $delete_if_exists);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsRelationIdFilePostWithHttpInfo
     *
     * Save property relation file to S3
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $key The name of the file that needs to be saved (required)
     * @param  string $content The actual file content in text format (required)
     * @param  bool $delete_if_exists Condition for the check of already existing file (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsRelationIdFilePostWithHttpInfo($relation_id, $key, $content, $delete_if_exists)
    {
        $request = $this->restPropertiesRelationsRelationIdFilePostRequest($relation_id, $key, $content, $delete_if_exists);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsRelationIdFilePostAsync
     *
     * Save property relation file to S3
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $key The name of the file that needs to be saved (required)
     * @param  string $content The actual file content in text format (required)
     * @param  bool $delete_if_exists Condition for the check of already existing file (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsRelationIdFilePostAsync($relation_id, $key, $content, $delete_if_exists)
    {
        return $this->restPropertiesRelationsRelationIdFilePostAsyncWithHttpInfo($relation_id, $key, $content, $delete_if_exists)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsRelationIdFilePostAsyncWithHttpInfo
     *
     * Save property relation file to S3
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $key The name of the file that needs to be saved (required)
     * @param  string $content The actual file content in text format (required)
     * @param  bool $delete_if_exists Condition for the check of already existing file (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsRelationIdFilePostAsyncWithHttpInfo($relation_id, $key, $content, $delete_if_exists)
    {
        $returnType = 'object';
        $request = $this->restPropertiesRelationsRelationIdFilePostRequest($relation_id, $key, $content, $delete_if_exists);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsRelationIdFilePost'
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $key The name of the file that needs to be saved (required)
     * @param  string $content The actual file content in text format (required)
     * @param  bool $delete_if_exists Condition for the check of already existing file (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesRelationsRelationIdFilePostRequest($relation_id, $key, $content, $delete_if_exists)
    {
        // verify the required parameter 'relation_id' is set
        if ($relation_id === null || (is_array($relation_id) && count($relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relation_id when calling restPropertiesRelationsRelationIdFilePost'
            );
        }
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling restPropertiesRelationsRelationIdFilePost'
            );
        }
        // verify the required parameter 'content' is set
        if ($content === null || (is_array($content) && count($content) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content when calling restPropertiesRelationsRelationIdFilePost'
            );
        }
        // verify the required parameter 'delete_if_exists' is set
        if ($delete_if_exists === null || (is_array($delete_if_exists) && count($delete_if_exists) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $delete_if_exists when calling restPropertiesRelationsRelationIdFilePost'
            );
        }

        $resourcePath = '/rest/properties/relations/{relationId}/file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($key)) {
            $key = ObjectSerializer::serializeCollection($key, '', true);
        }
        if ($key !== null) {
            $queryParams['key'] = $key;
        }
        // query params
        if (is_array($content)) {
            $content = ObjectSerializer::serializeCollection($content, '', true);
        }
        if ($content !== null) {
            $queryParams['content'] = $content;
        }
        // query params
        if (is_array($delete_if_exists)) {
            $delete_if_exists = ObjectSerializer::serializeCollection($delete_if_exists, '', true);
        }
        if ($delete_if_exists !== null) {
            $queryParams['deleteIfExists'] = $delete_if_exists;
        }


        // path params
        if ($relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationId' . '}',
                ObjectSerializer::toPathValue($relation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsRelationIdGet
     *
     * Get a property relation
     *
     * @param  int $relation_id The ID of the relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyRelation
     */
    public function restPropertiesRelationsRelationIdGet($relation_id)
    {
        list($response) = $this->restPropertiesRelationsRelationIdGetWithHttpInfo($relation_id);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsRelationIdGetWithHttpInfo
     *
     * Get a property relation
     *
     * @param  int $relation_id The ID of the relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsRelationIdGetWithHttpInfo($relation_id)
    {
        $request = $this->restPropertiesRelationsRelationIdGetRequest($relation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyRelation' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyRelation';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsRelationIdGetAsync
     *
     * Get a property relation
     *
     * @param  int $relation_id The ID of the relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsRelationIdGetAsync($relation_id)
    {
        return $this->restPropertiesRelationsRelationIdGetAsyncWithHttpInfo($relation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsRelationIdGetAsyncWithHttpInfo
     *
     * Get a property relation
     *
     * @param  int $relation_id The ID of the relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsRelationIdGetAsyncWithHttpInfo($relation_id)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyRelation';
        $request = $this->restPropertiesRelationsRelationIdGetRequest($relation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsRelationIdGet'
     *
     * @param  int $relation_id The ID of the relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesRelationsRelationIdGetRequest($relation_id)
    {
        // verify the required parameter 'relation_id' is set
        if ($relation_id === null || (is_array($relation_id) && count($relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relation_id when calling restPropertiesRelationsRelationIdGet'
            );
        }

        $resourcePath = '/rest/properties/relations/{relationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationId' . '}',
                ObjectSerializer::toPathValue($relation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsRelationIdPut
     *
     * Update a property relation
     *
     * @param  int $relation_id The ID of the property relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyRelation
     */
    public function restPropertiesRelationsRelationIdPut($relation_id)
    {
        list($response) = $this->restPropertiesRelationsRelationIdPutWithHttpInfo($relation_id);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsRelationIdPutWithHttpInfo
     *
     * Update a property relation
     *
     * @param  int $relation_id The ID of the property relation (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsRelationIdPutWithHttpInfo($relation_id)
    {
        $request = $this->restPropertiesRelationsRelationIdPutRequest($relation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyRelation' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyRelation';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsRelationIdPutAsync
     *
     * Update a property relation
     *
     * @param  int $relation_id The ID of the property relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsRelationIdPutAsync($relation_id)
    {
        return $this->restPropertiesRelationsRelationIdPutAsyncWithHttpInfo($relation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsRelationIdPutAsyncWithHttpInfo
     *
     * Update a property relation
     *
     * @param  int $relation_id The ID of the property relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsRelationIdPutAsyncWithHttpInfo($relation_id)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyRelation';
        $request = $this->restPropertiesRelationsRelationIdPutRequest($relation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsRelationIdPut'
     *
     * @param  int $relation_id The ID of the property relation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesRelationsRelationIdPutRequest($relation_id)
    {
        // verify the required parameter 'relation_id' is set
        if ($relation_id === null || (is_array($relation_id) && count($relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relation_id when calling restPropertiesRelationsRelationIdPut'
            );
        }

        $resourcePath = '/rest/properties/relations/{relationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationId' . '}',
                ObjectSerializer::toPathValue($relation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsRelationIdValuesDelete
     *
     * Delete all property relation values of a specified property relation
     *
     * @param  int $relation_id relation_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restPropertiesRelationsRelationIdValuesDelete($relation_id)
    {
        $this->restPropertiesRelationsRelationIdValuesDeleteWithHttpInfo($relation_id);
    }

    /**
     * Operation restPropertiesRelationsRelationIdValuesDeleteWithHttpInfo
     *
     * Delete all property relation values of a specified property relation
     *
     * @param  int $relation_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsRelationIdValuesDeleteWithHttpInfo($relation_id)
    {
        $request = $this->restPropertiesRelationsRelationIdValuesDeleteRequest($relation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsRelationIdValuesDeleteAsync
     *
     * Delete all property relation values of a specified property relation
     *
     * @param  int $relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsRelationIdValuesDeleteAsync($relation_id)
    {
        return $this->restPropertiesRelationsRelationIdValuesDeleteAsyncWithHttpInfo($relation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsRelationIdValuesDeleteAsyncWithHttpInfo
     *
     * Delete all property relation values of a specified property relation
     *
     * @param  int $relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsRelationIdValuesDeleteAsyncWithHttpInfo($relation_id)
    {
        $returnType = '';
        $request = $this->restPropertiesRelationsRelationIdValuesDeleteRequest($relation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsRelationIdValuesDelete'
     *
     * @param  int $relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesRelationsRelationIdValuesDeleteRequest($relation_id)
    {
        // verify the required parameter 'relation_id' is set
        if ($relation_id === null || (is_array($relation_id) && count($relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relation_id when calling restPropertiesRelationsRelationIdValuesDelete'
            );
        }

        $resourcePath = '/rest/properties/relations/{relationId}/values';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationId' . '}',
                ObjectSerializer::toPathValue($relation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsValuesGet
     *
     * List property relation values
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyRelationValue[]
     */
    public function restPropertiesRelationsValuesGet()
    {
        list($response) = $this->restPropertiesRelationsValuesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPropertiesRelationsValuesGetWithHttpInfo
     *
     * List property relation values
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyRelationValue[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsValuesGetWithHttpInfo()
    {
        $request = $this->restPropertiesRelationsValuesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyRelationValue[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyRelationValue[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyRelationValue[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyRelationValue[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsValuesGetAsync
     *
     * List property relation values
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsValuesGetAsync()
    {
        return $this->restPropertiesRelationsValuesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsValuesGetAsyncWithHttpInfo
     *
     * List property relation values
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsValuesGetAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\PropertyRelationValue[]';
        $request = $this->restPropertiesRelationsValuesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsValuesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesRelationsValuesGetRequest()
    {

        $resourcePath = '/rest/properties/relations/values';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsValuesPost
     *
     * Create a property relation value
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $lang The lang of the property relation value (required)
     * @param  string $value The value of the property relation (required)
     * @param  \OpenAPI\Client\Model\InlineObject225 $_rest_properties_relations_values _rest_properties_relations_values (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyRelationValue
     */
    public function restPropertiesRelationsValuesPost($property_id, $lang, $value, $_rest_properties_relations_values = null)
    {
        list($response) = $this->restPropertiesRelationsValuesPostWithHttpInfo($property_id, $lang, $value, $_rest_properties_relations_values);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsValuesPostWithHttpInfo
     *
     * Create a property relation value
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $lang The lang of the property relation value (required)
     * @param  string $value The value of the property relation (required)
     * @param  \OpenAPI\Client\Model\InlineObject225 $_rest_properties_relations_values (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyRelationValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsValuesPostWithHttpInfo($property_id, $lang, $value, $_rest_properties_relations_values = null)
    {
        $request = $this->restPropertiesRelationsValuesPostRequest($property_id, $lang, $value, $_rest_properties_relations_values);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyRelationValue' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyRelationValue', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyRelationValue';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyRelationValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsValuesPostAsync
     *
     * Create a property relation value
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $lang The lang of the property relation value (required)
     * @param  string $value The value of the property relation (required)
     * @param  \OpenAPI\Client\Model\InlineObject225 $_rest_properties_relations_values (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsValuesPostAsync($property_id, $lang, $value, $_rest_properties_relations_values = null)
    {
        return $this->restPropertiesRelationsValuesPostAsyncWithHttpInfo($property_id, $lang, $value, $_rest_properties_relations_values)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsValuesPostAsyncWithHttpInfo
     *
     * Create a property relation value
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $lang The lang of the property relation value (required)
     * @param  string $value The value of the property relation (required)
     * @param  \OpenAPI\Client\Model\InlineObject225 $_rest_properties_relations_values (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsValuesPostAsyncWithHttpInfo($property_id, $lang, $value, $_rest_properties_relations_values = null)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyRelationValue';
        $request = $this->restPropertiesRelationsValuesPostRequest($property_id, $lang, $value, $_rest_properties_relations_values);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsValuesPost'
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $lang The lang of the property relation value (required)
     * @param  string $value The value of the property relation (required)
     * @param  \OpenAPI\Client\Model\InlineObject225 $_rest_properties_relations_values (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesRelationsValuesPostRequest($property_id, $lang, $value, $_rest_properties_relations_values = null)
    {
        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesRelationsValuesPost'
            );
        }
        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lang when calling restPropertiesRelationsValuesPost'
            );
        }
        // verify the required parameter 'value' is set
        if ($value === null || (is_array($value) && count($value) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $value when calling restPropertiesRelationsValuesPost'
            );
        }

        $resourcePath = '/rest/properties/relations/values';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($property_id)) {
            $property_id = ObjectSerializer::serializeCollection($property_id, '', true);
        }
        if ($property_id !== null) {
            $queryParams['propertyId'] = $property_id;
        }
        // query params
        if (is_array($lang)) {
            $lang = ObjectSerializer::serializeCollection($lang, '', true);
        }
        if ($lang !== null) {
            $queryParams['lang'] = $lang;
        }
        // query params
        if (is_array($value)) {
            $value = ObjectSerializer::serializeCollection($value, '', true);
        }
        if ($value !== null) {
            $queryParams['value'] = $value;
        }



        // body params
        $_tempBody = null;
        if (isset($_rest_properties_relations_values)) {
            $_tempBody = $_rest_properties_relations_values;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsValuesPropertiesRelationValueIdDelete
     *
     * Delete a property relation value
     *
     * @param  int $property_relation_value_id The ID of the property relation value (required)
     * @param  int $properties_relation_value_id properties_relation_value_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restPropertiesRelationsValuesPropertiesRelationValueIdDelete($property_relation_value_id, $properties_relation_value_id)
    {
        $this->restPropertiesRelationsValuesPropertiesRelationValueIdDeleteWithHttpInfo($property_relation_value_id, $properties_relation_value_id);
    }

    /**
     * Operation restPropertiesRelationsValuesPropertiesRelationValueIdDeleteWithHttpInfo
     *
     * Delete a property relation value
     *
     * @param  int $property_relation_value_id The ID of the property relation value (required)
     * @param  int $properties_relation_value_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsValuesPropertiesRelationValueIdDeleteWithHttpInfo($property_relation_value_id, $properties_relation_value_id)
    {
        $request = $this->restPropertiesRelationsValuesPropertiesRelationValueIdDeleteRequest($property_relation_value_id, $properties_relation_value_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsValuesPropertiesRelationValueIdDeleteAsync
     *
     * Delete a property relation value
     *
     * @param  int $property_relation_value_id The ID of the property relation value (required)
     * @param  int $properties_relation_value_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsValuesPropertiesRelationValueIdDeleteAsync($property_relation_value_id, $properties_relation_value_id)
    {
        return $this->restPropertiesRelationsValuesPropertiesRelationValueIdDeleteAsyncWithHttpInfo($property_relation_value_id, $properties_relation_value_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsValuesPropertiesRelationValueIdDeleteAsyncWithHttpInfo
     *
     * Delete a property relation value
     *
     * @param  int $property_relation_value_id The ID of the property relation value (required)
     * @param  int $properties_relation_value_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsValuesPropertiesRelationValueIdDeleteAsyncWithHttpInfo($property_relation_value_id, $properties_relation_value_id)
    {
        $returnType = '';
        $request = $this->restPropertiesRelationsValuesPropertiesRelationValueIdDeleteRequest($property_relation_value_id, $properties_relation_value_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsValuesPropertiesRelationValueIdDelete'
     *
     * @param  int $property_relation_value_id The ID of the property relation value (required)
     * @param  int $properties_relation_value_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesRelationsValuesPropertiesRelationValueIdDeleteRequest($property_relation_value_id, $properties_relation_value_id)
    {
        // verify the required parameter 'property_relation_value_id' is set
        if ($property_relation_value_id === null || (is_array($property_relation_value_id) && count($property_relation_value_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_relation_value_id when calling restPropertiesRelationsValuesPropertiesRelationValueIdDelete'
            );
        }
        // verify the required parameter 'properties_relation_value_id' is set
        if ($properties_relation_value_id === null || (is_array($properties_relation_value_id) && count($properties_relation_value_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $properties_relation_value_id when calling restPropertiesRelationsValuesPropertiesRelationValueIdDelete'
            );
        }

        $resourcePath = '/rest/properties/relations/values/{propertiesRelationValueId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($property_relation_value_id)) {
            $property_relation_value_id = ObjectSerializer::serializeCollection($property_relation_value_id, '', true);
        }
        if ($property_relation_value_id !== null) {
            $queryParams['propertyRelationValueId'] = $property_relation_value_id;
        }


        // path params
        if ($properties_relation_value_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertiesRelationValueId' . '}',
                ObjectSerializer::toPathValue($properties_relation_value_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsValuesPropertiesRelationValueIdPut
     *
     * Update a property relation value
     *
     * @param  int $property_relation_value_id The ID of the property relation value (required)
     * @param  int $properties_relation_value_id properties_relation_value_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyRelationValue
     */
    public function restPropertiesRelationsValuesPropertiesRelationValueIdPut($property_relation_value_id, $properties_relation_value_id)
    {
        list($response) = $this->restPropertiesRelationsValuesPropertiesRelationValueIdPutWithHttpInfo($property_relation_value_id, $properties_relation_value_id);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsValuesPropertiesRelationValueIdPutWithHttpInfo
     *
     * Update a property relation value
     *
     * @param  int $property_relation_value_id The ID of the property relation value (required)
     * @param  int $properties_relation_value_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyRelationValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsValuesPropertiesRelationValueIdPutWithHttpInfo($property_relation_value_id, $properties_relation_value_id)
    {
        $request = $this->restPropertiesRelationsValuesPropertiesRelationValueIdPutRequest($property_relation_value_id, $properties_relation_value_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyRelationValue' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyRelationValue', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyRelationValue';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyRelationValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsValuesPropertiesRelationValueIdPutAsync
     *
     * Update a property relation value
     *
     * @param  int $property_relation_value_id The ID of the property relation value (required)
     * @param  int $properties_relation_value_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsValuesPropertiesRelationValueIdPutAsync($property_relation_value_id, $properties_relation_value_id)
    {
        return $this->restPropertiesRelationsValuesPropertiesRelationValueIdPutAsyncWithHttpInfo($property_relation_value_id, $properties_relation_value_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsValuesPropertiesRelationValueIdPutAsyncWithHttpInfo
     *
     * Update a property relation value
     *
     * @param  int $property_relation_value_id The ID of the property relation value (required)
     * @param  int $properties_relation_value_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsValuesPropertiesRelationValueIdPutAsyncWithHttpInfo($property_relation_value_id, $properties_relation_value_id)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyRelationValue';
        $request = $this->restPropertiesRelationsValuesPropertiesRelationValueIdPutRequest($property_relation_value_id, $properties_relation_value_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsValuesPropertiesRelationValueIdPut'
     *
     * @param  int $property_relation_value_id The ID of the property relation value (required)
     * @param  int $properties_relation_value_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesRelationsValuesPropertiesRelationValueIdPutRequest($property_relation_value_id, $properties_relation_value_id)
    {
        // verify the required parameter 'property_relation_value_id' is set
        if ($property_relation_value_id === null || (is_array($property_relation_value_id) && count($property_relation_value_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_relation_value_id when calling restPropertiesRelationsValuesPropertiesRelationValueIdPut'
            );
        }
        // verify the required parameter 'properties_relation_value_id' is set
        if ($properties_relation_value_id === null || (is_array($properties_relation_value_id) && count($properties_relation_value_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $properties_relation_value_id when calling restPropertiesRelationsValuesPropertiesRelationValueIdPut'
            );
        }

        $resourcePath = '/rest/properties/relations/values/{propertiesRelationValueId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($property_relation_value_id)) {
            $property_relation_value_id = ObjectSerializer::serializeCollection($property_relation_value_id, '', true);
        }
        if ($property_relation_value_id !== null) {
            $queryParams['$propertyRelationValueId'] = $property_relation_value_id;
        }


        // path params
        if ($properties_relation_value_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertiesRelationValueId' . '}',
                ObjectSerializer::toPathValue($properties_relation_value_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsValuesPut
     *
     * Update multiple property relation value
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyRelationValue
     */
    public function restPropertiesRelationsValuesPut()
    {
        list($response) = $this->restPropertiesRelationsValuesPutWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPropertiesRelationsValuesPutWithHttpInfo
     *
     * Update multiple property relation value
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyRelationValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsValuesPutWithHttpInfo()
    {
        $request = $this->restPropertiesRelationsValuesPutRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyRelationValue' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyRelationValue', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyRelationValue';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyRelationValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsValuesPutAsync
     *
     * Update multiple property relation value
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsValuesPutAsync()
    {
        return $this->restPropertiesRelationsValuesPutAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsValuesPutAsyncWithHttpInfo
     *
     * Update multiple property relation value
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsValuesPutAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\PropertyRelationValue';
        $request = $this->restPropertiesRelationsValuesPutRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsValuesPut'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesRelationsValuesPutRequest()
    {

        $resourcePath = '/rest/properties/relations/values';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsValuesRelationMarkupIdGet
     *
     * Get a property relation value
     *
     * @param  int $property_relation_id The ID of the property relation (required)
     * @param  int $relation_markup_id relation_markup_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyRelationValue
     */
    public function restPropertiesRelationsValuesRelationMarkupIdGet($property_relation_id, $relation_markup_id)
    {
        list($response) = $this->restPropertiesRelationsValuesRelationMarkupIdGetWithHttpInfo($property_relation_id, $relation_markup_id);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsValuesRelationMarkupIdGetWithHttpInfo
     *
     * Get a property relation value
     *
     * @param  int $property_relation_id The ID of the property relation (required)
     * @param  int $relation_markup_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyRelationValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsValuesRelationMarkupIdGetWithHttpInfo($property_relation_id, $relation_markup_id)
    {
        $request = $this->restPropertiesRelationsValuesRelationMarkupIdGetRequest($property_relation_id, $relation_markup_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyRelationValue' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyRelationValue', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyRelationValue';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyRelationValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsValuesRelationMarkupIdGetAsync
     *
     * Get a property relation value
     *
     * @param  int $property_relation_id The ID of the property relation (required)
     * @param  int $relation_markup_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsValuesRelationMarkupIdGetAsync($property_relation_id, $relation_markup_id)
    {
        return $this->restPropertiesRelationsValuesRelationMarkupIdGetAsyncWithHttpInfo($property_relation_id, $relation_markup_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsValuesRelationMarkupIdGetAsyncWithHttpInfo
     *
     * Get a property relation value
     *
     * @param  int $property_relation_id The ID of the property relation (required)
     * @param  int $relation_markup_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesRelationsValuesRelationMarkupIdGetAsyncWithHttpInfo($property_relation_id, $relation_markup_id)
    {
        $returnType = '\OpenAPI\Client\Model\PropertyRelationValue';
        $request = $this->restPropertiesRelationsValuesRelationMarkupIdGetRequest($property_relation_id, $relation_markup_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsValuesRelationMarkupIdGet'
     *
     * @param  int $property_relation_id The ID of the property relation (required)
     * @param  int $relation_markup_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesRelationsValuesRelationMarkupIdGetRequest($property_relation_id, $relation_markup_id)
    {
        // verify the required parameter 'property_relation_id' is set
        if ($property_relation_id === null || (is_array($property_relation_id) && count($property_relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_relation_id when calling restPropertiesRelationsValuesRelationMarkupIdGet'
            );
        }
        // verify the required parameter 'relation_markup_id' is set
        if ($relation_markup_id === null || (is_array($relation_markup_id) && count($relation_markup_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relation_markup_id when calling restPropertiesRelationsValuesRelationMarkupIdGet'
            );
        }

        $resourcePath = '/rest/properties/relations/values/{relationMarkupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($property_relation_id)) {
            $property_relation_id = ObjectSerializer::serializeCollection($property_relation_id, '', true);
        }
        if ($property_relation_id !== null) {
            $queryParams['propertyRelationId'] = $property_relation_id;
        }


        // path params
        if ($relation_markup_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationMarkupId' . '}',
                ObjectSerializer::toPathValue($relation_markup_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesSelectionsGet
     *
     * List property selections
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertySelection[]
     */
    public function restPropertiesSelectionsGet()
    {
        list($response) = $this->restPropertiesSelectionsGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPropertiesSelectionsGetWithHttpInfo
     *
     * List property selections
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertySelection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesSelectionsGetWithHttpInfo()
    {
        $request = $this->restPropertiesSelectionsGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertySelection[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertySelection[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertySelection[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertySelection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesSelectionsGetAsync
     *
     * List property selections
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesSelectionsGetAsync()
    {
        return $this->restPropertiesSelectionsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesSelectionsGetAsyncWithHttpInfo
     *
     * List property selections
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesSelectionsGetAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\PropertySelection[]';
        $request = $this->restPropertiesSelectionsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesSelectionsGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesSelectionsGetRequest()
    {

        $resourcePath = '/rest/properties/selections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesSelectionsPost
     *
     * Create a property selection
     *
     * @param  int $property_id The ID of the property (required)
     * @param  int $position The position of the property selection (required)
     * @param  \OpenAPI\Client\Model\InlineObject226 $_rest_properties_selections _rest_properties_selections (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertySelection
     */
    public function restPropertiesSelectionsPost($property_id, $position, $_rest_properties_selections = null)
    {
        list($response) = $this->restPropertiesSelectionsPostWithHttpInfo($property_id, $position, $_rest_properties_selections);
        return $response;
    }

    /**
     * Operation restPropertiesSelectionsPostWithHttpInfo
     *
     * Create a property selection
     *
     * @param  int $property_id The ID of the property (required)
     * @param  int $position The position of the property selection (required)
     * @param  \OpenAPI\Client\Model\InlineObject226 $_rest_properties_selections (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertySelection, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesSelectionsPostWithHttpInfo($property_id, $position, $_rest_properties_selections = null)
    {
        $request = $this->restPropertiesSelectionsPostRequest($property_id, $position, $_rest_properties_selections);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertySelection' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertySelection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertySelection';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertySelection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesSelectionsPostAsync
     *
     * Create a property selection
     *
     * @param  int $property_id The ID of the property (required)
     * @param  int $position The position of the property selection (required)
     * @param  \OpenAPI\Client\Model\InlineObject226 $_rest_properties_selections (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesSelectionsPostAsync($property_id, $position, $_rest_properties_selections = null)
    {
        return $this->restPropertiesSelectionsPostAsyncWithHttpInfo($property_id, $position, $_rest_properties_selections)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesSelectionsPostAsyncWithHttpInfo
     *
     * Create a property selection
     *
     * @param  int $property_id The ID of the property (required)
     * @param  int $position The position of the property selection (required)
     * @param  \OpenAPI\Client\Model\InlineObject226 $_rest_properties_selections (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesSelectionsPostAsyncWithHttpInfo($property_id, $position, $_rest_properties_selections = null)
    {
        $returnType = '\OpenAPI\Client\Model\PropertySelection';
        $request = $this->restPropertiesSelectionsPostRequest($property_id, $position, $_rest_properties_selections);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesSelectionsPost'
     *
     * @param  int $property_id The ID of the property (required)
     * @param  int $position The position of the property selection (required)
     * @param  \OpenAPI\Client\Model\InlineObject226 $_rest_properties_selections (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesSelectionsPostRequest($property_id, $position, $_rest_properties_selections = null)
    {
        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesSelectionsPost'
            );
        }
        // verify the required parameter 'position' is set
        if ($position === null || (is_array($position) && count($position) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $position when calling restPropertiesSelectionsPost'
            );
        }

        $resourcePath = '/rest/properties/selections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($property_id)) {
            $property_id = ObjectSerializer::serializeCollection($property_id, '', true);
        }
        if ($property_id !== null) {
            $queryParams['propertyId'] = $property_id;
        }
        // query params
        if (is_array($position)) {
            $position = ObjectSerializer::serializeCollection($position, '', true);
        }
        if ($position !== null) {
            $queryParams['position'] = $position;
        }



        // body params
        $_tempBody = null;
        if (isset($_rest_properties_selections)) {
            $_tempBody = $_rest_properties_selections;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesSelectionsPropertySelectionIdDelete
     *
     * Delete a property selection
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restPropertiesSelectionsPropertySelectionIdDelete($property_selection_id)
    {
        $this->restPropertiesSelectionsPropertySelectionIdDeleteWithHttpInfo($property_selection_id);
    }

    /**
     * Operation restPropertiesSelectionsPropertySelectionIdDeleteWithHttpInfo
     *
     * Delete a property selection
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesSelectionsPropertySelectionIdDeleteWithHttpInfo($property_selection_id)
    {
        $request = $this->restPropertiesSelectionsPropertySelectionIdDeleteRequest($property_selection_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesSelectionsPropertySelectionIdDeleteAsync
     *
     * Delete a property selection
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesSelectionsPropertySelectionIdDeleteAsync($property_selection_id)
    {
        return $this->restPropertiesSelectionsPropertySelectionIdDeleteAsyncWithHttpInfo($property_selection_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesSelectionsPropertySelectionIdDeleteAsyncWithHttpInfo
     *
     * Delete a property selection
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesSelectionsPropertySelectionIdDeleteAsyncWithHttpInfo($property_selection_id)
    {
        $returnType = '';
        $request = $this->restPropertiesSelectionsPropertySelectionIdDeleteRequest($property_selection_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesSelectionsPropertySelectionIdDelete'
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesSelectionsPropertySelectionIdDeleteRequest($property_selection_id)
    {
        // verify the required parameter 'property_selection_id' is set
        if ($property_selection_id === null || (is_array($property_selection_id) && count($property_selection_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_selection_id when calling restPropertiesSelectionsPropertySelectionIdDelete'
            );
        }

        $resourcePath = '/rest/properties/selections/{propertySelectionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_selection_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertySelectionId' . '}',
                ObjectSerializer::toPathValue($property_selection_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesSelectionsPropertySelectionIdGet
     *
     * Get a property selection
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertySelection
     */
    public function restPropertiesSelectionsPropertySelectionIdGet($property_selection_id)
    {
        list($response) = $this->restPropertiesSelectionsPropertySelectionIdGetWithHttpInfo($property_selection_id);
        return $response;
    }

    /**
     * Operation restPropertiesSelectionsPropertySelectionIdGetWithHttpInfo
     *
     * Get a property selection
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertySelection, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesSelectionsPropertySelectionIdGetWithHttpInfo($property_selection_id)
    {
        $request = $this->restPropertiesSelectionsPropertySelectionIdGetRequest($property_selection_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertySelection' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertySelection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertySelection';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertySelection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesSelectionsPropertySelectionIdGetAsync
     *
     * Get a property selection
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesSelectionsPropertySelectionIdGetAsync($property_selection_id)
    {
        return $this->restPropertiesSelectionsPropertySelectionIdGetAsyncWithHttpInfo($property_selection_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesSelectionsPropertySelectionIdGetAsyncWithHttpInfo
     *
     * Get a property selection
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesSelectionsPropertySelectionIdGetAsyncWithHttpInfo($property_selection_id)
    {
        $returnType = '\OpenAPI\Client\Model\PropertySelection';
        $request = $this->restPropertiesSelectionsPropertySelectionIdGetRequest($property_selection_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesSelectionsPropertySelectionIdGet'
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesSelectionsPropertySelectionIdGetRequest($property_selection_id)
    {
        // verify the required parameter 'property_selection_id' is set
        if ($property_selection_id === null || (is_array($property_selection_id) && count($property_selection_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_selection_id when calling restPropertiesSelectionsPropertySelectionIdGet'
            );
        }

        $resourcePath = '/rest/properties/selections/{propertySelectionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_selection_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertySelectionId' . '}',
                ObjectSerializer::toPathValue($property_selection_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesSelectionsPropertySelectionIdPut
     *
     * Update a property selection
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     * @param  int $property_selection_id2 property_selection_id2 (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertySelection
     */
    public function restPropertiesSelectionsPropertySelectionIdPut($property_selection_id, $property_selection_id2)
    {
        list($response) = $this->restPropertiesSelectionsPropertySelectionIdPutWithHttpInfo($property_selection_id, $property_selection_id2);
        return $response;
    }

    /**
     * Operation restPropertiesSelectionsPropertySelectionIdPutWithHttpInfo
     *
     * Update a property selection
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     * @param  int $property_selection_id2 (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertySelection, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesSelectionsPropertySelectionIdPutWithHttpInfo($property_selection_id, $property_selection_id2)
    {
        $request = $this->restPropertiesSelectionsPropertySelectionIdPutRequest($property_selection_id, $property_selection_id2);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertySelection' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertySelection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertySelection';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertySelection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesSelectionsPropertySelectionIdPutAsync
     *
     * Update a property selection
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     * @param  int $property_selection_id2 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesSelectionsPropertySelectionIdPutAsync($property_selection_id, $property_selection_id2)
    {
        return $this->restPropertiesSelectionsPropertySelectionIdPutAsyncWithHttpInfo($property_selection_id, $property_selection_id2)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesSelectionsPropertySelectionIdPutAsyncWithHttpInfo
     *
     * Update a property selection
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     * @param  int $property_selection_id2 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesSelectionsPropertySelectionIdPutAsyncWithHttpInfo($property_selection_id, $property_selection_id2)
    {
        $returnType = '\OpenAPI\Client\Model\PropertySelection';
        $request = $this->restPropertiesSelectionsPropertySelectionIdPutRequest($property_selection_id, $property_selection_id2);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesSelectionsPropertySelectionIdPut'
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     * @param  int $property_selection_id2 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesSelectionsPropertySelectionIdPutRequest($property_selection_id, $property_selection_id2)
    {
        // verify the required parameter 'property_selection_id' is set
        if ($property_selection_id === null || (is_array($property_selection_id) && count($property_selection_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_selection_id when calling restPropertiesSelectionsPropertySelectionIdPut'
            );
        }
        // verify the required parameter 'property_selection_id2' is set
        if ($property_selection_id2 === null || (is_array($property_selection_id2) && count($property_selection_id2) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_selection_id2 when calling restPropertiesSelectionsPropertySelectionIdPut'
            );
        }

        $resourcePath = '/rest/properties/selections/{propertySelectionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($property_selection_id)) {
            $property_selection_id = ObjectSerializer::serializeCollection($property_selection_id, '', true);
        }
        if ($property_selection_id !== null) {
            $queryParams['$propertySelectionId'] = $property_selection_id;
        }


        // path params
        if ($property_selection_id2 !== null) {
            $resourcePath = str_replace(
                '{' . 'propertySelectionId' . '}',
                ObjectSerializer::toPathValue($property_selection_id2),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesSystemlangGet
     *
     * Get system language
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restPropertiesSystemlangGet()
    {
        list($response) = $this->restPropertiesSystemlangGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restPropertiesSystemlangGetWithHttpInfo
     *
     * Get system language
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesSystemlangGetWithHttpInfo()
    {
        $request = $this->restPropertiesSystemlangGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesSystemlangGetAsync
     *
     * Get system language
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesSystemlangGetAsync()
    {
        return $this->restPropertiesSystemlangGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesSystemlangGetAsyncWithHttpInfo
     *
     * Get system language
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restPropertiesSystemlangGetAsyncWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->restPropertiesSystemlangGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesSystemlangGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restPropertiesSystemlangGetRequest()
    {

        $resourcePath = '/rest/properties/systemlang';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
