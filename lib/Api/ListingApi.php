<?php
/**
 * ListingApi
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0-beta2
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * ListingApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ListingApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation restListingsGet
     *
     * List listing
     *
     * @param  int $id Filter that restricts the search result to listings with specific listing ID. Several IDs can be entered as array. (optional)
     * @param  int $item_id Filter that restricts the search result to listings with specific item ID. Several IDs can be entered as array. (optional)
     * @param  int $type_id Filter that restricts the search result to listings with specific type ID. Several IDs can be entered as array. (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listings with specific stock dependence type ID. Several IDs can be entered as array. (optional)
     * @param  int $unit_combination_id Filter that restricts the search result to listings with specific unit combination ID. Several IDs can be entered as array. (optional)
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $with An array with child instances to be loaded. One of &#39;stockDependenceType&#39;, &#39;type&#39;, &#39;markets&#39;, &#39;properties&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20024
     */
    public function restListingsGet($id = null, $item_id = null, $type_id = null, $stock_dependence_type_id = null, $unit_combination_id = null, $page = null, $items_per_page = null, $with = null)
    {
        list($response) = $this->restListingsGetWithHttpInfo($id, $item_id, $type_id, $stock_dependence_type_id, $unit_combination_id, $page, $items_per_page, $with);
        return $response;
    }

    /**
     * Operation restListingsGetWithHttpInfo
     *
     * List listing
     *
     * @param  int $id Filter that restricts the search result to listings with specific listing ID. Several IDs can be entered as array. (optional)
     * @param  int $item_id Filter that restricts the search result to listings with specific item ID. Several IDs can be entered as array. (optional)
     * @param  int $type_id Filter that restricts the search result to listings with specific type ID. Several IDs can be entered as array. (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listings with specific stock dependence type ID. Several IDs can be entered as array. (optional)
     * @param  int $unit_combination_id Filter that restricts the search result to listings with specific unit combination ID. Several IDs can be entered as array. (optional)
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $with An array with child instances to be loaded. One of &#39;stockDependenceType&#39;, &#39;type&#39;, &#39;markets&#39;, &#39;properties&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20024, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsGetWithHttpInfo($id = null, $item_id = null, $type_id = null, $stock_dependence_type_id = null, $unit_combination_id = null, $page = null, $items_per_page = null, $with = null)
    {
        $request = $this->restListingsGetRequest($id, $item_id, $type_id, $stock_dependence_type_id, $unit_combination_id, $page, $items_per_page, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20024' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20024', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20024';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20024',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsGetAsync
     *
     * List listing
     *
     * @param  int $id Filter that restricts the search result to listings with specific listing ID. Several IDs can be entered as array. (optional)
     * @param  int $item_id Filter that restricts the search result to listings with specific item ID. Several IDs can be entered as array. (optional)
     * @param  int $type_id Filter that restricts the search result to listings with specific type ID. Several IDs can be entered as array. (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listings with specific stock dependence type ID. Several IDs can be entered as array. (optional)
     * @param  int $unit_combination_id Filter that restricts the search result to listings with specific unit combination ID. Several IDs can be entered as array. (optional)
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $with An array with child instances to be loaded. One of &#39;stockDependenceType&#39;, &#39;type&#39;, &#39;markets&#39;, &#39;properties&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsGetAsync($id = null, $item_id = null, $type_id = null, $stock_dependence_type_id = null, $unit_combination_id = null, $page = null, $items_per_page = null, $with = null)
    {
        return $this->restListingsGetAsyncWithHttpInfo($id, $item_id, $type_id, $stock_dependence_type_id, $unit_combination_id, $page, $items_per_page, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsGetAsyncWithHttpInfo
     *
     * List listing
     *
     * @param  int $id Filter that restricts the search result to listings with specific listing ID. Several IDs can be entered as array. (optional)
     * @param  int $item_id Filter that restricts the search result to listings with specific item ID. Several IDs can be entered as array. (optional)
     * @param  int $type_id Filter that restricts the search result to listings with specific type ID. Several IDs can be entered as array. (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listings with specific stock dependence type ID. Several IDs can be entered as array. (optional)
     * @param  int $unit_combination_id Filter that restricts the search result to listings with specific unit combination ID. Several IDs can be entered as array. (optional)
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $with An array with child instances to be loaded. One of &#39;stockDependenceType&#39;, &#39;type&#39;, &#39;markets&#39;, &#39;properties&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsGetAsyncWithHttpInfo($id = null, $item_id = null, $type_id = null, $stock_dependence_type_id = null, $unit_combination_id = null, $page = null, $items_per_page = null, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20024';
        $request = $this->restListingsGetRequest($id, $item_id, $type_id, $stock_dependence_type_id, $unit_combination_id, $page, $items_per_page, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsGet'
     *
     * @param  int $id Filter that restricts the search result to listings with specific listing ID. Several IDs can be entered as array. (optional)
     * @param  int $item_id Filter that restricts the search result to listings with specific item ID. Several IDs can be entered as array. (optional)
     * @param  int $type_id Filter that restricts the search result to listings with specific type ID. Several IDs can be entered as array. (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listings with specific stock dependence type ID. Several IDs can be entered as array. (optional)
     * @param  int $unit_combination_id Filter that restricts the search result to listings with specific unit combination ID. Several IDs can be entered as array. (optional)
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $with An array with child instances to be loaded. One of &#39;stockDependenceType&#39;, &#39;type&#39;, &#39;markets&#39;, &#39;properties&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsGetRequest($id = null, $item_id = null, $type_id = null, $stock_dependence_type_id = null, $unit_combination_id = null, $page = null, $items_per_page = null, $with = null)
    {

        $resourcePath = '/rest/listings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($id)) {
            $id = ObjectSerializer::serializeCollection($id, '', true);
        }
        if ($id !== null) {
            $queryParams['id'] = $id;
        }
        // query params
        if (is_array($item_id)) {
            $item_id = ObjectSerializer::serializeCollection($item_id, '', true);
        }
        if ($item_id !== null) {
            $queryParams['itemId'] = $item_id;
        }
        // query params
        if (is_array($type_id)) {
            $type_id = ObjectSerializer::serializeCollection($type_id, '', true);
        }
        if ($type_id !== null) {
            $queryParams['typeId'] = $type_id;
        }
        // query params
        if (is_array($stock_dependence_type_id)) {
            $stock_dependence_type_id = ObjectSerializer::serializeCollection($stock_dependence_type_id, '', true);
        }
        if ($stock_dependence_type_id !== null) {
            $queryParams['stockDependenceTypeId'] = $stock_dependence_type_id;
        }
        // query params
        if (is_array($unit_combination_id)) {
            $unit_combination_id = ObjectSerializer::serializeCollection($unit_combination_id, '', true);
        }
        if ($unit_combination_id !== null) {
            $queryParams['unitCombinationId'] = $unit_combination_id;
        }
        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsIdDelete
     *
     * Delete a listing
     *
     * @param  int $id The listing ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restListingsIdDelete($id)
    {
        list($response) = $this->restListingsIdDeleteWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restListingsIdDeleteWithHttpInfo
     *
     * Delete a listing
     *
     * @param  int $id The listing ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsIdDeleteWithHttpInfo($id)
    {
        $request = $this->restListingsIdDeleteRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsIdDeleteAsync
     *
     * Delete a listing
     *
     * @param  int $id The listing ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsIdDeleteAsync($id)
    {
        return $this->restListingsIdDeleteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsIdDeleteAsyncWithHttpInfo
     *
     * Delete a listing
     *
     * @param  int $id The listing ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsIdDeleteAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->restListingsIdDeleteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsIdDelete'
     *
     * @param  int $id The listing ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsIdDeleteRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsIdDelete'
            );
        }

        $resourcePath = '/rest/listings/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsIdGet
     *
     * Get a listing
     *
     * @param  int $id The ID of the listing entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#39;stockDependenceType&#39;, &#39;type&#39;, &#39;markets&#39;, &#39;properties&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Listing
     */
    public function restListingsIdGet($id, $with = null)
    {
        list($response) = $this->restListingsIdGetWithHttpInfo($id, $with);
        return $response;
    }

    /**
     * Operation restListingsIdGetWithHttpInfo
     *
     * Get a listing
     *
     * @param  int $id The ID of the listing entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#39;stockDependenceType&#39;, &#39;type&#39;, &#39;markets&#39;, &#39;properties&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Listing, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsIdGetWithHttpInfo($id, $with = null)
    {
        $request = $this->restListingsIdGetRequest($id, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Listing' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Listing', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Listing';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Listing',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsIdGetAsync
     *
     * Get a listing
     *
     * @param  int $id The ID of the listing entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#39;stockDependenceType&#39;, &#39;type&#39;, &#39;markets&#39;, &#39;properties&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsIdGetAsync($id, $with = null)
    {
        return $this->restListingsIdGetAsyncWithHttpInfo($id, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsIdGetAsyncWithHttpInfo
     *
     * Get a listing
     *
     * @param  int $id The ID of the listing entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#39;stockDependenceType&#39;, &#39;type&#39;, &#39;markets&#39;, &#39;properties&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsIdGetAsyncWithHttpInfo($id, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\Listing';
        $request = $this->restListingsIdGetRequest($id, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsIdGet'
     *
     * @param  int $id The ID of the listing entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#39;stockDependenceType&#39;, &#39;type&#39;, &#39;markets&#39;, &#39;properties&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsIdGetRequest($id, $with = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsIdGet'
            );
        }

        $resourcePath = '/rest/listings/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsIdPut
     *
     * Update a listing
     *
     * @param  int $id The ID of the listing. (required)
     * @param  \OpenAPI\Client\Model\InlineObject153 $_rest_listings_id _rest_listings_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Listing
     */
    public function restListingsIdPut($id, $_rest_listings_id = null)
    {
        list($response) = $this->restListingsIdPutWithHttpInfo($id, $_rest_listings_id);
        return $response;
    }

    /**
     * Operation restListingsIdPutWithHttpInfo
     *
     * Update a listing
     *
     * @param  int $id The ID of the listing. (required)
     * @param  \OpenAPI\Client\Model\InlineObject153 $_rest_listings_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Listing, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsIdPutWithHttpInfo($id, $_rest_listings_id = null)
    {
        $request = $this->restListingsIdPutRequest($id, $_rest_listings_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Listing' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Listing', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Listing';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Listing',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsIdPutAsync
     *
     * Update a listing
     *
     * @param  int $id The ID of the listing. (required)
     * @param  \OpenAPI\Client\Model\InlineObject153 $_rest_listings_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsIdPutAsync($id, $_rest_listings_id = null)
    {
        return $this->restListingsIdPutAsyncWithHttpInfo($id, $_rest_listings_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsIdPutAsyncWithHttpInfo
     *
     * Update a listing
     *
     * @param  int $id The ID of the listing. (required)
     * @param  \OpenAPI\Client\Model\InlineObject153 $_rest_listings_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsIdPutAsyncWithHttpInfo($id, $_rest_listings_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\Listing';
        $request = $this->restListingsIdPutRequest($id, $_rest_listings_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsIdPut'
     *
     * @param  int $id The ID of the listing. (required)
     * @param  \OpenAPI\Client\Model\InlineObject153 $_rest_listings_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsIdPutRequest($id, $_rest_listings_id = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsIdPut'
            );
        }

        $resourcePath = '/rest/listings/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_listings_id)) {
            $_tempBody = $_rest_listings_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsLayoutTemplatesIdDelete
     *
     * Delete a layout template
     *
     * @param  int $id The layout template ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restListingsLayoutTemplatesIdDelete($id)
    {
        list($response) = $this->restListingsLayoutTemplatesIdDeleteWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restListingsLayoutTemplatesIdDeleteWithHttpInfo
     *
     * Delete a layout template
     *
     * @param  int $id The layout template ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsLayoutTemplatesIdDeleteWithHttpInfo($id)
    {
        $request = $this->restListingsLayoutTemplatesIdDeleteRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsLayoutTemplatesIdDeleteAsync
     *
     * Delete a layout template
     *
     * @param  int $id The layout template ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsLayoutTemplatesIdDeleteAsync($id)
    {
        return $this->restListingsLayoutTemplatesIdDeleteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsLayoutTemplatesIdDeleteAsyncWithHttpInfo
     *
     * Delete a layout template
     *
     * @param  int $id The layout template ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsLayoutTemplatesIdDeleteAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->restListingsLayoutTemplatesIdDeleteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsLayoutTemplatesIdDelete'
     *
     * @param  int $id The layout template ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsLayoutTemplatesIdDeleteRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsLayoutTemplatesIdDelete'
            );
        }

        $resourcePath = '/rest/listings/layout_templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsLayoutTemplatesIdGet
     *
     * Get a layout template
     *
     * @param  int $id The ID of the layout template entry. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LayoutTemplate
     */
    public function restListingsLayoutTemplatesIdGet($id)
    {
        list($response) = $this->restListingsLayoutTemplatesIdGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restListingsLayoutTemplatesIdGetWithHttpInfo
     *
     * Get a layout template
     *
     * @param  int $id The ID of the layout template entry. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LayoutTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsLayoutTemplatesIdGetWithHttpInfo($id)
    {
        $request = $this->restListingsLayoutTemplatesIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\LayoutTemplate' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\LayoutTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\LayoutTemplate';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LayoutTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsLayoutTemplatesIdGetAsync
     *
     * Get a layout template
     *
     * @param  int $id The ID of the layout template entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsLayoutTemplatesIdGetAsync($id)
    {
        return $this->restListingsLayoutTemplatesIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsLayoutTemplatesIdGetAsyncWithHttpInfo
     *
     * Get a layout template
     *
     * @param  int $id The ID of the layout template entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsLayoutTemplatesIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\OpenAPI\Client\Model\LayoutTemplate';
        $request = $this->restListingsLayoutTemplatesIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsLayoutTemplatesIdGet'
     *
     * @param  int $id The ID of the layout template entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsLayoutTemplatesIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsLayoutTemplatesIdGet'
            );
        }

        $resourcePath = '/rest/listings/layout_templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsLayoutTemplatesPost
     *
     * Create new layout template
     *
     * @param  \OpenAPI\Client\Model\InlineObject141 $_rest_listings_layout_templates _rest_listings_layout_templates (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LayoutTemplate
     */
    public function restListingsLayoutTemplatesPost($_rest_listings_layout_templates = null)
    {
        list($response) = $this->restListingsLayoutTemplatesPostWithHttpInfo($_rest_listings_layout_templates);
        return $response;
    }

    /**
     * Operation restListingsLayoutTemplatesPostWithHttpInfo
     *
     * Create new layout template
     *
     * @param  \OpenAPI\Client\Model\InlineObject141 $_rest_listings_layout_templates (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LayoutTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsLayoutTemplatesPostWithHttpInfo($_rest_listings_layout_templates = null)
    {
        $request = $this->restListingsLayoutTemplatesPostRequest($_rest_listings_layout_templates);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\LayoutTemplate' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\LayoutTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\LayoutTemplate';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LayoutTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsLayoutTemplatesPostAsync
     *
     * Create new layout template
     *
     * @param  \OpenAPI\Client\Model\InlineObject141 $_rest_listings_layout_templates (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsLayoutTemplatesPostAsync($_rest_listings_layout_templates = null)
    {
        return $this->restListingsLayoutTemplatesPostAsyncWithHttpInfo($_rest_listings_layout_templates)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsLayoutTemplatesPostAsyncWithHttpInfo
     *
     * Create new layout template
     *
     * @param  \OpenAPI\Client\Model\InlineObject141 $_rest_listings_layout_templates (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsLayoutTemplatesPostAsyncWithHttpInfo($_rest_listings_layout_templates = null)
    {
        $returnType = '\OpenAPI\Client\Model\LayoutTemplate';
        $request = $this->restListingsLayoutTemplatesPostRequest($_rest_listings_layout_templates);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsLayoutTemplatesPost'
     *
     * @param  \OpenAPI\Client\Model\InlineObject141 $_rest_listings_layout_templates (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsLayoutTemplatesPostRequest($_rest_listings_layout_templates = null)
    {

        $resourcePath = '/rest/listings/layout_templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_listings_layout_templates)) {
            $_tempBody = $_rest_listings_layout_templates;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsDirectoriesGet
     *
     * Get all listing market directories
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListingMarketDirectory[]
     */
    public function restListingsMarketsDirectoriesGet()
    {
        list($response) = $this->restListingsMarketsDirectoriesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restListingsMarketsDirectoriesGetWithHttpInfo
     *
     * Get all listing market directories
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListingMarketDirectory[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsDirectoriesGetWithHttpInfo()
    {
        $request = $this->restListingsMarketsDirectoriesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListingMarketDirectory[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListingMarketDirectory[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ListingMarketDirectory[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListingMarketDirectory[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsDirectoriesGetAsync
     *
     * Get all listing market directories
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsDirectoriesGetAsync()
    {
        return $this->restListingsMarketsDirectoriesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsDirectoriesGetAsyncWithHttpInfo
     *
     * Get all listing market directories
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsDirectoriesGetAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\ListingMarketDirectory[]';
        $request = $this->restListingsMarketsDirectoriesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsDirectoriesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsDirectoriesGetRequest()
    {

        $resourcePath = '/rest/listings/markets/directories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsDirectoriesIdDelete
     *
     * Delete listing market directory
     *
     * @param  int $id The listing market directory ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restListingsMarketsDirectoriesIdDelete($id)
    {
        list($response) = $this->restListingsMarketsDirectoriesIdDeleteWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restListingsMarketsDirectoriesIdDeleteWithHttpInfo
     *
     * Delete listing market directory
     *
     * @param  int $id The listing market directory ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsDirectoriesIdDeleteWithHttpInfo($id)
    {
        $request = $this->restListingsMarketsDirectoriesIdDeleteRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsDirectoriesIdDeleteAsync
     *
     * Delete listing market directory
     *
     * @param  int $id The listing market directory ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsDirectoriesIdDeleteAsync($id)
    {
        return $this->restListingsMarketsDirectoriesIdDeleteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsDirectoriesIdDeleteAsyncWithHttpInfo
     *
     * Delete listing market directory
     *
     * @param  int $id The listing market directory ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsDirectoriesIdDeleteAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->restListingsMarketsDirectoriesIdDeleteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsDirectoriesIdDelete'
     *
     * @param  int $id The listing market directory ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsDirectoriesIdDeleteRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsDirectoriesIdDelete'
            );
        }

        $resourcePath = '/rest/listings/markets/directories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsDirectoriesIdGet
     *
     * Get a listing market directory
     *
     * @param  int $id The ID of the listing market directory entry. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListingMarketDirectory
     */
    public function restListingsMarketsDirectoriesIdGet($id)
    {
        list($response) = $this->restListingsMarketsDirectoriesIdGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restListingsMarketsDirectoriesIdGetWithHttpInfo
     *
     * Get a listing market directory
     *
     * @param  int $id The ID of the listing market directory entry. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListingMarketDirectory, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsDirectoriesIdGetWithHttpInfo($id)
    {
        $request = $this->restListingsMarketsDirectoriesIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListingMarketDirectory' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListingMarketDirectory', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ListingMarketDirectory';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListingMarketDirectory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsDirectoriesIdGetAsync
     *
     * Get a listing market directory
     *
     * @param  int $id The ID of the listing market directory entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsDirectoriesIdGetAsync($id)
    {
        return $this->restListingsMarketsDirectoriesIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsDirectoriesIdGetAsyncWithHttpInfo
     *
     * Get a listing market directory
     *
     * @param  int $id The ID of the listing market directory entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsDirectoriesIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\OpenAPI\Client\Model\ListingMarketDirectory';
        $request = $this->restListingsMarketsDirectoriesIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsDirectoriesIdGet'
     *
     * @param  int $id The ID of the listing market directory entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsDirectoriesIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsDirectoriesIdGet'
            );
        }

        $resourcePath = '/rest/listings/markets/directories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsDirectoriesIdPut
     *
     * Update listing market directory
     *
     * @param  int $id The listing market directory ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject144 $_rest_listings_markets_directories_id _rest_listings_markets_directories_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListingMarketDirectory
     */
    public function restListingsMarketsDirectoriesIdPut($id, $_rest_listings_markets_directories_id = null)
    {
        list($response) = $this->restListingsMarketsDirectoriesIdPutWithHttpInfo($id, $_rest_listings_markets_directories_id);
        return $response;
    }

    /**
     * Operation restListingsMarketsDirectoriesIdPutWithHttpInfo
     *
     * Update listing market directory
     *
     * @param  int $id The listing market directory ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject144 $_rest_listings_markets_directories_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListingMarketDirectory, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsDirectoriesIdPutWithHttpInfo($id, $_rest_listings_markets_directories_id = null)
    {
        $request = $this->restListingsMarketsDirectoriesIdPutRequest($id, $_rest_listings_markets_directories_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListingMarketDirectory' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListingMarketDirectory', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ListingMarketDirectory';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListingMarketDirectory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsDirectoriesIdPutAsync
     *
     * Update listing market directory
     *
     * @param  int $id The listing market directory ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject144 $_rest_listings_markets_directories_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsDirectoriesIdPutAsync($id, $_rest_listings_markets_directories_id = null)
    {
        return $this->restListingsMarketsDirectoriesIdPutAsyncWithHttpInfo($id, $_rest_listings_markets_directories_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsDirectoriesIdPutAsyncWithHttpInfo
     *
     * Update listing market directory
     *
     * @param  int $id The listing market directory ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject144 $_rest_listings_markets_directories_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsDirectoriesIdPutAsyncWithHttpInfo($id, $_rest_listings_markets_directories_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\ListingMarketDirectory';
        $request = $this->restListingsMarketsDirectoriesIdPutRequest($id, $_rest_listings_markets_directories_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsDirectoriesIdPut'
     *
     * @param  int $id The listing market directory ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject144 $_rest_listings_markets_directories_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsDirectoriesIdPutRequest($id, $_rest_listings_markets_directories_id = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsDirectoriesIdPut'
            );
        }

        $resourcePath = '/rest/listings/markets/directories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_listings_markets_directories_id)) {
            $_tempBody = $_rest_listings_markets_directories_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsDirectoriesPost
     *
     * Create listing market directory
     *
     * @param  \OpenAPI\Client\Model\InlineObject143 $_rest_listings_markets_directories _rest_listings_markets_directories (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListingMarketDirectory
     */
    public function restListingsMarketsDirectoriesPost($_rest_listings_markets_directories = null)
    {
        list($response) = $this->restListingsMarketsDirectoriesPostWithHttpInfo($_rest_listings_markets_directories);
        return $response;
    }

    /**
     * Operation restListingsMarketsDirectoriesPostWithHttpInfo
     *
     * Create listing market directory
     *
     * @param  \OpenAPI\Client\Model\InlineObject143 $_rest_listings_markets_directories (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListingMarketDirectory, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsDirectoriesPostWithHttpInfo($_rest_listings_markets_directories = null)
    {
        $request = $this->restListingsMarketsDirectoriesPostRequest($_rest_listings_markets_directories);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListingMarketDirectory' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListingMarketDirectory', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ListingMarketDirectory';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListingMarketDirectory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsDirectoriesPostAsync
     *
     * Create listing market directory
     *
     * @param  \OpenAPI\Client\Model\InlineObject143 $_rest_listings_markets_directories (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsDirectoriesPostAsync($_rest_listings_markets_directories = null)
    {
        return $this->restListingsMarketsDirectoriesPostAsyncWithHttpInfo($_rest_listings_markets_directories)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsDirectoriesPostAsyncWithHttpInfo
     *
     * Create listing market directory
     *
     * @param  \OpenAPI\Client\Model\InlineObject143 $_rest_listings_markets_directories (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsDirectoriesPostAsyncWithHttpInfo($_rest_listings_markets_directories = null)
    {
        $returnType = '\OpenAPI\Client\Model\ListingMarketDirectory';
        $request = $this->restListingsMarketsDirectoriesPostRequest($_rest_listings_markets_directories);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsDirectoriesPost'
     *
     * @param  \OpenAPI\Client\Model\InlineObject143 $_rest_listings_markets_directories (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsDirectoriesPostRequest($_rest_listings_markets_directories = null)
    {

        $resourcePath = '/rest/listings/markets/directories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_listings_markets_directories)) {
            $_tempBody = $_rest_listings_markets_directories;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsFindGet
     *
     * Find listing markets
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20025
     */
    public function restListingsMarketsFindGet($page = null, $items_per_page = null, $id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $item_id = null, $shipping_profile_id = null, $with = null)
    {
        list($response) = $this->restListingsMarketsFindGetWithHttpInfo($page, $items_per_page, $id, $variations, $referrer_id, $credentials_id, $directory_id, $item_id, $shipping_profile_id, $with);
        return $response;
    }

    /**
     * Operation restListingsMarketsFindGetWithHttpInfo
     *
     * Find listing markets
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20025, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsFindGetWithHttpInfo($page = null, $items_per_page = null, $id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $item_id = null, $shipping_profile_id = null, $with = null)
    {
        $request = $this->restListingsMarketsFindGetRequest($page, $items_per_page, $id, $variations, $referrer_id, $credentials_id, $directory_id, $item_id, $shipping_profile_id, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20025' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20025', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20025';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20025',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsFindGetAsync
     *
     * Find listing markets
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsFindGetAsync($page = null, $items_per_page = null, $id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $item_id = null, $shipping_profile_id = null, $with = null)
    {
        return $this->restListingsMarketsFindGetAsyncWithHttpInfo($page, $items_per_page, $id, $variations, $referrer_id, $credentials_id, $directory_id, $item_id, $shipping_profile_id, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsFindGetAsyncWithHttpInfo
     *
     * Find listing markets
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsFindGetAsyncWithHttpInfo($page = null, $items_per_page = null, $id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $item_id = null, $shipping_profile_id = null, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20025';
        $request = $this->restListingsMarketsFindGetRequest($page, $items_per_page, $id, $variations, $referrer_id, $credentials_id, $directory_id, $item_id, $shipping_profile_id, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsFindGet'
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsFindGetRequest($page = null, $items_per_page = null, $id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $item_id = null, $shipping_profile_id = null, $with = null)
    {

        $resourcePath = '/rest/listings/markets/find';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }
        // query params
        if (is_array($id)) {
            $id = ObjectSerializer::serializeCollection($id, '', true);
        }
        if ($id !== null) {
            $queryParams['id'] = $id;
        }
        // query params
        if (is_array($variations)) {
            $variations = ObjectSerializer::serializeCollection($variations, '', true);
        }
        if ($variations !== null) {
            $queryParams['variations'] = $variations;
        }
        // query params
        if (is_array($referrer_id)) {
            $referrer_id = ObjectSerializer::serializeCollection($referrer_id, '', true);
        }
        if ($referrer_id !== null) {
            $queryParams['referrerId'] = $referrer_id;
        }
        // query params
        if (is_array($credentials_id)) {
            $credentials_id = ObjectSerializer::serializeCollection($credentials_id, '', true);
        }
        if ($credentials_id !== null) {
            $queryParams['credentialsId'] = $credentials_id;
        }
        // query params
        if (is_array($directory_id)) {
            $directory_id = ObjectSerializer::serializeCollection($directory_id, '', true);
        }
        if ($directory_id !== null) {
            $queryParams['directoryId'] = $directory_id;
        }
        // query params
        if (is_array($item_id)) {
            $item_id = ObjectSerializer::serializeCollection($item_id, '', true);
        }
        if ($item_id !== null) {
            $queryParams['itemId'] = $item_id;
        }
        // query params
        if (is_array($shipping_profile_id)) {
            $shipping_profile_id = ObjectSerializer::serializeCollection($shipping_profile_id, '', true);
        }
        if ($shipping_profile_id !== null) {
            $queryParams['shippingProfileId'] = $shipping_profile_id;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsGet
     *
     * List listing markets
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  int $variation_id Filter that restricts the search result to listing markets that match the given variation ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  string $verified Filter that restricts the search result to listing markets that are verified. Available values are &#39;succeeded&#39;,&#39;unknown&#39; or &#39;failed&#39;. (optional)
     * @param  string $duration Filter that restricts the search result to listing markets with given duration. (optional)
     * @param  int $listing_id Filter that restricts the search result to listing markets that belong to a given listing ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int $listing_type_id Filter that restricts the search result to listing markets that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listing markets that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $status Filter that restricts the search result to listing markets with a custom status condition. Available values are &#39;enabled&#39;, &#39;disabled&#39;, &#39;online&#39;, &#39;offline&#39; (optional)
     * @param  string $stock_condition Filter that restricts the search result to listing markets with a custom stock condition. Available values are &#39;stockNetLessEqualZero&#39;, &#39;stockNetLessZero&#39;, &#39;stockNetGreaterZero&#39;, &#39;stockGrossLessEqualZero&#39;, &#39;stockGrossLessZero&#39;, &#39;stockGrossGreaterZero&#39;, &#39;stockNetTotalLessEqualZero&#39;, &#39;stockNetTotalLessZero&#39;, &#39;stockNetTotalGreaterZero&#39; (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  string $updated_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20025
     */
    public function restListingsMarketsGet($page = null, $items_per_page = null, $id = null, $variation_id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $verified = null, $duration = null, $listing_id = null, $item_id = null, $listing_type_id = null, $stock_dependence_type_id = null, $status = null, $stock_condition = null, $shipping_profile_id = null, $updated_at_from = null, $updated_at_to = null, $with = null)
    {
        list($response) = $this->restListingsMarketsGetWithHttpInfo($page, $items_per_page, $id, $variation_id, $variations, $referrer_id, $credentials_id, $directory_id, $verified, $duration, $listing_id, $item_id, $listing_type_id, $stock_dependence_type_id, $status, $stock_condition, $shipping_profile_id, $updated_at_from, $updated_at_to, $with);
        return $response;
    }

    /**
     * Operation restListingsMarketsGetWithHttpInfo
     *
     * List listing markets
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  int $variation_id Filter that restricts the search result to listing markets that match the given variation ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  string $verified Filter that restricts the search result to listing markets that are verified. Available values are &#39;succeeded&#39;,&#39;unknown&#39; or &#39;failed&#39;. (optional)
     * @param  string $duration Filter that restricts the search result to listing markets with given duration. (optional)
     * @param  int $listing_id Filter that restricts the search result to listing markets that belong to a given listing ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int $listing_type_id Filter that restricts the search result to listing markets that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listing markets that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $status Filter that restricts the search result to listing markets with a custom status condition. Available values are &#39;enabled&#39;, &#39;disabled&#39;, &#39;online&#39;, &#39;offline&#39; (optional)
     * @param  string $stock_condition Filter that restricts the search result to listing markets with a custom stock condition. Available values are &#39;stockNetLessEqualZero&#39;, &#39;stockNetLessZero&#39;, &#39;stockNetGreaterZero&#39;, &#39;stockGrossLessEqualZero&#39;, &#39;stockGrossLessZero&#39;, &#39;stockGrossGreaterZero&#39;, &#39;stockNetTotalLessEqualZero&#39;, &#39;stockNetTotalLessZero&#39;, &#39;stockNetTotalGreaterZero&#39; (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  string $updated_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20025, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsGetWithHttpInfo($page = null, $items_per_page = null, $id = null, $variation_id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $verified = null, $duration = null, $listing_id = null, $item_id = null, $listing_type_id = null, $stock_dependence_type_id = null, $status = null, $stock_condition = null, $shipping_profile_id = null, $updated_at_from = null, $updated_at_to = null, $with = null)
    {
        $request = $this->restListingsMarketsGetRequest($page, $items_per_page, $id, $variation_id, $variations, $referrer_id, $credentials_id, $directory_id, $verified, $duration, $listing_id, $item_id, $listing_type_id, $stock_dependence_type_id, $status, $stock_condition, $shipping_profile_id, $updated_at_from, $updated_at_to, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20025' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20025', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20025';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20025',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsGetAsync
     *
     * List listing markets
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  int $variation_id Filter that restricts the search result to listing markets that match the given variation ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  string $verified Filter that restricts the search result to listing markets that are verified. Available values are &#39;succeeded&#39;,&#39;unknown&#39; or &#39;failed&#39;. (optional)
     * @param  string $duration Filter that restricts the search result to listing markets with given duration. (optional)
     * @param  int $listing_id Filter that restricts the search result to listing markets that belong to a given listing ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int $listing_type_id Filter that restricts the search result to listing markets that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listing markets that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $status Filter that restricts the search result to listing markets with a custom status condition. Available values are &#39;enabled&#39;, &#39;disabled&#39;, &#39;online&#39;, &#39;offline&#39; (optional)
     * @param  string $stock_condition Filter that restricts the search result to listing markets with a custom stock condition. Available values are &#39;stockNetLessEqualZero&#39;, &#39;stockNetLessZero&#39;, &#39;stockNetGreaterZero&#39;, &#39;stockGrossLessEqualZero&#39;, &#39;stockGrossLessZero&#39;, &#39;stockGrossGreaterZero&#39;, &#39;stockNetTotalLessEqualZero&#39;, &#39;stockNetTotalLessZero&#39;, &#39;stockNetTotalGreaterZero&#39; (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  string $updated_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsGetAsync($page = null, $items_per_page = null, $id = null, $variation_id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $verified = null, $duration = null, $listing_id = null, $item_id = null, $listing_type_id = null, $stock_dependence_type_id = null, $status = null, $stock_condition = null, $shipping_profile_id = null, $updated_at_from = null, $updated_at_to = null, $with = null)
    {
        return $this->restListingsMarketsGetAsyncWithHttpInfo($page, $items_per_page, $id, $variation_id, $variations, $referrer_id, $credentials_id, $directory_id, $verified, $duration, $listing_id, $item_id, $listing_type_id, $stock_dependence_type_id, $status, $stock_condition, $shipping_profile_id, $updated_at_from, $updated_at_to, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsGetAsyncWithHttpInfo
     *
     * List listing markets
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  int $variation_id Filter that restricts the search result to listing markets that match the given variation ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  string $verified Filter that restricts the search result to listing markets that are verified. Available values are &#39;succeeded&#39;,&#39;unknown&#39; or &#39;failed&#39;. (optional)
     * @param  string $duration Filter that restricts the search result to listing markets with given duration. (optional)
     * @param  int $listing_id Filter that restricts the search result to listing markets that belong to a given listing ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int $listing_type_id Filter that restricts the search result to listing markets that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listing markets that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $status Filter that restricts the search result to listing markets with a custom status condition. Available values are &#39;enabled&#39;, &#39;disabled&#39;, &#39;online&#39;, &#39;offline&#39; (optional)
     * @param  string $stock_condition Filter that restricts the search result to listing markets with a custom stock condition. Available values are &#39;stockNetLessEqualZero&#39;, &#39;stockNetLessZero&#39;, &#39;stockNetGreaterZero&#39;, &#39;stockGrossLessEqualZero&#39;, &#39;stockGrossLessZero&#39;, &#39;stockGrossGreaterZero&#39;, &#39;stockNetTotalLessEqualZero&#39;, &#39;stockNetTotalLessZero&#39;, &#39;stockNetTotalGreaterZero&#39; (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  string $updated_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsGetAsyncWithHttpInfo($page = null, $items_per_page = null, $id = null, $variation_id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $verified = null, $duration = null, $listing_id = null, $item_id = null, $listing_type_id = null, $stock_dependence_type_id = null, $status = null, $stock_condition = null, $shipping_profile_id = null, $updated_at_from = null, $updated_at_to = null, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20025';
        $request = $this->restListingsMarketsGetRequest($page, $items_per_page, $id, $variation_id, $variations, $referrer_id, $credentials_id, $directory_id, $verified, $duration, $listing_id, $item_id, $listing_type_id, $stock_dependence_type_id, $status, $stock_condition, $shipping_profile_id, $updated_at_from, $updated_at_to, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsGet'
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  int $variation_id Filter that restricts the search result to listing markets that match the given variation ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  string $verified Filter that restricts the search result to listing markets that are verified. Available values are &#39;succeeded&#39;,&#39;unknown&#39; or &#39;failed&#39;. (optional)
     * @param  string $duration Filter that restricts the search result to listing markets with given duration. (optional)
     * @param  int $listing_id Filter that restricts the search result to listing markets that belong to a given listing ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int $listing_type_id Filter that restricts the search result to listing markets that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listing markets that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $status Filter that restricts the search result to listing markets with a custom status condition. Available values are &#39;enabled&#39;, &#39;disabled&#39;, &#39;online&#39;, &#39;offline&#39; (optional)
     * @param  string $stock_condition Filter that restricts the search result to listing markets with a custom stock condition. Available values are &#39;stockNetLessEqualZero&#39;, &#39;stockNetLessZero&#39;, &#39;stockNetGreaterZero&#39;, &#39;stockGrossLessEqualZero&#39;, &#39;stockGrossLessZero&#39;, &#39;stockGrossGreaterZero&#39;, &#39;stockNetTotalLessEqualZero&#39;, &#39;stockNetTotalLessZero&#39;, &#39;stockNetTotalGreaterZero&#39; (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  string $updated_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsGetRequest($page = null, $items_per_page = null, $id = null, $variation_id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $verified = null, $duration = null, $listing_id = null, $item_id = null, $listing_type_id = null, $stock_dependence_type_id = null, $status = null, $stock_condition = null, $shipping_profile_id = null, $updated_at_from = null, $updated_at_to = null, $with = null)
    {

        $resourcePath = '/rest/listings/markets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }
        // query params
        if (is_array($id)) {
            $id = ObjectSerializer::serializeCollection($id, '', true);
        }
        if ($id !== null) {
            $queryParams['id'] = $id;
        }
        // query params
        if (is_array($variation_id)) {
            $variation_id = ObjectSerializer::serializeCollection($variation_id, '', true);
        }
        if ($variation_id !== null) {
            $queryParams['variationId'] = $variation_id;
        }
        // query params
        if (is_array($variations)) {
            $variations = ObjectSerializer::serializeCollection($variations, '', true);
        }
        if ($variations !== null) {
            $queryParams['variations'] = $variations;
        }
        // query params
        if (is_array($referrer_id)) {
            $referrer_id = ObjectSerializer::serializeCollection($referrer_id, '', true);
        }
        if ($referrer_id !== null) {
            $queryParams['referrerId'] = $referrer_id;
        }
        // query params
        if (is_array($credentials_id)) {
            $credentials_id = ObjectSerializer::serializeCollection($credentials_id, '', true);
        }
        if ($credentials_id !== null) {
            $queryParams['credentialsId'] = $credentials_id;
        }
        // query params
        if (is_array($directory_id)) {
            $directory_id = ObjectSerializer::serializeCollection($directory_id, '', true);
        }
        if ($directory_id !== null) {
            $queryParams['directoryId'] = $directory_id;
        }
        // query params
        if (is_array($verified)) {
            $verified = ObjectSerializer::serializeCollection($verified, '', true);
        }
        if ($verified !== null) {
            $queryParams['verified'] = $verified;
        }
        // query params
        if (is_array($duration)) {
            $duration = ObjectSerializer::serializeCollection($duration, '', true);
        }
        if ($duration !== null) {
            $queryParams['duration'] = $duration;
        }
        // query params
        if (is_array($listing_id)) {
            $listing_id = ObjectSerializer::serializeCollection($listing_id, '', true);
        }
        if ($listing_id !== null) {
            $queryParams['listingId'] = $listing_id;
        }
        // query params
        if (is_array($item_id)) {
            $item_id = ObjectSerializer::serializeCollection($item_id, '', true);
        }
        if ($item_id !== null) {
            $queryParams['itemId'] = $item_id;
        }
        // query params
        if (is_array($listing_type_id)) {
            $listing_type_id = ObjectSerializer::serializeCollection($listing_type_id, '', true);
        }
        if ($listing_type_id !== null) {
            $queryParams['listingTypeId'] = $listing_type_id;
        }
        // query params
        if (is_array($stock_dependence_type_id)) {
            $stock_dependence_type_id = ObjectSerializer::serializeCollection($stock_dependence_type_id, '', true);
        }
        if ($stock_dependence_type_id !== null) {
            $queryParams['stockDependenceTypeId'] = $stock_dependence_type_id;
        }
        // query params
        if (is_array($status)) {
            $status = ObjectSerializer::serializeCollection($status, '', true);
        }
        if ($status !== null) {
            $queryParams['status'] = $status;
        }
        // query params
        if (is_array($stock_condition)) {
            $stock_condition = ObjectSerializer::serializeCollection($stock_condition, '', true);
        }
        if ($stock_condition !== null) {
            $queryParams['stockCondition'] = $stock_condition;
        }
        // query params
        if (is_array($shipping_profile_id)) {
            $shipping_profile_id = ObjectSerializer::serializeCollection($shipping_profile_id, '', true);
        }
        if ($shipping_profile_id !== null) {
            $queryParams['shippingProfileId'] = $shipping_profile_id;
        }
        // query params
        if (is_array($updated_at_from)) {
            $updated_at_from = ObjectSerializer::serializeCollection($updated_at_from, '', true);
        }
        if ($updated_at_from !== null) {
            $queryParams['updatedAtFrom'] = $updated_at_from;
        }
        // query params
        if (is_array($updated_at_to)) {
            $updated_at_to = ObjectSerializer::serializeCollection($updated_at_to, '', true);
        }
        if ($updated_at_to !== null) {
            $queryParams['updatedAtTo'] = $updated_at_to;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsHistoriesGet
     *
     * List listing market history
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market histories that match the given listing market ID(s). (optional)
     * @param  int $variation_id Filter that restricts the search result to listing market histories that match the given variation ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing market histories with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing market histories with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing market histories with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing market histories with a given directory ID. (optional)
     * @param  string $verified Filter that restricts the search result to listing market histories that are verified. Available values are &#39;succeeded&#39;,&#39;unknown&#39; or &#39;failed&#39;. (optional)
     * @param  string $duration Filter that restricts the search result to listing market histories with given duration. (optional)
     * @param  string $external_id Filter that restricts the search result to listing market histories with given external id. (optional)
     * @param  int $listing_id Filter that restricts the search result to listing market histories that belong to a given listing ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing market histories that belong to a given item ID. (optional)
     * @param  int $listing_type_id Filter that restricts the search result to listing market histories that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listing market histories that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $status_id Filter that restricts the search result to listing market histories with a custom status status ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Active listing market histories&lt;/li&gt;     &lt;li&gt;2 - Ended listing market histories&lt;/li&gt;     &lt;li&gt;3 - Relisted listing market histories&lt;/li&gt;     &lt;li&gt;4 - Hidden listing market histories&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $stock_condition Filter that restricts the search result to listing market histories with a custom stock condition. Available values are &#39;stockNetLessEqualZero&#39;, &#39;stockNetLessZero&#39;, &#39;stockNetGreaterZero&#39;, &#39;stockGrossLessEqualZero&#39;, &#39;stockGrossLessZero&#39;, &#39;stockGrossGreaterZero&#39;, &#39;stockNetTotalLessEqualZero&#39;, &#39;stockNetTotalLessZero&#39;, &#39;stockNetTotalGreaterZero&#39; (optional)
     * @param  string $updated_at_from Filter that restricts the search result to listing market histories that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to listing market histories that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $text_data Filter that restricts the search result to listing market histories that match given text in listing title or description. (optional)
     * @param  string $first_platform_category_id Filter that restricts the search result to listing market histories with first platform category ID equal to the given ID. (optional)
     * @param  string $second_platform_category_id Filter that restricts the search result to listing market histories with second platform category ID equal to the given ID. (optional)
     * @param  string $first_shop_category_id Filter that restricts the search result to listing market histories with first shop category ID equal to the given ID. (optional)
     * @param  string $second_shop_category_id Filter that restricts the search result to listing market histories with second shop category ID equal to the given ID. (optional)
     * @param  string $third_shop_category_id Filter that restricts the search result to listing market histories with third shop category ID equal to the given ID. (optional)
     * @param  string $shipping_profile_id Filter that restricts the search result to listing market histories that belong to a given shipping profile. (optional)
     * @param  string $last_sale Filter that restricts the search result to listing market histories with last sale before given date.The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $is_ebay_plus Filter that restricts the search result to listing market histories that belong to eBay Plus. (optional)
     * @param  string $is_click_and_collect Filter that restricts the search result to listing market histories that belong to eBay Click &amp; Collect. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#39;listingMarket&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20026
     */
    public function restListingsMarketsHistoriesGet($page = null, $items_per_page = null, $listing_market_id = null, $variation_id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $verified = null, $duration = null, $external_id = null, $listing_id = null, $item_id = null, $listing_type_id = null, $stock_dependence_type_id = null, $status_id = null, $stock_condition = null, $updated_at_from = null, $updated_at_to = null, $text_data = null, $first_platform_category_id = null, $second_platform_category_id = null, $first_shop_category_id = null, $second_shop_category_id = null, $third_shop_category_id = null, $shipping_profile_id = null, $last_sale = null, $is_ebay_plus = null, $is_click_and_collect = null, $with = null)
    {
        list($response) = $this->restListingsMarketsHistoriesGetWithHttpInfo($page, $items_per_page, $listing_market_id, $variation_id, $variations, $referrer_id, $credentials_id, $directory_id, $verified, $duration, $external_id, $listing_id, $item_id, $listing_type_id, $stock_dependence_type_id, $status_id, $stock_condition, $updated_at_from, $updated_at_to, $text_data, $first_platform_category_id, $second_platform_category_id, $first_shop_category_id, $second_shop_category_id, $third_shop_category_id, $shipping_profile_id, $last_sale, $is_ebay_plus, $is_click_and_collect, $with);
        return $response;
    }

    /**
     * Operation restListingsMarketsHistoriesGetWithHttpInfo
     *
     * List listing market history
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market histories that match the given listing market ID(s). (optional)
     * @param  int $variation_id Filter that restricts the search result to listing market histories that match the given variation ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing market histories with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing market histories with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing market histories with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing market histories with a given directory ID. (optional)
     * @param  string $verified Filter that restricts the search result to listing market histories that are verified. Available values are &#39;succeeded&#39;,&#39;unknown&#39; or &#39;failed&#39;. (optional)
     * @param  string $duration Filter that restricts the search result to listing market histories with given duration. (optional)
     * @param  string $external_id Filter that restricts the search result to listing market histories with given external id. (optional)
     * @param  int $listing_id Filter that restricts the search result to listing market histories that belong to a given listing ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing market histories that belong to a given item ID. (optional)
     * @param  int $listing_type_id Filter that restricts the search result to listing market histories that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listing market histories that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $status_id Filter that restricts the search result to listing market histories with a custom status status ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Active listing market histories&lt;/li&gt;     &lt;li&gt;2 - Ended listing market histories&lt;/li&gt;     &lt;li&gt;3 - Relisted listing market histories&lt;/li&gt;     &lt;li&gt;4 - Hidden listing market histories&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $stock_condition Filter that restricts the search result to listing market histories with a custom stock condition. Available values are &#39;stockNetLessEqualZero&#39;, &#39;stockNetLessZero&#39;, &#39;stockNetGreaterZero&#39;, &#39;stockGrossLessEqualZero&#39;, &#39;stockGrossLessZero&#39;, &#39;stockGrossGreaterZero&#39;, &#39;stockNetTotalLessEqualZero&#39;, &#39;stockNetTotalLessZero&#39;, &#39;stockNetTotalGreaterZero&#39; (optional)
     * @param  string $updated_at_from Filter that restricts the search result to listing market histories that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to listing market histories that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $text_data Filter that restricts the search result to listing market histories that match given text in listing title or description. (optional)
     * @param  string $first_platform_category_id Filter that restricts the search result to listing market histories with first platform category ID equal to the given ID. (optional)
     * @param  string $second_platform_category_id Filter that restricts the search result to listing market histories with second platform category ID equal to the given ID. (optional)
     * @param  string $first_shop_category_id Filter that restricts the search result to listing market histories with first shop category ID equal to the given ID. (optional)
     * @param  string $second_shop_category_id Filter that restricts the search result to listing market histories with second shop category ID equal to the given ID. (optional)
     * @param  string $third_shop_category_id Filter that restricts the search result to listing market histories with third shop category ID equal to the given ID. (optional)
     * @param  string $shipping_profile_id Filter that restricts the search result to listing market histories that belong to a given shipping profile. (optional)
     * @param  string $last_sale Filter that restricts the search result to listing market histories with last sale before given date.The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $is_ebay_plus Filter that restricts the search result to listing market histories that belong to eBay Plus. (optional)
     * @param  string $is_click_and_collect Filter that restricts the search result to listing market histories that belong to eBay Click &amp; Collect. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#39;listingMarket&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20026, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsHistoriesGetWithHttpInfo($page = null, $items_per_page = null, $listing_market_id = null, $variation_id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $verified = null, $duration = null, $external_id = null, $listing_id = null, $item_id = null, $listing_type_id = null, $stock_dependence_type_id = null, $status_id = null, $stock_condition = null, $updated_at_from = null, $updated_at_to = null, $text_data = null, $first_platform_category_id = null, $second_platform_category_id = null, $first_shop_category_id = null, $second_shop_category_id = null, $third_shop_category_id = null, $shipping_profile_id = null, $last_sale = null, $is_ebay_plus = null, $is_click_and_collect = null, $with = null)
    {
        $request = $this->restListingsMarketsHistoriesGetRequest($page, $items_per_page, $listing_market_id, $variation_id, $variations, $referrer_id, $credentials_id, $directory_id, $verified, $duration, $external_id, $listing_id, $item_id, $listing_type_id, $stock_dependence_type_id, $status_id, $stock_condition, $updated_at_from, $updated_at_to, $text_data, $first_platform_category_id, $second_platform_category_id, $first_shop_category_id, $second_shop_category_id, $third_shop_category_id, $shipping_profile_id, $last_sale, $is_ebay_plus, $is_click_and_collect, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20026' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20026', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20026';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20026',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsHistoriesGetAsync
     *
     * List listing market history
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market histories that match the given listing market ID(s). (optional)
     * @param  int $variation_id Filter that restricts the search result to listing market histories that match the given variation ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing market histories with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing market histories with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing market histories with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing market histories with a given directory ID. (optional)
     * @param  string $verified Filter that restricts the search result to listing market histories that are verified. Available values are &#39;succeeded&#39;,&#39;unknown&#39; or &#39;failed&#39;. (optional)
     * @param  string $duration Filter that restricts the search result to listing market histories with given duration. (optional)
     * @param  string $external_id Filter that restricts the search result to listing market histories with given external id. (optional)
     * @param  int $listing_id Filter that restricts the search result to listing market histories that belong to a given listing ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing market histories that belong to a given item ID. (optional)
     * @param  int $listing_type_id Filter that restricts the search result to listing market histories that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listing market histories that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $status_id Filter that restricts the search result to listing market histories with a custom status status ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Active listing market histories&lt;/li&gt;     &lt;li&gt;2 - Ended listing market histories&lt;/li&gt;     &lt;li&gt;3 - Relisted listing market histories&lt;/li&gt;     &lt;li&gt;4 - Hidden listing market histories&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $stock_condition Filter that restricts the search result to listing market histories with a custom stock condition. Available values are &#39;stockNetLessEqualZero&#39;, &#39;stockNetLessZero&#39;, &#39;stockNetGreaterZero&#39;, &#39;stockGrossLessEqualZero&#39;, &#39;stockGrossLessZero&#39;, &#39;stockGrossGreaterZero&#39;, &#39;stockNetTotalLessEqualZero&#39;, &#39;stockNetTotalLessZero&#39;, &#39;stockNetTotalGreaterZero&#39; (optional)
     * @param  string $updated_at_from Filter that restricts the search result to listing market histories that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to listing market histories that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $text_data Filter that restricts the search result to listing market histories that match given text in listing title or description. (optional)
     * @param  string $first_platform_category_id Filter that restricts the search result to listing market histories with first platform category ID equal to the given ID. (optional)
     * @param  string $second_platform_category_id Filter that restricts the search result to listing market histories with second platform category ID equal to the given ID. (optional)
     * @param  string $first_shop_category_id Filter that restricts the search result to listing market histories with first shop category ID equal to the given ID. (optional)
     * @param  string $second_shop_category_id Filter that restricts the search result to listing market histories with second shop category ID equal to the given ID. (optional)
     * @param  string $third_shop_category_id Filter that restricts the search result to listing market histories with third shop category ID equal to the given ID. (optional)
     * @param  string $shipping_profile_id Filter that restricts the search result to listing market histories that belong to a given shipping profile. (optional)
     * @param  string $last_sale Filter that restricts the search result to listing market histories with last sale before given date.The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $is_ebay_plus Filter that restricts the search result to listing market histories that belong to eBay Plus. (optional)
     * @param  string $is_click_and_collect Filter that restricts the search result to listing market histories that belong to eBay Click &amp; Collect. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#39;listingMarket&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsHistoriesGetAsync($page = null, $items_per_page = null, $listing_market_id = null, $variation_id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $verified = null, $duration = null, $external_id = null, $listing_id = null, $item_id = null, $listing_type_id = null, $stock_dependence_type_id = null, $status_id = null, $stock_condition = null, $updated_at_from = null, $updated_at_to = null, $text_data = null, $first_platform_category_id = null, $second_platform_category_id = null, $first_shop_category_id = null, $second_shop_category_id = null, $third_shop_category_id = null, $shipping_profile_id = null, $last_sale = null, $is_ebay_plus = null, $is_click_and_collect = null, $with = null)
    {
        return $this->restListingsMarketsHistoriesGetAsyncWithHttpInfo($page, $items_per_page, $listing_market_id, $variation_id, $variations, $referrer_id, $credentials_id, $directory_id, $verified, $duration, $external_id, $listing_id, $item_id, $listing_type_id, $stock_dependence_type_id, $status_id, $stock_condition, $updated_at_from, $updated_at_to, $text_data, $first_platform_category_id, $second_platform_category_id, $first_shop_category_id, $second_shop_category_id, $third_shop_category_id, $shipping_profile_id, $last_sale, $is_ebay_plus, $is_click_and_collect, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsHistoriesGetAsyncWithHttpInfo
     *
     * List listing market history
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market histories that match the given listing market ID(s). (optional)
     * @param  int $variation_id Filter that restricts the search result to listing market histories that match the given variation ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing market histories with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing market histories with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing market histories with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing market histories with a given directory ID. (optional)
     * @param  string $verified Filter that restricts the search result to listing market histories that are verified. Available values are &#39;succeeded&#39;,&#39;unknown&#39; or &#39;failed&#39;. (optional)
     * @param  string $duration Filter that restricts the search result to listing market histories with given duration. (optional)
     * @param  string $external_id Filter that restricts the search result to listing market histories with given external id. (optional)
     * @param  int $listing_id Filter that restricts the search result to listing market histories that belong to a given listing ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing market histories that belong to a given item ID. (optional)
     * @param  int $listing_type_id Filter that restricts the search result to listing market histories that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listing market histories that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $status_id Filter that restricts the search result to listing market histories with a custom status status ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Active listing market histories&lt;/li&gt;     &lt;li&gt;2 - Ended listing market histories&lt;/li&gt;     &lt;li&gt;3 - Relisted listing market histories&lt;/li&gt;     &lt;li&gt;4 - Hidden listing market histories&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $stock_condition Filter that restricts the search result to listing market histories with a custom stock condition. Available values are &#39;stockNetLessEqualZero&#39;, &#39;stockNetLessZero&#39;, &#39;stockNetGreaterZero&#39;, &#39;stockGrossLessEqualZero&#39;, &#39;stockGrossLessZero&#39;, &#39;stockGrossGreaterZero&#39;, &#39;stockNetTotalLessEqualZero&#39;, &#39;stockNetTotalLessZero&#39;, &#39;stockNetTotalGreaterZero&#39; (optional)
     * @param  string $updated_at_from Filter that restricts the search result to listing market histories that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to listing market histories that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $text_data Filter that restricts the search result to listing market histories that match given text in listing title or description. (optional)
     * @param  string $first_platform_category_id Filter that restricts the search result to listing market histories with first platform category ID equal to the given ID. (optional)
     * @param  string $second_platform_category_id Filter that restricts the search result to listing market histories with second platform category ID equal to the given ID. (optional)
     * @param  string $first_shop_category_id Filter that restricts the search result to listing market histories with first shop category ID equal to the given ID. (optional)
     * @param  string $second_shop_category_id Filter that restricts the search result to listing market histories with second shop category ID equal to the given ID. (optional)
     * @param  string $third_shop_category_id Filter that restricts the search result to listing market histories with third shop category ID equal to the given ID. (optional)
     * @param  string $shipping_profile_id Filter that restricts the search result to listing market histories that belong to a given shipping profile. (optional)
     * @param  string $last_sale Filter that restricts the search result to listing market histories with last sale before given date.The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $is_ebay_plus Filter that restricts the search result to listing market histories that belong to eBay Plus. (optional)
     * @param  string $is_click_and_collect Filter that restricts the search result to listing market histories that belong to eBay Click &amp; Collect. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#39;listingMarket&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsHistoriesGetAsyncWithHttpInfo($page = null, $items_per_page = null, $listing_market_id = null, $variation_id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $verified = null, $duration = null, $external_id = null, $listing_id = null, $item_id = null, $listing_type_id = null, $stock_dependence_type_id = null, $status_id = null, $stock_condition = null, $updated_at_from = null, $updated_at_to = null, $text_data = null, $first_platform_category_id = null, $second_platform_category_id = null, $first_shop_category_id = null, $second_shop_category_id = null, $third_shop_category_id = null, $shipping_profile_id = null, $last_sale = null, $is_ebay_plus = null, $is_click_and_collect = null, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20026';
        $request = $this->restListingsMarketsHistoriesGetRequest($page, $items_per_page, $listing_market_id, $variation_id, $variations, $referrer_id, $credentials_id, $directory_id, $verified, $duration, $external_id, $listing_id, $item_id, $listing_type_id, $stock_dependence_type_id, $status_id, $stock_condition, $updated_at_from, $updated_at_to, $text_data, $first_platform_category_id, $second_platform_category_id, $first_shop_category_id, $second_shop_category_id, $third_shop_category_id, $shipping_profile_id, $last_sale, $is_ebay_plus, $is_click_and_collect, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsHistoriesGet'
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market histories that match the given listing market ID(s). (optional)
     * @param  int $variation_id Filter that restricts the search result to listing market histories that match the given variation ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing market histories with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing market histories with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing market histories with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing market histories with a given directory ID. (optional)
     * @param  string $verified Filter that restricts the search result to listing market histories that are verified. Available values are &#39;succeeded&#39;,&#39;unknown&#39; or &#39;failed&#39;. (optional)
     * @param  string $duration Filter that restricts the search result to listing market histories with given duration. (optional)
     * @param  string $external_id Filter that restricts the search result to listing market histories with given external id. (optional)
     * @param  int $listing_id Filter that restricts the search result to listing market histories that belong to a given listing ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing market histories that belong to a given item ID. (optional)
     * @param  int $listing_type_id Filter that restricts the search result to listing market histories that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listing market histories that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $status_id Filter that restricts the search result to listing market histories with a custom status status ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Active listing market histories&lt;/li&gt;     &lt;li&gt;2 - Ended listing market histories&lt;/li&gt;     &lt;li&gt;3 - Relisted listing market histories&lt;/li&gt;     &lt;li&gt;4 - Hidden listing market histories&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $stock_condition Filter that restricts the search result to listing market histories with a custom stock condition. Available values are &#39;stockNetLessEqualZero&#39;, &#39;stockNetLessZero&#39;, &#39;stockNetGreaterZero&#39;, &#39;stockGrossLessEqualZero&#39;, &#39;stockGrossLessZero&#39;, &#39;stockGrossGreaterZero&#39;, &#39;stockNetTotalLessEqualZero&#39;, &#39;stockNetTotalLessZero&#39;, &#39;stockNetTotalGreaterZero&#39; (optional)
     * @param  string $updated_at_from Filter that restricts the search result to listing market histories that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to listing market histories that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $text_data Filter that restricts the search result to listing market histories that match given text in listing title or description. (optional)
     * @param  string $first_platform_category_id Filter that restricts the search result to listing market histories with first platform category ID equal to the given ID. (optional)
     * @param  string $second_platform_category_id Filter that restricts the search result to listing market histories with second platform category ID equal to the given ID. (optional)
     * @param  string $first_shop_category_id Filter that restricts the search result to listing market histories with first shop category ID equal to the given ID. (optional)
     * @param  string $second_shop_category_id Filter that restricts the search result to listing market histories with second shop category ID equal to the given ID. (optional)
     * @param  string $third_shop_category_id Filter that restricts the search result to listing market histories with third shop category ID equal to the given ID. (optional)
     * @param  string $shipping_profile_id Filter that restricts the search result to listing market histories that belong to a given shipping profile. (optional)
     * @param  string $last_sale Filter that restricts the search result to listing market histories with last sale before given date.The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $is_ebay_plus Filter that restricts the search result to listing market histories that belong to eBay Plus. (optional)
     * @param  string $is_click_and_collect Filter that restricts the search result to listing market histories that belong to eBay Click &amp; Collect. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#39;listingMarket&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsHistoriesGetRequest($page = null, $items_per_page = null, $listing_market_id = null, $variation_id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $verified = null, $duration = null, $external_id = null, $listing_id = null, $item_id = null, $listing_type_id = null, $stock_dependence_type_id = null, $status_id = null, $stock_condition = null, $updated_at_from = null, $updated_at_to = null, $text_data = null, $first_platform_category_id = null, $second_platform_category_id = null, $first_shop_category_id = null, $second_shop_category_id = null, $third_shop_category_id = null, $shipping_profile_id = null, $last_sale = null, $is_ebay_plus = null, $is_click_and_collect = null, $with = null)
    {

        $resourcePath = '/rest/listings/markets/histories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }
        // query params
        if (is_array($listing_market_id)) {
            $listing_market_id = ObjectSerializer::serializeCollection($listing_market_id, '', true);
        }
        if ($listing_market_id !== null) {
            $queryParams['listingMarketId'] = $listing_market_id;
        }
        // query params
        if (is_array($variation_id)) {
            $variation_id = ObjectSerializer::serializeCollection($variation_id, '', true);
        }
        if ($variation_id !== null) {
            $queryParams['variationId'] = $variation_id;
        }
        // query params
        if (is_array($variations)) {
            $variations = ObjectSerializer::serializeCollection($variations, '', true);
        }
        if ($variations !== null) {
            $queryParams['variations'] = $variations;
        }
        // query params
        if (is_array($referrer_id)) {
            $referrer_id = ObjectSerializer::serializeCollection($referrer_id, '', true);
        }
        if ($referrer_id !== null) {
            $queryParams['referrerId'] = $referrer_id;
        }
        // query params
        if (is_array($credentials_id)) {
            $credentials_id = ObjectSerializer::serializeCollection($credentials_id, '', true);
        }
        if ($credentials_id !== null) {
            $queryParams['credentialsId'] = $credentials_id;
        }
        // query params
        if (is_array($directory_id)) {
            $directory_id = ObjectSerializer::serializeCollection($directory_id, '', true);
        }
        if ($directory_id !== null) {
            $queryParams['directoryId'] = $directory_id;
        }
        // query params
        if (is_array($verified)) {
            $verified = ObjectSerializer::serializeCollection($verified, '', true);
        }
        if ($verified !== null) {
            $queryParams['verified'] = $verified;
        }
        // query params
        if (is_array($duration)) {
            $duration = ObjectSerializer::serializeCollection($duration, '', true);
        }
        if ($duration !== null) {
            $queryParams['duration'] = $duration;
        }
        // query params
        if (is_array($external_id)) {
            $external_id = ObjectSerializer::serializeCollection($external_id, '', true);
        }
        if ($external_id !== null) {
            $queryParams['externalId'] = $external_id;
        }
        // query params
        if (is_array($listing_id)) {
            $listing_id = ObjectSerializer::serializeCollection($listing_id, '', true);
        }
        if ($listing_id !== null) {
            $queryParams['listingId'] = $listing_id;
        }
        // query params
        if (is_array($item_id)) {
            $item_id = ObjectSerializer::serializeCollection($item_id, '', true);
        }
        if ($item_id !== null) {
            $queryParams['itemId'] = $item_id;
        }
        // query params
        if (is_array($listing_type_id)) {
            $listing_type_id = ObjectSerializer::serializeCollection($listing_type_id, '', true);
        }
        if ($listing_type_id !== null) {
            $queryParams['listingTypeId'] = $listing_type_id;
        }
        // query params
        if (is_array($stock_dependence_type_id)) {
            $stock_dependence_type_id = ObjectSerializer::serializeCollection($stock_dependence_type_id, '', true);
        }
        if ($stock_dependence_type_id !== null) {
            $queryParams['stockDependenceTypeId'] = $stock_dependence_type_id;
        }
        // query params
        if (is_array($status_id)) {
            $status_id = ObjectSerializer::serializeCollection($status_id, '', true);
        }
        if ($status_id !== null) {
            $queryParams['statusId'] = $status_id;
        }
        // query params
        if (is_array($stock_condition)) {
            $stock_condition = ObjectSerializer::serializeCollection($stock_condition, '', true);
        }
        if ($stock_condition !== null) {
            $queryParams['stockCondition'] = $stock_condition;
        }
        // query params
        if (is_array($updated_at_from)) {
            $updated_at_from = ObjectSerializer::serializeCollection($updated_at_from, '', true);
        }
        if ($updated_at_from !== null) {
            $queryParams['updatedAtFrom'] = $updated_at_from;
        }
        // query params
        if (is_array($updated_at_to)) {
            $updated_at_to = ObjectSerializer::serializeCollection($updated_at_to, '', true);
        }
        if ($updated_at_to !== null) {
            $queryParams['updatedAtTo'] = $updated_at_to;
        }
        // query params
        if (is_array($text_data)) {
            $text_data = ObjectSerializer::serializeCollection($text_data, '', true);
        }
        if ($text_data !== null) {
            $queryParams['textData'] = $text_data;
        }
        // query params
        if (is_array($first_platform_category_id)) {
            $first_platform_category_id = ObjectSerializer::serializeCollection($first_platform_category_id, '', true);
        }
        if ($first_platform_category_id !== null) {
            $queryParams['firstPlatformCategoryId'] = $first_platform_category_id;
        }
        // query params
        if (is_array($second_platform_category_id)) {
            $second_platform_category_id = ObjectSerializer::serializeCollection($second_platform_category_id, '', true);
        }
        if ($second_platform_category_id !== null) {
            $queryParams['secondPlatformCategoryId'] = $second_platform_category_id;
        }
        // query params
        if (is_array($first_shop_category_id)) {
            $first_shop_category_id = ObjectSerializer::serializeCollection($first_shop_category_id, '', true);
        }
        if ($first_shop_category_id !== null) {
            $queryParams['firstShopCategoryId'] = $first_shop_category_id;
        }
        // query params
        if (is_array($second_shop_category_id)) {
            $second_shop_category_id = ObjectSerializer::serializeCollection($second_shop_category_id, '', true);
        }
        if ($second_shop_category_id !== null) {
            $queryParams['secondShopCategoryId'] = $second_shop_category_id;
        }
        // query params
        if (is_array($third_shop_category_id)) {
            $third_shop_category_id = ObjectSerializer::serializeCollection($third_shop_category_id, '', true);
        }
        if ($third_shop_category_id !== null) {
            $queryParams['thirdShopCategoryId'] = $third_shop_category_id;
        }
        // query params
        if (is_array($shipping_profile_id)) {
            $shipping_profile_id = ObjectSerializer::serializeCollection($shipping_profile_id, '', true);
        }
        if ($shipping_profile_id !== null) {
            $queryParams['shippingProfileId'] = $shipping_profile_id;
        }
        // query params
        if (is_array($last_sale)) {
            $last_sale = ObjectSerializer::serializeCollection($last_sale, '', true);
        }
        if ($last_sale !== null) {
            $queryParams['lastSale'] = $last_sale;
        }
        // query params
        if (is_array($is_ebay_plus)) {
            $is_ebay_plus = ObjectSerializer::serializeCollection($is_ebay_plus, '', true);
        }
        if ($is_ebay_plus !== null) {
            $queryParams['isEbayPlus'] = $is_ebay_plus;
        }
        // query params
        if (is_array($is_click_and_collect)) {
            $is_click_and_collect = ObjectSerializer::serializeCollection($is_click_and_collect, '', true);
        }
        if ($is_click_and_collect !== null) {
            $queryParams['isClickAndCollect'] = $is_click_and_collect;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsHistoriesIdGet
     *
     * Get a listing market history
     *
     * @param  int $id The ID of the listing market history entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#39;listingMarket&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;dates&#39;, &#39;variations&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListingMarketHistory
     */
    public function restListingsMarketsHistoriesIdGet($id, $with = null)
    {
        list($response) = $this->restListingsMarketsHistoriesIdGetWithHttpInfo($id, $with);
        return $response;
    }

    /**
     * Operation restListingsMarketsHistoriesIdGetWithHttpInfo
     *
     * Get a listing market history
     *
     * @param  int $id The ID of the listing market history entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#39;listingMarket&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;dates&#39;, &#39;variations&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListingMarketHistory, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsHistoriesIdGetWithHttpInfo($id, $with = null)
    {
        $request = $this->restListingsMarketsHistoriesIdGetRequest($id, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListingMarketHistory' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListingMarketHistory', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ListingMarketHistory';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListingMarketHistory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsHistoriesIdGetAsync
     *
     * Get a listing market history
     *
     * @param  int $id The ID of the listing market history entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#39;listingMarket&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;dates&#39;, &#39;variations&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsHistoriesIdGetAsync($id, $with = null)
    {
        return $this->restListingsMarketsHistoriesIdGetAsyncWithHttpInfo($id, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsHistoriesIdGetAsyncWithHttpInfo
     *
     * Get a listing market history
     *
     * @param  int $id The ID of the listing market history entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#39;listingMarket&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;dates&#39;, &#39;variations&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsHistoriesIdGetAsyncWithHttpInfo($id, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\ListingMarketHistory';
        $request = $this->restListingsMarketsHistoriesIdGetRequest($id, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsHistoriesIdGet'
     *
     * @param  int $id The ID of the listing market history entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#39;listingMarket&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;dates&#39;, &#39;variations&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsHistoriesIdGetRequest($id, $with = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsHistoriesIdGet'
            );
        }

        $resourcePath = '/rest/listings/markets/histories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsIdDelete
     *
     * Delete listing market
     *
     * @param  int $id The listing market ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restListingsMarketsIdDelete($id)
    {
        list($response) = $this->restListingsMarketsIdDeleteWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restListingsMarketsIdDeleteWithHttpInfo
     *
     * Delete listing market
     *
     * @param  int $id The listing market ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsIdDeleteWithHttpInfo($id)
    {
        $request = $this->restListingsMarketsIdDeleteRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsIdDeleteAsync
     *
     * Delete listing market
     *
     * @param  int $id The listing market ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsIdDeleteAsync($id)
    {
        return $this->restListingsMarketsIdDeleteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsIdDeleteAsyncWithHttpInfo
     *
     * Delete listing market
     *
     * @param  int $id The listing market ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsIdDeleteAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->restListingsMarketsIdDeleteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsIdDelete'
     *
     * @param  int $id The listing market ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsIdDeleteRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsIdDelete'
            );
        }

        $resourcePath = '/rest/listings/markets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsIdGet
     *
     * Get a listing market
     *
     * @param  int $id The ID of the listing market entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;itemSpecifics&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListingMarket
     */
    public function restListingsMarketsIdGet($id, $with = null)
    {
        list($response) = $this->restListingsMarketsIdGetWithHttpInfo($id, $with);
        return $response;
    }

    /**
     * Operation restListingsMarketsIdGetWithHttpInfo
     *
     * Get a listing market
     *
     * @param  int $id The ID of the listing market entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;itemSpecifics&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListingMarket, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsIdGetWithHttpInfo($id, $with = null)
    {
        $request = $this->restListingsMarketsIdGetRequest($id, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListingMarket' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListingMarket', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ListingMarket';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListingMarket',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsIdGetAsync
     *
     * Get a listing market
     *
     * @param  int $id The ID of the listing market entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;itemSpecifics&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsIdGetAsync($id, $with = null)
    {
        return $this->restListingsMarketsIdGetAsyncWithHttpInfo($id, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsIdGetAsyncWithHttpInfo
     *
     * Get a listing market
     *
     * @param  int $id The ID of the listing market entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;itemSpecifics&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsIdGetAsyncWithHttpInfo($id, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\ListingMarket';
        $request = $this->restListingsMarketsIdGetRequest($id, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsIdGet'
     *
     * @param  int $id The ID of the listing market entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;itemSpecifics&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsIdGetRequest($id, $with = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsIdGet'
            );
        }

        $resourcePath = '/rest/listings/markets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsIdPut
     *
     * Update a listing market
     *
     * @param  int $id The listing market ID. (required)
     * @param  int $referrer_id The referrer ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject150 $_rest_listings_markets_id _rest_listings_markets_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListingMarket
     */
    public function restListingsMarketsIdPut($id, $referrer_id, $_rest_listings_markets_id = null)
    {
        list($response) = $this->restListingsMarketsIdPutWithHttpInfo($id, $referrer_id, $_rest_listings_markets_id);
        return $response;
    }

    /**
     * Operation restListingsMarketsIdPutWithHttpInfo
     *
     * Update a listing market
     *
     * @param  int $id The listing market ID. (required)
     * @param  int $referrer_id The referrer ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject150 $_rest_listings_markets_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListingMarket, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsIdPutWithHttpInfo($id, $referrer_id, $_rest_listings_markets_id = null)
    {
        $request = $this->restListingsMarketsIdPutRequest($id, $referrer_id, $_rest_listings_markets_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListingMarket' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListingMarket', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ListingMarket';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListingMarket',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsIdPutAsync
     *
     * Update a listing market
     *
     * @param  int $id The listing market ID. (required)
     * @param  int $referrer_id The referrer ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject150 $_rest_listings_markets_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsIdPutAsync($id, $referrer_id, $_rest_listings_markets_id = null)
    {
        return $this->restListingsMarketsIdPutAsyncWithHttpInfo($id, $referrer_id, $_rest_listings_markets_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsIdPutAsyncWithHttpInfo
     *
     * Update a listing market
     *
     * @param  int $id The listing market ID. (required)
     * @param  int $referrer_id The referrer ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject150 $_rest_listings_markets_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsIdPutAsyncWithHttpInfo($id, $referrer_id, $_rest_listings_markets_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\ListingMarket';
        $request = $this->restListingsMarketsIdPutRequest($id, $referrer_id, $_rest_listings_markets_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsIdPut'
     *
     * @param  int $id The listing market ID. (required)
     * @param  int $referrer_id The referrer ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject150 $_rest_listings_markets_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsIdPutRequest($id, $referrer_id, $_rest_listings_markets_id = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsIdPut'
            );
        }
        // verify the required parameter 'referrer_id' is set
        if ($referrer_id === null || (is_array($referrer_id) && count($referrer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $referrer_id when calling restListingsMarketsIdPut'
            );
        }

        $resourcePath = '/rest/listings/markets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($referrer_id)) {
            $referrer_id = ObjectSerializer::serializeCollection($referrer_id, '', true);
        }
        if ($referrer_id !== null) {
            $queryParams['referrerId'] = $referrer_id;
        }


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_listings_markets_id)) {
            $_tempBody = $_rest_listings_markets_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsInfosGet
     *
     * Search listing market info
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing market info that match the given ID(s). (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market info that match the given listing market ID(s). (optional)
     * @param  string $type Filter that restricts the search result to listing market info with a custom type. Available values are &#39;warning&#39;, &#39;error&#39;, &#39;info&#39;. (optional)
     * @param  int $code Filter that restricts the search result to listing market info with given codes. (optional)
     * @param  string $created_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $with An array with child instances to be loaded. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20027
     */
    public function restListingsMarketsInfosGet($page = null, $items_per_page = null, $id = null, $listing_market_id = null, $type = null, $code = null, $created_at_from = null, $created_at_to = null, $with = null)
    {
        list($response) = $this->restListingsMarketsInfosGetWithHttpInfo($page, $items_per_page, $id, $listing_market_id, $type, $code, $created_at_from, $created_at_to, $with);
        return $response;
    }

    /**
     * Operation restListingsMarketsInfosGetWithHttpInfo
     *
     * Search listing market info
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing market info that match the given ID(s). (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market info that match the given listing market ID(s). (optional)
     * @param  string $type Filter that restricts the search result to listing market info with a custom type. Available values are &#39;warning&#39;, &#39;error&#39;, &#39;info&#39;. (optional)
     * @param  int $code Filter that restricts the search result to listing market info with given codes. (optional)
     * @param  string $created_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $with An array with child instances to be loaded. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20027, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsInfosGetWithHttpInfo($page = null, $items_per_page = null, $id = null, $listing_market_id = null, $type = null, $code = null, $created_at_from = null, $created_at_to = null, $with = null)
    {
        $request = $this->restListingsMarketsInfosGetRequest($page, $items_per_page, $id, $listing_market_id, $type, $code, $created_at_from, $created_at_to, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20027' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20027', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20027';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20027',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsInfosGetAsync
     *
     * Search listing market info
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing market info that match the given ID(s). (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market info that match the given listing market ID(s). (optional)
     * @param  string $type Filter that restricts the search result to listing market info with a custom type. Available values are &#39;warning&#39;, &#39;error&#39;, &#39;info&#39;. (optional)
     * @param  int $code Filter that restricts the search result to listing market info with given codes. (optional)
     * @param  string $created_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $with An array with child instances to be loaded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsInfosGetAsync($page = null, $items_per_page = null, $id = null, $listing_market_id = null, $type = null, $code = null, $created_at_from = null, $created_at_to = null, $with = null)
    {
        return $this->restListingsMarketsInfosGetAsyncWithHttpInfo($page, $items_per_page, $id, $listing_market_id, $type, $code, $created_at_from, $created_at_to, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsInfosGetAsyncWithHttpInfo
     *
     * Search listing market info
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing market info that match the given ID(s). (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market info that match the given listing market ID(s). (optional)
     * @param  string $type Filter that restricts the search result to listing market info with a custom type. Available values are &#39;warning&#39;, &#39;error&#39;, &#39;info&#39;. (optional)
     * @param  int $code Filter that restricts the search result to listing market info with given codes. (optional)
     * @param  string $created_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $with An array with child instances to be loaded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsInfosGetAsyncWithHttpInfo($page = null, $items_per_page = null, $id = null, $listing_market_id = null, $type = null, $code = null, $created_at_from = null, $created_at_to = null, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20027';
        $request = $this->restListingsMarketsInfosGetRequest($page, $items_per_page, $id, $listing_market_id, $type, $code, $created_at_from, $created_at_to, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsInfosGet'
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing market info that match the given ID(s). (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market info that match the given listing market ID(s). (optional)
     * @param  string $type Filter that restricts the search result to listing market info with a custom type. Available values are &#39;warning&#39;, &#39;error&#39;, &#39;info&#39;. (optional)
     * @param  int $code Filter that restricts the search result to listing market info with given codes. (optional)
     * @param  string $created_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int $with An array with child instances to be loaded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsInfosGetRequest($page = null, $items_per_page = null, $id = null, $listing_market_id = null, $type = null, $code = null, $created_at_from = null, $created_at_to = null, $with = null)
    {

        $resourcePath = '/rest/listings/markets/infos';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }
        // query params
        if (is_array($id)) {
            $id = ObjectSerializer::serializeCollection($id, '', true);
        }
        if ($id !== null) {
            $queryParams['id'] = $id;
        }
        // query params
        if (is_array($listing_market_id)) {
            $listing_market_id = ObjectSerializer::serializeCollection($listing_market_id, '', true);
        }
        if ($listing_market_id !== null) {
            $queryParams['listingMarketId'] = $listing_market_id;
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($code)) {
            $code = ObjectSerializer::serializeCollection($code, '', true);
        }
        if ($code !== null) {
            $queryParams['code'] = $code;
        }
        // query params
        if (is_array($created_at_from)) {
            $created_at_from = ObjectSerializer::serializeCollection($created_at_from, '', true);
        }
        if ($created_at_from !== null) {
            $queryParams['createdAtFrom'] = $created_at_from;
        }
        // query params
        if (is_array($created_at_to)) {
            $created_at_to = ObjectSerializer::serializeCollection($created_at_to, '', true);
        }
        if ($created_at_to !== null) {
            $queryParams['createdAtTo'] = $created_at_to;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsItemSpecificsFindGet
     *
     * Gets all ListingMarketItemSpecifics.
     *
     * @param  \OpenAPI\Client\Model\InlineObject146 $_rest_listings_markets_item_specifics_find _rest_listings_markets_item_specifics_find (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20028
     */
    public function restListingsMarketsItemSpecificsFindGet($_rest_listings_markets_item_specifics_find = null)
    {
        list($response) = $this->restListingsMarketsItemSpecificsFindGetWithHttpInfo($_rest_listings_markets_item_specifics_find);
        return $response;
    }

    /**
     * Operation restListingsMarketsItemSpecificsFindGetWithHttpInfo
     *
     * Gets all ListingMarketItemSpecifics.
     *
     * @param  \OpenAPI\Client\Model\InlineObject146 $_rest_listings_markets_item_specifics_find (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20028, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsItemSpecificsFindGetWithHttpInfo($_rest_listings_markets_item_specifics_find = null)
    {
        $request = $this->restListingsMarketsItemSpecificsFindGetRequest($_rest_listings_markets_item_specifics_find);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20028' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20028', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20028';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20028',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsItemSpecificsFindGetAsync
     *
     * Gets all ListingMarketItemSpecifics.
     *
     * @param  \OpenAPI\Client\Model\InlineObject146 $_rest_listings_markets_item_specifics_find (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsItemSpecificsFindGetAsync($_rest_listings_markets_item_specifics_find = null)
    {
        return $this->restListingsMarketsItemSpecificsFindGetAsyncWithHttpInfo($_rest_listings_markets_item_specifics_find)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsItemSpecificsFindGetAsyncWithHttpInfo
     *
     * Gets all ListingMarketItemSpecifics.
     *
     * @param  \OpenAPI\Client\Model\InlineObject146 $_rest_listings_markets_item_specifics_find (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsItemSpecificsFindGetAsyncWithHttpInfo($_rest_listings_markets_item_specifics_find = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20028';
        $request = $this->restListingsMarketsItemSpecificsFindGetRequest($_rest_listings_markets_item_specifics_find);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsItemSpecificsFindGet'
     *
     * @param  \OpenAPI\Client\Model\InlineObject146 $_rest_listings_markets_item_specifics_find (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsItemSpecificsFindGetRequest($_rest_listings_markets_item_specifics_find = null)
    {

        $resourcePath = '/rest/listings/markets/item_specifics/find';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_listings_markets_item_specifics_find)) {
            $_tempBody = $_rest_listings_markets_item_specifics_find;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsItemSpecificsGet
     *
     * Gets all ListingMarketItemSpecifics.
     *
     * @param  \OpenAPI\Client\Model\InlineObject145 $_rest_listings_markets_item_specifics _rest_listings_markets_item_specifics (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListingMarketItemSpecific
     */
    public function restListingsMarketsItemSpecificsGet($_rest_listings_markets_item_specifics = null)
    {
        list($response) = $this->restListingsMarketsItemSpecificsGetWithHttpInfo($_rest_listings_markets_item_specifics);
        return $response;
    }

    /**
     * Operation restListingsMarketsItemSpecificsGetWithHttpInfo
     *
     * Gets all ListingMarketItemSpecifics.
     *
     * @param  \OpenAPI\Client\Model\InlineObject145 $_rest_listings_markets_item_specifics (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListingMarketItemSpecific, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsItemSpecificsGetWithHttpInfo($_rest_listings_markets_item_specifics = null)
    {
        $request = $this->restListingsMarketsItemSpecificsGetRequest($_rest_listings_markets_item_specifics);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListingMarketItemSpecific' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListingMarketItemSpecific', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ListingMarketItemSpecific';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListingMarketItemSpecific',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsItemSpecificsGetAsync
     *
     * Gets all ListingMarketItemSpecifics.
     *
     * @param  \OpenAPI\Client\Model\InlineObject145 $_rest_listings_markets_item_specifics (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsItemSpecificsGetAsync($_rest_listings_markets_item_specifics = null)
    {
        return $this->restListingsMarketsItemSpecificsGetAsyncWithHttpInfo($_rest_listings_markets_item_specifics)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsItemSpecificsGetAsyncWithHttpInfo
     *
     * Gets all ListingMarketItemSpecifics.
     *
     * @param  \OpenAPI\Client\Model\InlineObject145 $_rest_listings_markets_item_specifics (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsItemSpecificsGetAsyncWithHttpInfo($_rest_listings_markets_item_specifics = null)
    {
        $returnType = '\OpenAPI\Client\Model\ListingMarketItemSpecific';
        $request = $this->restListingsMarketsItemSpecificsGetRequest($_rest_listings_markets_item_specifics);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsItemSpecificsGet'
     *
     * @param  \OpenAPI\Client\Model\InlineObject145 $_rest_listings_markets_item_specifics (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsItemSpecificsGetRequest($_rest_listings_markets_item_specifics = null)
    {

        $resourcePath = '/rest/listings/markets/item_specifics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_listings_markets_item_specifics)) {
            $_tempBody = $_rest_listings_markets_item_specifics;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdDelete
     *
     * Deletes a ListingMarketItemSpecific.
     *
     * @param  int $id id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restListingsMarketsItemSpecificsIdDelete($id)
    {
        list($response) = $this->restListingsMarketsItemSpecificsIdDeleteWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdDeleteWithHttpInfo
     *
     * Deletes a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsItemSpecificsIdDeleteWithHttpInfo($id)
    {
        $request = $this->restListingsMarketsItemSpecificsIdDeleteRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdDeleteAsync
     *
     * Deletes a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsItemSpecificsIdDeleteAsync($id)
    {
        return $this->restListingsMarketsItemSpecificsIdDeleteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdDeleteAsyncWithHttpInfo
     *
     * Deletes a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsItemSpecificsIdDeleteAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->restListingsMarketsItemSpecificsIdDeleteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsItemSpecificsIdDelete'
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsItemSpecificsIdDeleteRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsItemSpecificsIdDelete'
            );
        }

        $resourcePath = '/rest/listings/markets/item_specifics/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdGet
     *
     * Gets a ListingMarketItemSpecific.
     *
     * @param  int $id id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListingMarketItemSpecific
     */
    public function restListingsMarketsItemSpecificsIdGet($id)
    {
        list($response) = $this->restListingsMarketsItemSpecificsIdGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdGetWithHttpInfo
     *
     * Gets a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListingMarketItemSpecific, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsItemSpecificsIdGetWithHttpInfo($id)
    {
        $request = $this->restListingsMarketsItemSpecificsIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListingMarketItemSpecific' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListingMarketItemSpecific', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ListingMarketItemSpecific';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListingMarketItemSpecific',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdGetAsync
     *
     * Gets a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsItemSpecificsIdGetAsync($id)
    {
        return $this->restListingsMarketsItemSpecificsIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdGetAsyncWithHttpInfo
     *
     * Gets a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsItemSpecificsIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\OpenAPI\Client\Model\ListingMarketItemSpecific';
        $request = $this->restListingsMarketsItemSpecificsIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsItemSpecificsIdGet'
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsItemSpecificsIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsItemSpecificsIdGet'
            );
        }

        $resourcePath = '/rest/listings/markets/item_specifics/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdPut
     *
     * Updates a ListingMarketItemSpecific.
     *
     * @param  int $id id (required)
     * @param  \OpenAPI\Client\Model\InlineObject147 $_rest_listings_markets_item_specifics_id _rest_listings_markets_item_specifics_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListingMarketItemSpecific
     */
    public function restListingsMarketsItemSpecificsIdPut($id, $_rest_listings_markets_item_specifics_id = null)
    {
        list($response) = $this->restListingsMarketsItemSpecificsIdPutWithHttpInfo($id, $_rest_listings_markets_item_specifics_id);
        return $response;
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdPutWithHttpInfo
     *
     * Updates a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\InlineObject147 $_rest_listings_markets_item_specifics_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListingMarketItemSpecific, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsItemSpecificsIdPutWithHttpInfo($id, $_rest_listings_markets_item_specifics_id = null)
    {
        $request = $this->restListingsMarketsItemSpecificsIdPutRequest($id, $_rest_listings_markets_item_specifics_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListingMarketItemSpecific' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListingMarketItemSpecific', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ListingMarketItemSpecific';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListingMarketItemSpecific',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdPutAsync
     *
     * Updates a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\InlineObject147 $_rest_listings_markets_item_specifics_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsItemSpecificsIdPutAsync($id, $_rest_listings_markets_item_specifics_id = null)
    {
        return $this->restListingsMarketsItemSpecificsIdPutAsyncWithHttpInfo($id, $_rest_listings_markets_item_specifics_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdPutAsyncWithHttpInfo
     *
     * Updates a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\InlineObject147 $_rest_listings_markets_item_specifics_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsItemSpecificsIdPutAsyncWithHttpInfo($id, $_rest_listings_markets_item_specifics_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\ListingMarketItemSpecific';
        $request = $this->restListingsMarketsItemSpecificsIdPutRequest($id, $_rest_listings_markets_item_specifics_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsItemSpecificsIdPut'
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\InlineObject147 $_rest_listings_markets_item_specifics_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsItemSpecificsIdPutRequest($id, $_rest_listings_markets_item_specifics_id = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsItemSpecificsIdPut'
            );
        }

        $resourcePath = '/rest/listings/markets/item_specifics/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_listings_markets_item_specifics_id)) {
            $_tempBody = $_rest_listings_markets_item_specifics_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsPost
     *
     * Create new listing market
     *
     * @param  \OpenAPI\Client\Model\InlineObject142 $_rest_listings_markets _rest_listings_markets (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListingMarket[]
     */
    public function restListingsMarketsPost($_rest_listings_markets = null)
    {
        list($response) = $this->restListingsMarketsPostWithHttpInfo($_rest_listings_markets);
        return $response;
    }

    /**
     * Operation restListingsMarketsPostWithHttpInfo
     *
     * Create new listing market
     *
     * @param  \OpenAPI\Client\Model\InlineObject142 $_rest_listings_markets (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListingMarket[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsPostWithHttpInfo($_rest_listings_markets = null)
    {
        $request = $this->restListingsMarketsPostRequest($_rest_listings_markets);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListingMarket[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListingMarket[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ListingMarket[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListingMarket[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsPostAsync
     *
     * Create new listing market
     *
     * @param  \OpenAPI\Client\Model\InlineObject142 $_rest_listings_markets (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsPostAsync($_rest_listings_markets = null)
    {
        return $this->restListingsMarketsPostAsyncWithHttpInfo($_rest_listings_markets)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsPostAsyncWithHttpInfo
     *
     * Create new listing market
     *
     * @param  \OpenAPI\Client\Model\InlineObject142 $_rest_listings_markets (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsPostAsyncWithHttpInfo($_rest_listings_markets = null)
    {
        $returnType = '\OpenAPI\Client\Model\ListingMarket[]';
        $request = $this->restListingsMarketsPostRequest($_rest_listings_markets);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsPost'
     *
     * @param  \OpenAPI\Client\Model\InlineObject142 $_rest_listings_markets (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsPostRequest($_rest_listings_markets = null)
    {

        $resourcePath = '/rest/listings/markets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_listings_markets)) {
            $_tempBody = $_rest_listings_markets;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsTextsGet
     *
     * List listing market texts
     *
     * @param  int $id Filter that restricts the search result to listing market texts with specific ID. Several IDs can be entered as array. (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market texts with specific listing market IDs. Several IDs can be entered as array. (optional)
     * @param  string $language Filter that restricts the search result to listing market texts for a specific language. @see listing market text model language for the complete available list of language types. (optional)
     * @param  string $contains Filter that restricts the search result to listing market texts which title, subtitle or description contain the given value. (optional)
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20029
     */
    public function restListingsMarketsTextsGet($id = null, $listing_market_id = null, $language = null, $contains = null, $page = null, $items_per_page = null)
    {
        list($response) = $this->restListingsMarketsTextsGetWithHttpInfo($id, $listing_market_id, $language, $contains, $page, $items_per_page);
        return $response;
    }

    /**
     * Operation restListingsMarketsTextsGetWithHttpInfo
     *
     * List listing market texts
     *
     * @param  int $id Filter that restricts the search result to listing market texts with specific ID. Several IDs can be entered as array. (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market texts with specific listing market IDs. Several IDs can be entered as array. (optional)
     * @param  string $language Filter that restricts the search result to listing market texts for a specific language. @see listing market text model language for the complete available list of language types. (optional)
     * @param  string $contains Filter that restricts the search result to listing market texts which title, subtitle or description contain the given value. (optional)
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20029, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsTextsGetWithHttpInfo($id = null, $listing_market_id = null, $language = null, $contains = null, $page = null, $items_per_page = null)
    {
        $request = $this->restListingsMarketsTextsGetRequest($id, $listing_market_id, $language, $contains, $page, $items_per_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20029' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20029', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20029';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20029',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsTextsGetAsync
     *
     * List listing market texts
     *
     * @param  int $id Filter that restricts the search result to listing market texts with specific ID. Several IDs can be entered as array. (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market texts with specific listing market IDs. Several IDs can be entered as array. (optional)
     * @param  string $language Filter that restricts the search result to listing market texts for a specific language. @see listing market text model language for the complete available list of language types. (optional)
     * @param  string $contains Filter that restricts the search result to listing market texts which title, subtitle or description contain the given value. (optional)
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsTextsGetAsync($id = null, $listing_market_id = null, $language = null, $contains = null, $page = null, $items_per_page = null)
    {
        return $this->restListingsMarketsTextsGetAsyncWithHttpInfo($id, $listing_market_id, $language, $contains, $page, $items_per_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsTextsGetAsyncWithHttpInfo
     *
     * List listing market texts
     *
     * @param  int $id Filter that restricts the search result to listing market texts with specific ID. Several IDs can be entered as array. (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market texts with specific listing market IDs. Several IDs can be entered as array. (optional)
     * @param  string $language Filter that restricts the search result to listing market texts for a specific language. @see listing market text model language for the complete available list of language types. (optional)
     * @param  string $contains Filter that restricts the search result to listing market texts which title, subtitle or description contain the given value. (optional)
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsTextsGetAsyncWithHttpInfo($id = null, $listing_market_id = null, $language = null, $contains = null, $page = null, $items_per_page = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20029';
        $request = $this->restListingsMarketsTextsGetRequest($id, $listing_market_id, $language, $contains, $page, $items_per_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsTextsGet'
     *
     * @param  int $id Filter that restricts the search result to listing market texts with specific ID. Several IDs can be entered as array. (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market texts with specific listing market IDs. Several IDs can be entered as array. (optional)
     * @param  string $language Filter that restricts the search result to listing market texts for a specific language. @see listing market text model language for the complete available list of language types. (optional)
     * @param  string $contains Filter that restricts the search result to listing market texts which title, subtitle or description contain the given value. (optional)
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsTextsGetRequest($id = null, $listing_market_id = null, $language = null, $contains = null, $page = null, $items_per_page = null)
    {

        $resourcePath = '/rest/listings/markets/texts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($id)) {
            $id = ObjectSerializer::serializeCollection($id, '', true);
        }
        if ($id !== null) {
            $queryParams['id'] = $id;
        }
        // query params
        if (is_array($listing_market_id)) {
            $listing_market_id = ObjectSerializer::serializeCollection($listing_market_id, '', true);
        }
        if ($listing_market_id !== null) {
            $queryParams['listingMarketId'] = $listing_market_id;
        }
        // query params
        if (is_array($language)) {
            $language = ObjectSerializer::serializeCollection($language, '', true);
        }
        if ($language !== null) {
            $queryParams['language'] = $language;
        }
        // query params
        if (is_array($contains)) {
            $contains = ObjectSerializer::serializeCollection($contains, '', true);
        }
        if ($contains !== null) {
            $queryParams['contains'] = $contains;
        }
        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsTextsIdDelete
     *
     * Delete a listing market text
     *
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  int $id id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restListingsMarketsTextsIdDelete($lang, $listing_market_id, $id)
    {
        list($response) = $this->restListingsMarketsTextsIdDeleteWithHttpInfo($lang, $listing_market_id, $id);
        return $response;
    }

    /**
     * Operation restListingsMarketsTextsIdDeleteWithHttpInfo
     *
     * Delete a listing market text
     *
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  int $id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsTextsIdDeleteWithHttpInfo($lang, $listing_market_id, $id)
    {
        $request = $this->restListingsMarketsTextsIdDeleteRequest($lang, $listing_market_id, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsTextsIdDeleteAsync
     *
     * Delete a listing market text
     *
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsTextsIdDeleteAsync($lang, $listing_market_id, $id)
    {
        return $this->restListingsMarketsTextsIdDeleteAsyncWithHttpInfo($lang, $listing_market_id, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsTextsIdDeleteAsyncWithHttpInfo
     *
     * Delete a listing market text
     *
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsTextsIdDeleteAsyncWithHttpInfo($lang, $listing_market_id, $id)
    {
        $returnType = 'object';
        $request = $this->restListingsMarketsTextsIdDeleteRequest($lang, $listing_market_id, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsTextsIdDelete'
     *
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsTextsIdDeleteRequest($lang, $listing_market_id, $id)
    {
        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lang when calling restListingsMarketsTextsIdDelete'
            );
        }
        // verify the required parameter 'listing_market_id' is set
        if ($listing_market_id === null || (is_array($listing_market_id) && count($listing_market_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $listing_market_id when calling restListingsMarketsTextsIdDelete'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsTextsIdDelete'
            );
        }

        $resourcePath = '/rest/listings/markets/texts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($lang)) {
            $lang = ObjectSerializer::serializeCollection($lang, '', true);
        }
        if ($lang !== null) {
            $queryParams['lang'] = $lang;
        }
        // query params
        if (is_array($listing_market_id)) {
            $listing_market_id = ObjectSerializer::serializeCollection($listing_market_id, '', true);
        }
        if ($listing_market_id !== null) {
            $queryParams['listingMarketId'] = $listing_market_id;
        }


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsTextsIdGet
     *
     * Get a listing market text
     *
     * @param  int $id The ID of the listing market text entry. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListingMarketText
     */
    public function restListingsMarketsTextsIdGet($id)
    {
        list($response) = $this->restListingsMarketsTextsIdGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restListingsMarketsTextsIdGetWithHttpInfo
     *
     * Get a listing market text
     *
     * @param  int $id The ID of the listing market text entry. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListingMarketText, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsTextsIdGetWithHttpInfo($id)
    {
        $request = $this->restListingsMarketsTextsIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListingMarketText' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListingMarketText', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ListingMarketText';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListingMarketText',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsTextsIdGetAsync
     *
     * Get a listing market text
     *
     * @param  int $id The ID of the listing market text entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsTextsIdGetAsync($id)
    {
        return $this->restListingsMarketsTextsIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsTextsIdGetAsyncWithHttpInfo
     *
     * Get a listing market text
     *
     * @param  int $id The ID of the listing market text entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsTextsIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\OpenAPI\Client\Model\ListingMarketText';
        $request = $this->restListingsMarketsTextsIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsTextsIdGet'
     *
     * @param  int $id The ID of the listing market text entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsTextsIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsTextsIdGet'
            );
        }

        $resourcePath = '/rest/listings/markets/texts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsTextsListingMarketIdLangPut
     *
     * Update a listing market text
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  \OpenAPI\Client\Model\InlineObject149 $_rest_listings_markets_texts_listing_market_id_lang _rest_listings_markets_texts_listing_market_id_lang (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListingMarketText
     */
    public function restListingsMarketsTextsListingMarketIdLangPut($listing_market_id, $lang, $_rest_listings_markets_texts_listing_market_id_lang = null)
    {
        list($response) = $this->restListingsMarketsTextsListingMarketIdLangPutWithHttpInfo($listing_market_id, $lang, $_rest_listings_markets_texts_listing_market_id_lang);
        return $response;
    }

    /**
     * Operation restListingsMarketsTextsListingMarketIdLangPutWithHttpInfo
     *
     * Update a listing market text
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  \OpenAPI\Client\Model\InlineObject149 $_rest_listings_markets_texts_listing_market_id_lang (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListingMarketText, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsTextsListingMarketIdLangPutWithHttpInfo($listing_market_id, $lang, $_rest_listings_markets_texts_listing_market_id_lang = null)
    {
        $request = $this->restListingsMarketsTextsListingMarketIdLangPutRequest($listing_market_id, $lang, $_rest_listings_markets_texts_listing_market_id_lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListingMarketText' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListingMarketText', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ListingMarketText';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListingMarketText',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsTextsListingMarketIdLangPutAsync
     *
     * Update a listing market text
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  \OpenAPI\Client\Model\InlineObject149 $_rest_listings_markets_texts_listing_market_id_lang (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsTextsListingMarketIdLangPutAsync($listing_market_id, $lang, $_rest_listings_markets_texts_listing_market_id_lang = null)
    {
        return $this->restListingsMarketsTextsListingMarketIdLangPutAsyncWithHttpInfo($listing_market_id, $lang, $_rest_listings_markets_texts_listing_market_id_lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsTextsListingMarketIdLangPutAsyncWithHttpInfo
     *
     * Update a listing market text
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  \OpenAPI\Client\Model\InlineObject149 $_rest_listings_markets_texts_listing_market_id_lang (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsTextsListingMarketIdLangPutAsyncWithHttpInfo($listing_market_id, $lang, $_rest_listings_markets_texts_listing_market_id_lang = null)
    {
        $returnType = '\OpenAPI\Client\Model\ListingMarketText';
        $request = $this->restListingsMarketsTextsListingMarketIdLangPutRequest($listing_market_id, $lang, $_rest_listings_markets_texts_listing_market_id_lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsTextsListingMarketIdLangPut'
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  \OpenAPI\Client\Model\InlineObject149 $_rest_listings_markets_texts_listing_market_id_lang (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsTextsListingMarketIdLangPutRequest($listing_market_id, $lang, $_rest_listings_markets_texts_listing_market_id_lang = null)
    {
        // verify the required parameter 'listing_market_id' is set
        if ($listing_market_id === null || (is_array($listing_market_id) && count($listing_market_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $listing_market_id when calling restListingsMarketsTextsListingMarketIdLangPut'
            );
        }
        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lang when calling restListingsMarketsTextsListingMarketIdLangPut'
            );
        }

        $resourcePath = '/rest/listings/markets/texts/{listingMarketId}/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($listing_market_id !== null) {
            $resourcePath = str_replace(
                '{' . 'listingMarketId' . '}',
                ObjectSerializer::toPathValue($listing_market_id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_listings_markets_texts_listing_market_id_lang)) {
            $_tempBody = $_rest_listings_markets_texts_listing_market_id_lang;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsTextsPost
     *
     * Create a listing market text
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  \OpenAPI\Client\Model\InlineObject148 $_rest_listings_markets_texts _rest_listings_markets_texts (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListingMarketText
     */
    public function restListingsMarketsTextsPost($listing_market_id, $_rest_listings_markets_texts = null)
    {
        list($response) = $this->restListingsMarketsTextsPostWithHttpInfo($listing_market_id, $_rest_listings_markets_texts);
        return $response;
    }

    /**
     * Operation restListingsMarketsTextsPostWithHttpInfo
     *
     * Create a listing market text
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  \OpenAPI\Client\Model\InlineObject148 $_rest_listings_markets_texts (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListingMarketText, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsTextsPostWithHttpInfo($listing_market_id, $_rest_listings_markets_texts = null)
    {
        $request = $this->restListingsMarketsTextsPostRequest($listing_market_id, $_rest_listings_markets_texts);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListingMarketText' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListingMarketText', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ListingMarketText';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListingMarketText',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsTextsPostAsync
     *
     * Create a listing market text
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  \OpenAPI\Client\Model\InlineObject148 $_rest_listings_markets_texts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsTextsPostAsync($listing_market_id, $_rest_listings_markets_texts = null)
    {
        return $this->restListingsMarketsTextsPostAsyncWithHttpInfo($listing_market_id, $_rest_listings_markets_texts)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsTextsPostAsyncWithHttpInfo
     *
     * Create a listing market text
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  \OpenAPI\Client\Model\InlineObject148 $_rest_listings_markets_texts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsTextsPostAsyncWithHttpInfo($listing_market_id, $_rest_listings_markets_texts = null)
    {
        $returnType = '\OpenAPI\Client\Model\ListingMarketText';
        $request = $this->restListingsMarketsTextsPostRequest($listing_market_id, $_rest_listings_markets_texts);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsTextsPost'
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  \OpenAPI\Client\Model\InlineObject148 $_rest_listings_markets_texts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsTextsPostRequest($listing_market_id, $_rest_listings_markets_texts = null)
    {
        // verify the required parameter 'listing_market_id' is set
        if ($listing_market_id === null || (is_array($listing_market_id) && count($listing_market_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $listing_market_id when calling restListingsMarketsTextsPost'
            );
        }

        $resourcePath = '/rest/listings/markets/texts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($listing_market_id)) {
            $listing_market_id = ObjectSerializer::serializeCollection($listing_market_id, '', true);
        }
        if ($listing_market_id !== null) {
            $queryParams['listingMarketId'] = $listing_market_id;
        }



        // body params
        $_tempBody = null;
        if (isset($_rest_listings_markets_texts)) {
            $_tempBody = $_rest_listings_markets_texts;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsOptionTemplatesIdDelete
     *
     * Delete option template
     *
     * @param  int $id The option template ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restListingsOptionTemplatesIdDelete($id)
    {
        list($response) = $this->restListingsOptionTemplatesIdDeleteWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restListingsOptionTemplatesIdDeleteWithHttpInfo
     *
     * Delete option template
     *
     * @param  int $id The option template ID. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsOptionTemplatesIdDeleteWithHttpInfo($id)
    {
        $request = $this->restListingsOptionTemplatesIdDeleteRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsOptionTemplatesIdDeleteAsync
     *
     * Delete option template
     *
     * @param  int $id The option template ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsOptionTemplatesIdDeleteAsync($id)
    {
        return $this->restListingsOptionTemplatesIdDeleteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsOptionTemplatesIdDeleteAsyncWithHttpInfo
     *
     * Delete option template
     *
     * @param  int $id The option template ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsOptionTemplatesIdDeleteAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->restListingsOptionTemplatesIdDeleteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsOptionTemplatesIdDelete'
     *
     * @param  int $id The option template ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsOptionTemplatesIdDeleteRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsOptionTemplatesIdDelete'
            );
        }

        $resourcePath = '/rest/listings/option_templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsOptionTemplatesIdGet
     *
     * Get option template
     *
     * @param  int $id The ID of the option template entry. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OptionTemplate
     */
    public function restListingsOptionTemplatesIdGet($id)
    {
        list($response) = $this->restListingsOptionTemplatesIdGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restListingsOptionTemplatesIdGetWithHttpInfo
     *
     * Get option template
     *
     * @param  int $id The ID of the option template entry. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OptionTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsOptionTemplatesIdGetWithHttpInfo($id)
    {
        $request = $this->restListingsOptionTemplatesIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OptionTemplate' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OptionTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OptionTemplate';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OptionTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsOptionTemplatesIdGetAsync
     *
     * Get option template
     *
     * @param  int $id The ID of the option template entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsOptionTemplatesIdGetAsync($id)
    {
        return $this->restListingsOptionTemplatesIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsOptionTemplatesIdGetAsyncWithHttpInfo
     *
     * Get option template
     *
     * @param  int $id The ID of the option template entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsOptionTemplatesIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\OpenAPI\Client\Model\OptionTemplate';
        $request = $this->restListingsOptionTemplatesIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsOptionTemplatesIdGet'
     *
     * @param  int $id The ID of the option template entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsOptionTemplatesIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsOptionTemplatesIdGet'
            );
        }

        $resourcePath = '/rest/listings/option_templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsOptionTemplatesIdPut
     *
     * Update option template
     *
     * @param  int $id The option template ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject152 $_rest_listings_option_templates_id _rest_listings_option_templates_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OptionTemplate
     */
    public function restListingsOptionTemplatesIdPut($id, $_rest_listings_option_templates_id = null)
    {
        list($response) = $this->restListingsOptionTemplatesIdPutWithHttpInfo($id, $_rest_listings_option_templates_id);
        return $response;
    }

    /**
     * Operation restListingsOptionTemplatesIdPutWithHttpInfo
     *
     * Update option template
     *
     * @param  int $id The option template ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject152 $_rest_listings_option_templates_id (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OptionTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsOptionTemplatesIdPutWithHttpInfo($id, $_rest_listings_option_templates_id = null)
    {
        $request = $this->restListingsOptionTemplatesIdPutRequest($id, $_rest_listings_option_templates_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OptionTemplate' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OptionTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OptionTemplate';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OptionTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsOptionTemplatesIdPutAsync
     *
     * Update option template
     *
     * @param  int $id The option template ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject152 $_rest_listings_option_templates_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsOptionTemplatesIdPutAsync($id, $_rest_listings_option_templates_id = null)
    {
        return $this->restListingsOptionTemplatesIdPutAsyncWithHttpInfo($id, $_rest_listings_option_templates_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsOptionTemplatesIdPutAsyncWithHttpInfo
     *
     * Update option template
     *
     * @param  int $id The option template ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject152 $_rest_listings_option_templates_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsOptionTemplatesIdPutAsyncWithHttpInfo($id, $_rest_listings_option_templates_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\OptionTemplate';
        $request = $this->restListingsOptionTemplatesIdPutRequest($id, $_rest_listings_option_templates_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsOptionTemplatesIdPut'
     *
     * @param  int $id The option template ID. (required)
     * @param  \OpenAPI\Client\Model\InlineObject152 $_rest_listings_option_templates_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsOptionTemplatesIdPutRequest($id, $_rest_listings_option_templates_id = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsOptionTemplatesIdPut'
            );
        }

        $resourcePath = '/rest/listings/option_templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($_rest_listings_option_templates_id)) {
            $_tempBody = $_rest_listings_option_templates_id;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsOptionTemplatesPost
     *
     * Create option template
     *
     * @param  \OpenAPI\Client\Model\InlineObject151 $_rest_listings_option_templates _rest_listings_option_templates (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OptionTemplate
     */
    public function restListingsOptionTemplatesPost($_rest_listings_option_templates = null)
    {
        list($response) = $this->restListingsOptionTemplatesPostWithHttpInfo($_rest_listings_option_templates);
        return $response;
    }

    /**
     * Operation restListingsOptionTemplatesPostWithHttpInfo
     *
     * Create option template
     *
     * @param  \OpenAPI\Client\Model\InlineObject151 $_rest_listings_option_templates (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OptionTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsOptionTemplatesPostWithHttpInfo($_rest_listings_option_templates = null)
    {
        $request = $this->restListingsOptionTemplatesPostRequest($_rest_listings_option_templates);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OptionTemplate' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OptionTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OptionTemplate';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OptionTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsOptionTemplatesPostAsync
     *
     * Create option template
     *
     * @param  \OpenAPI\Client\Model\InlineObject151 $_rest_listings_option_templates (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsOptionTemplatesPostAsync($_rest_listings_option_templates = null)
    {
        return $this->restListingsOptionTemplatesPostAsyncWithHttpInfo($_rest_listings_option_templates)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsOptionTemplatesPostAsyncWithHttpInfo
     *
     * Create option template
     *
     * @param  \OpenAPI\Client\Model\InlineObject151 $_rest_listings_option_templates (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsOptionTemplatesPostAsyncWithHttpInfo($_rest_listings_option_templates = null)
    {
        $returnType = '\OpenAPI\Client\Model\OptionTemplate';
        $request = $this->restListingsOptionTemplatesPostRequest($_rest_listings_option_templates);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsOptionTemplatesPost'
     *
     * @param  \OpenAPI\Client\Model\InlineObject151 $_rest_listings_option_templates (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsOptionTemplatesPostRequest($_rest_listings_option_templates = null)
    {

        $resourcePath = '/rest/listings/option_templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_listings_option_templates)) {
            $_tempBody = $_rest_listings_option_templates;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsOptionTemplatesPreviewGet
     *
     * Get a preview list of option templates
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function restListingsOptionTemplatesPreviewGet()
    {
        list($response) = $this->restListingsOptionTemplatesPreviewGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restListingsOptionTemplatesPreviewGetWithHttpInfo
     *
     * Get a preview list of option templates
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsOptionTemplatesPreviewGetWithHttpInfo()
    {
        $request = $this->restListingsOptionTemplatesPreviewGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsOptionTemplatesPreviewGetAsync
     *
     * Get a preview list of option templates
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsOptionTemplatesPreviewGetAsync()
    {
        return $this->restListingsOptionTemplatesPreviewGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsOptionTemplatesPreviewGetAsyncWithHttpInfo
     *
     * Get a preview list of option templates
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsOptionTemplatesPreviewGetAsyncWithHttpInfo()
    {
        $returnType = 'object[]';
        $request = $this->restListingsOptionTemplatesPreviewGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsOptionTemplatesPreviewGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsOptionTemplatesPreviewGetRequest()
    {

        $resourcePath = '/rest/listings/option_templates/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsPost
     *
     * Create new listing
     *
     * @param  \OpenAPI\Client\Model\InlineObject140 $_rest_listings _rest_listings (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Listing
     */
    public function restListingsPost($_rest_listings = null)
    {
        list($response) = $this->restListingsPostWithHttpInfo($_rest_listings);
        return $response;
    }

    /**
     * Operation restListingsPostWithHttpInfo
     *
     * Create new listing
     *
     * @param  \OpenAPI\Client\Model\InlineObject140 $_rest_listings (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Listing, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsPostWithHttpInfo($_rest_listings = null)
    {
        $request = $this->restListingsPostRequest($_rest_listings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Listing' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Listing', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Listing';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Listing',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsPostAsync
     *
     * Create new listing
     *
     * @param  \OpenAPI\Client\Model\InlineObject140 $_rest_listings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsPostAsync($_rest_listings = null)
    {
        return $this->restListingsPostAsyncWithHttpInfo($_rest_listings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsPostAsyncWithHttpInfo
     *
     * Create new listing
     *
     * @param  \OpenAPI\Client\Model\InlineObject140 $_rest_listings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsPostAsyncWithHttpInfo($_rest_listings = null)
    {
        $returnType = '\OpenAPI\Client\Model\Listing';
        $request = $this->restListingsPostRequest($_rest_listings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsPost'
     *
     * @param  \OpenAPI\Client\Model\InlineObject140 $_rest_listings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsPostRequest($_rest_listings = null)
    {

        $resourcePath = '/rest/listings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($_rest_listings)) {
            $_tempBody = $_rest_listings;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsShippingProfilesGet
     *
     * List listing shipping profiles
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing shipping profiles that match the given ID(s). (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing shipping profiles with given referrer ID(s). (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing shipping profiles with given credential ID(s). (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20030
     */
    public function restListingsShippingProfilesGet($page = null, $items_per_page = null, $id = null, $referrer_id = null, $credentials_id = null)
    {
        list($response) = $this->restListingsShippingProfilesGetWithHttpInfo($page, $items_per_page, $id, $referrer_id, $credentials_id);
        return $response;
    }

    /**
     * Operation restListingsShippingProfilesGetWithHttpInfo
     *
     * List listing shipping profiles
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing shipping profiles that match the given ID(s). (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing shipping profiles with given referrer ID(s). (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing shipping profiles with given credential ID(s). (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20030, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsShippingProfilesGetWithHttpInfo($page = null, $items_per_page = null, $id = null, $referrer_id = null, $credentials_id = null)
    {
        $request = $this->restListingsShippingProfilesGetRequest($page, $items_per_page, $id, $referrer_id, $credentials_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20030' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20030', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20030';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20030',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsShippingProfilesGetAsync
     *
     * List listing shipping profiles
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing shipping profiles that match the given ID(s). (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing shipping profiles with given referrer ID(s). (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing shipping profiles with given credential ID(s). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsShippingProfilesGetAsync($page = null, $items_per_page = null, $id = null, $referrer_id = null, $credentials_id = null)
    {
        return $this->restListingsShippingProfilesGetAsyncWithHttpInfo($page, $items_per_page, $id, $referrer_id, $credentials_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsShippingProfilesGetAsyncWithHttpInfo
     *
     * List listing shipping profiles
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing shipping profiles that match the given ID(s). (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing shipping profiles with given referrer ID(s). (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing shipping profiles with given credential ID(s). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsShippingProfilesGetAsyncWithHttpInfo($page = null, $items_per_page = null, $id = null, $referrer_id = null, $credentials_id = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20030';
        $request = $this->restListingsShippingProfilesGetRequest($page, $items_per_page, $id, $referrer_id, $credentials_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsShippingProfilesGet'
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing shipping profiles that match the given ID(s). (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing shipping profiles with given referrer ID(s). (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing shipping profiles with given credential ID(s). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsShippingProfilesGetRequest($page = null, $items_per_page = null, $id = null, $referrer_id = null, $credentials_id = null)
    {

        $resourcePath = '/rest/listings/shipping_profiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }
        // query params
        if (is_array($id)) {
            $id = ObjectSerializer::serializeCollection($id, '', true);
        }
        if ($id !== null) {
            $queryParams['id'] = $id;
        }
        // query params
        if (is_array($referrer_id)) {
            $referrer_id = ObjectSerializer::serializeCollection($referrer_id, '', true);
        }
        if ($referrer_id !== null) {
            $queryParams['referrerId'] = $referrer_id;
        }
        // query params
        if (is_array($credentials_id)) {
            $credentials_id = ObjectSerializer::serializeCollection($credentials_id, '', true);
        }
        if ($credentials_id !== null) {
            $queryParams['credentialsId'] = $credentials_id;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsShippingProfilesIdGet
     *
     * Get a shipping profile
     *
     * @param  int $id The ID of the listing shipping profile entry. (required)
     * @param  int $with An array with child instances to be loaded. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ShippingProfile
     */
    public function restListingsShippingProfilesIdGet($id, $with = null)
    {
        list($response) = $this->restListingsShippingProfilesIdGetWithHttpInfo($id, $with);
        return $response;
    }

    /**
     * Operation restListingsShippingProfilesIdGetWithHttpInfo
     *
     * Get a shipping profile
     *
     * @param  int $id The ID of the listing shipping profile entry. (required)
     * @param  int $with An array with child instances to be loaded. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ShippingProfile, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsShippingProfilesIdGetWithHttpInfo($id, $with = null)
    {
        $request = $this->restListingsShippingProfilesIdGetRequest($id, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ShippingProfile' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ShippingProfile', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ShippingProfile';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ShippingProfile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsShippingProfilesIdGetAsync
     *
     * Get a shipping profile
     *
     * @param  int $id The ID of the listing shipping profile entry. (required)
     * @param  int $with An array with child instances to be loaded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsShippingProfilesIdGetAsync($id, $with = null)
    {
        return $this->restListingsShippingProfilesIdGetAsyncWithHttpInfo($id, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsShippingProfilesIdGetAsyncWithHttpInfo
     *
     * Get a shipping profile
     *
     * @param  int $id The ID of the listing shipping profile entry. (required)
     * @param  int $with An array with child instances to be loaded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsShippingProfilesIdGetAsyncWithHttpInfo($id, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\ShippingProfile';
        $request = $this->restListingsShippingProfilesIdGetRequest($id, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsShippingProfilesIdGet'
     *
     * @param  int $id The ID of the listing shipping profile entry. (required)
     * @param  int $with An array with child instances to be loaded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsShippingProfilesIdGetRequest($id, $with = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsShippingProfilesIdGet'
            );
        }

        $resourcePath = '/rest/listings/shipping_profiles/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsStockDependenceTypesGet
     *
     * List listing stock dependence types
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20031
     */
    public function restListingsStockDependenceTypesGet($page = null, $items_per_page = null, $with = null)
    {
        list($response) = $this->restListingsStockDependenceTypesGetWithHttpInfo($page, $items_per_page, $with);
        return $response;
    }

    /**
     * Operation restListingsStockDependenceTypesGetWithHttpInfo
     *
     * List listing stock dependence types
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20031, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsStockDependenceTypesGetWithHttpInfo($page = null, $items_per_page = null, $with = null)
    {
        $request = $this->restListingsStockDependenceTypesGetRequest($page, $items_per_page, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20031' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20031', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20031';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20031',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsStockDependenceTypesGetAsync
     *
     * List listing stock dependence types
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsStockDependenceTypesGetAsync($page = null, $items_per_page = null, $with = null)
    {
        return $this->restListingsStockDependenceTypesGetAsyncWithHttpInfo($page, $items_per_page, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsStockDependenceTypesGetAsyncWithHttpInfo
     *
     * List listing stock dependence types
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsStockDependenceTypesGetAsyncWithHttpInfo($page = null, $items_per_page = null, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20031';
        $request = $this->restListingsStockDependenceTypesGetRequest($page, $items_per_page, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsStockDependenceTypesGet'
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsStockDependenceTypesGetRequest($page = null, $items_per_page = null, $with = null)
    {

        $resourcePath = '/rest/listings/stock_dependence_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }
        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsStockDependenceTypesIdGet
     *
     * Get a listing stock dependence type
     *
     * @param  int $id The ID of the listing stock dependence type entry. (required)
     * @param  int $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\StockDependenceType
     */
    public function restListingsStockDependenceTypesIdGet($id, $with = null)
    {
        list($response) = $this->restListingsStockDependenceTypesIdGetWithHttpInfo($id, $with);
        return $response;
    }

    /**
     * Operation restListingsStockDependenceTypesIdGetWithHttpInfo
     *
     * Get a listing stock dependence type
     *
     * @param  int $id The ID of the listing stock dependence type entry. (required)
     * @param  int $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StockDependenceType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsStockDependenceTypesIdGetWithHttpInfo($id, $with = null)
    {
        $request = $this->restListingsStockDependenceTypesIdGetRequest($id, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\StockDependenceType' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\StockDependenceType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\StockDependenceType';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StockDependenceType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsStockDependenceTypesIdGetAsync
     *
     * Get a listing stock dependence type
     *
     * @param  int $id The ID of the listing stock dependence type entry. (required)
     * @param  int $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsStockDependenceTypesIdGetAsync($id, $with = null)
    {
        return $this->restListingsStockDependenceTypesIdGetAsyncWithHttpInfo($id, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsStockDependenceTypesIdGetAsyncWithHttpInfo
     *
     * Get a listing stock dependence type
     *
     * @param  int $id The ID of the listing stock dependence type entry. (required)
     * @param  int $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsStockDependenceTypesIdGetAsyncWithHttpInfo($id, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\StockDependenceType';
        $request = $this->restListingsStockDependenceTypesIdGetRequest($id, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsStockDependenceTypesIdGet'
     *
     * @param  int $id The ID of the listing stock dependence type entry. (required)
     * @param  int $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsStockDependenceTypesIdGetRequest($id, $with = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsStockDependenceTypesIdGet'
            );
        }

        $resourcePath = '/rest/listings/stock_dependence_types/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsTypesGet
     *
     * List listing types
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20032
     */
    public function restListingsTypesGet($page = null, $items_per_page = null)
    {
        list($response) = $this->restListingsTypesGetWithHttpInfo($page, $items_per_page);
        return $response;
    }

    /**
     * Operation restListingsTypesGetWithHttpInfo
     *
     * List listing types
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20032, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsTypesGetWithHttpInfo($page = null, $items_per_page = null)
    {
        $request = $this->restListingsTypesGetRequest($page, $items_per_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20032' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20032', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20032';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20032',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsTypesGetAsync
     *
     * List listing types
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsTypesGetAsync($page = null, $items_per_page = null)
    {
        return $this->restListingsTypesGetAsyncWithHttpInfo($page, $items_per_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsTypesGetAsyncWithHttpInfo
     *
     * List listing types
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsTypesGetAsyncWithHttpInfo($page = null, $items_per_page = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20032';
        $request = $this->restListingsTypesGetRequest($page, $items_per_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsTypesGet'
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsTypesGetRequest($page = null, $items_per_page = null)
    {

        $resourcePath = '/rest/listings/types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($items_per_page)) {
            $items_per_page = ObjectSerializer::serializeCollection($items_per_page, '', true);
        }
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = $items_per_page;
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsTypesIdGet
     *
     * Get a listing type
     *
     * @param  int $id The ID of the listing type entry. (required)
     * @param  int $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListingType
     */
    public function restListingsTypesIdGet($id, $with = null)
    {
        list($response) = $this->restListingsTypesIdGetWithHttpInfo($id, $with);
        return $response;
    }

    /**
     * Operation restListingsTypesIdGetWithHttpInfo
     *
     * Get a listing type
     *
     * @param  int $id The ID of the listing type entry. (required)
     * @param  int $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListingType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsTypesIdGetWithHttpInfo($id, $with = null)
    {
        $request = $this->restListingsTypesIdGetRequest($id, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListingType' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListingType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ListingType';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListingType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsTypesIdGetAsync
     *
     * Get a listing type
     *
     * @param  int $id The ID of the listing type entry. (required)
     * @param  int $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsTypesIdGetAsync($id, $with = null)
    {
        return $this->restListingsTypesIdGetAsyncWithHttpInfo($id, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsTypesIdGetAsyncWithHttpInfo
     *
     * Get a listing type
     *
     * @param  int $id The ID of the listing type entry. (required)
     * @param  int $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsTypesIdGetAsyncWithHttpInfo($id, $with = null)
    {
        $returnType = '\OpenAPI\Client\Model\ListingType';
        $request = $this->restListingsTypesIdGetRequest($id, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsTypesIdGet'
     *
     * @param  int $id The ID of the listing type entry. (required)
     * @param  int $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsTypesIdGetRequest($id, $with = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsTypesIdGet'
            );
        }

        $resourcePath = '/rest/listings/types/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($with)) {
            $with = ObjectSerializer::serializeCollection($with, '', true);
        }
        if ($with !== null) {
            $queryParams['with'] = $with;
        }


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
